"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var wjcCore = require("wijmo/wijmo");
var wjcSelf = require("wijmo/wijmo.pdf");
window['wijmo'] = window['wijmo'] || {};
window['wijmo']['pdf'] = wjcSelf;
(function (f) { if (typeof localExports === "object" && typeof localModule !== "undefined") {
    localModule.localExports = f();
}
else if (typeof localDefine === "function" && localDefine.amd) {
    localDefine([], f);
}
else {
    var g;
    if (typeof window !== "undefined") {
        g = window;
    }
    else if (typeof global !== "undefined") {
        g = global;
    }
    else if (typeof self !== "undefined") {
        g = self;
    }
    else {
        g = this;
    }
    g.PDFDocument = f();
} })(function () {
    var localDefine, localModule, localExports;
    return (function e(t, n, r) { function s(o, u) { if (!n[o]) {
        if (!t[o]) {
            var a = typeof localRequire == "function" && localRequire;
            if (!u && a)
                return a(o, !0);
            if (i)
                return i(o, !0);
            var f = new Error("Cannot find localModule '" + o + "'");
            throw f.code = "localModule_NOT_FOUND", f;
        }
        var l = n[o] = { localExports: {} };
        t[o][0].call(l.localExports, function (e) { var n = t[o][1][e]; return s(n ? n : e); }, l, l.localExports, e, t, n, r);
    } return n[o].localExports; } var i = typeof localRequire == "function" && localRequire; for (var o = 0; o < r.length; o++)
        s(r[o]); return s; })({
        1: [function (localRequire, localModule, localExports) {
                var Data;
                Data = (function () {
                    function Data(data) {
                        this.data = data != null ? data : [];
                        this.pos = 0;
                        this.length = this.data.length;
                    }
                    Data.prototype.readByte = function () {
                        return this.data[this.pos++];
                    };
                    Data.prototype.writeByte = function (byte) {
                        return this.data[this.pos++] = byte;
                    };
                    Data.prototype.byteAt = function (index) {
                        return this.data[index];
                    };
                    Data.prototype.readBool = function () {
                        return !!this.readByte();
                    };
                    Data.prototype.writeBool = function (val) {
                        return this.writeByte(val ? 1 : 0);
                    };
                    Data.prototype.readUInt32 = function () {
                        var b1, b2, b3, b4;
                        b1 = this.readByte() * 0x1000000;
                        b2 = this.readByte() << 16;
                        b3 = this.readByte() << 8;
                        b4 = this.readByte();
                        return b1 + b2 + b3 + b4;
                    };
                    Data.prototype.writeUInt32 = function (val) {
                        this.writeByte((val >>> 24) & 0xff);
                        this.writeByte((val >> 16) & 0xff);
                        this.writeByte((val >> 8) & 0xff);
                        return this.writeByte(val & 0xff);
                    };
                    Data.prototype.readInt32 = function () {
                        var int;
                        int = this.readUInt32();
                        if (int >= 0x80000000) {
                            return int - 0x100000000;
                        }
                        else {
                            return int;
                        }
                    };
                    Data.prototype.writeInt32 = function (val) {
                        if (val < 0) {
                            val += 0x100000000;
                        }
                        return this.writeUInt32(val);
                    };
                    Data.prototype.readUInt16 = function () {
                        var b1, b2;
                        b1 = this.readByte() << 8;
                        b2 = this.readByte();
                        return b1 | b2;
                    };
                    Data.prototype.writeUInt16 = function (val) {
                        this.writeByte((val >> 8) & 0xff);
                        return this.writeByte(val & 0xff);
                    };
                    Data.prototype.readInt16 = function () {
                        var int;
                        int = this.readUInt16();
                        if (int >= 0x8000) {
                            return int - 0x10000;
                        }
                        else {
                            return int;
                        }
                    };
                    Data.prototype.writeInt16 = function (val) {
                        if (val < 0) {
                            val += 0x10000;
                        }
                        return this.writeUInt16(val);
                    };
                    Data.prototype.readString = function (length) {
                        var i, ret, _i;
                        ret = [];
                        for (i = _i = 0; 0 <= length ? _i < length : _i > length; i = 0 <= length ? ++_i : --_i) {
                            ret[i] = String.fromCharCode(this.readByte());
                        }
                        return ret.join('');
                    };
                    Data.prototype.writeString = function (val) {
                        var i, _i, _ref, _results;
                        _results = [];
                        for (i = _i = 0, _ref = val.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
                            _results.push(this.writeByte(val.charCodeAt(i)));
                        }
                        return _results;
                    };
                    Data.prototype.stringAt = function (pos, length) {
                        this.pos = pos;
                        return this.readString(length);
                    };
                    Data.prototype.readShort = function () {
                        return this.readInt16();
                    };
                    Data.prototype.writeShort = function (val) {
                        return this.writeInt16(val);
                    };
                    Data.prototype.readLongLong = function () {
                        var b1, b2, b3, b4, b5, b6, b7, b8;
                        b1 = this.readByte();
                        b2 = this.readByte();
                        b3 = this.readByte();
                        b4 = this.readByte();
                        b5 = this.readByte();
                        b6 = this.readByte();
                        b7 = this.readByte();
                        b8 = this.readByte();
                        if (b1 & 0x80) {
                            return ((b1 ^ 0xff) * 0x100000000000000 + (b2 ^ 0xff) * 0x1000000000000 + (b3 ^ 0xff) * 0x10000000000 + (b4 ^ 0xff) * 0x100000000 + (b5 ^ 0xff) * 0x1000000 + (b6 ^ 0xff) * 0x10000 + (b7 ^ 0xff) * 0x100 + (b8 ^ 0xff) + 1) * -1;
                        }
                        return b1 * 0x100000000000000 + b2 * 0x1000000000000 + b3 * 0x10000000000 + b4 * 0x100000000 + b5 * 0x1000000 + b6 * 0x10000 + b7 * 0x100 + b8;
                    };
                    Data.prototype.writeLongLong = function (val) {
                        var high, low;
                        high = Math.floor(val / 0x100000000);
                        low = val & 0xffffffff;
                        this.writeByte((high >> 24) & 0xff);
                        this.writeByte((high >> 16) & 0xff);
                        this.writeByte((high >> 8) & 0xff);
                        this.writeByte(high & 0xff);
                        this.writeByte((low >> 24) & 0xff);
                        this.writeByte((low >> 16) & 0xff);
                        this.writeByte((low >> 8) & 0xff);
                        return this.writeByte(low & 0xff);
                    };
                    Data.prototype.readInt = function () {
                        return this.readInt32();
                    };
                    Data.prototype.writeInt = function (val) {
                        return this.writeInt32(val);
                    };
                    Data.prototype.slice = function (start, end) {
                        return this.data.slice(start, end);
                    };
                    Data.prototype.read = function (bytes) {
                        var buf, i, _i;
                        buf = [];
                        for (i = _i = 0; 0 <= bytes ? _i < bytes : _i > bytes; i = 0 <= bytes ? ++_i : --_i) {
                            buf.push(this.readByte());
                        }
                        return buf;
                    };
                    Data.prototype.write = function (bytes) {
                        var byte, _i, _len, _results;
                        _results = [];
                        for (_i = 0, _len = bytes.length; _i < _len; _i++) {
                            byte = bytes[_i];
                            _results.push(this.writeByte(byte));
                        }
                        return _results;
                    };
                    return Data;
                })();
                localModule.localExports = Data;
            }, {}], 2: [function (localRequire, localModule, localExports) {
                (function (Buffer) {
                    var PDFDocument, PDFObject, PDFPage, PDFReference, fs, stream, __hasProp = {}.hasOwnProperty, __extends = function (child, parent) { for (var key in parent) {
                        if (__hasProp.call(parent, key))
                            child[key] = parent[key];
                    } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                    stream = localRequire('stream');
                    fs = localRequire('fs');
                    PDFObject = localRequire('./object');
                    PDFReference = localRequire('./reference');
                    PDFPage = localRequire('./page');
                    PDFDocument = (function (_super) {
                        var mixin;
                        __extends(PDFDocument, _super);
                        function PDFDocument(options) {
                            var key, val, _ref, _ref1;
                            this.options = options != null ? options : {};
                            PDFDocument.__super__.constructor.apply(this, arguments);
                            this.version = 1.3;
                            this.compress = (_ref = this.options.compress) != null ? _ref : true;
                            this._pageBuffer = [];
                            this._pageBufferStart = 0;
                            this._offsets = [];
                            this._waiting = 0;
                            this._ended = false;
                            this._offset = 0;
                            this._root = this.ref({
                                Type: 'Catalog',
                                Pages: this.ref({
                                    Type: 'Pages',
                                    Count: 0,
                                    Kids: []
                                })
                            });
                            this.page = null;
                            this.initColor();
                            this.initVector();
                            this.initFonts();
                            this.initText();
                            this.initImages();
                            this.info = {
                                Producer: 'PDFKit',
                                Creator: 'PDFKit',
                                CreationDate: new Date()
                            };
                            if (this.options.info) {
                                _ref1 = this.options.info;
                                for (key in _ref1) {
                                    val = _ref1[key];
                                    this.info[key] = val;
                                }
                            }
                            this._write("%PDF-" + this.version);
                            this._write("%\xFF\xFF\xFF\xFF");
                            if (this.options.pageAdding) {
                                this.on('pageAdding', this.options.pageAdding);
                            }
                            if (this.options.pageAdded) {
                                this.on('pageAdded', this.options.pageAdded);
                            }
                            if (this.options.autoFirstPage !== false) {
                                this.addPage();
                            }
                        }
                        mixin = function (methods) {
                            var method, name, _results;
                            _results = [];
                            for (name in methods) {
                                method = methods[name];
                                _results.push(PDFDocument.prototype[name] = method);
                            }
                            return _results;
                        };
                        mixin(localRequire('./mixins/color'));
                        mixin(localRequire('./mixins/vector'));
                        mixin(localRequire('./mixins/fonts'));
                        mixin(localRequire('./mixins/text'));
                        mixin(localRequire('./mixins/images'));
                        mixin(localRequire('./mixins/annotations'));
                        PDFDocument.prototype.addPage = function (options) {
                            var pages;
                            if (options == null) {
                                options = this.options;
                            }
                            this.emit('pageAdding', this, options);
                            if (!this.options.bufferPages) {
                                this.flushPages();
                            }
                            this.page = new PDFPage(this, options);
                            this._pageBuffer.push(this.page);
                            pages = this._root.data.Pages.data;
                            pages.Kids.push(this.page.dictionary);
                            pages.Count++;
                            this.x = this.page.margins.left;
                            this.y = this.page.margins.top;
                            this._ctm = [1, 0, 0, 1, 0, 0];
                            this.transform(1, 0, 0, -1, 0, this.page.height);
                            this.emit('pageAdded', this);
                            return this;
                        };
                        PDFDocument.prototype.bufferedPageRange = function () {
                            return {
                                start: this._pageBufferStart,
                                count: this._pageBuffer.length
                            };
                        };
                        PDFDocument.prototype.switchToPage = function (n) {
                            var page;
                            if (!(page = this._pageBuffer[n - this._pageBufferStart])) {
                                throw new Error("switchToPage(" + n + ") out of bounds, current buffer covers pages " + this._pageBufferStart + " to " + (this._pageBufferStart + this._pageBuffer.length - 1));
                            }
                            return this.page = page;
                        };
                        PDFDocument.prototype.flushPages = function () {
                            var page, pages, _i, _len;
                            pages = this._pageBuffer;
                            this._pageBuffer = [];
                            this._pageBufferStart += pages.length;
                            for (_i = 0, _len = pages.length; _i < _len; _i++) {
                                page = pages[_i];
                                page.end();
                            }
                        };
                        PDFDocument.prototype.ref = function (data) {
                            var ref;
                            ref = new PDFReference(this, this._offsets.length + 1, data);
                            this._offsets.push(null);
                            this._waiting++;
                            return ref;
                        };
                        PDFDocument.prototype._read = function () { };
                        PDFDocument.prototype._write = function (data) {
                            if (!Buffer.isBuffer(data)) {
                                data = new Buffer(data + '\n', 'binary');
                            }
                            this.push(data);
                            return this._offset += data.length;
                        };
                        PDFDocument.prototype.addContent = function (data) {
                            this.page.write(data);
                            return this;
                        };
                        PDFDocument.prototype._refEnd = function (ref) {
                            this._offsets[ref.id - 1] = ref.offset;
                            if (--this._waiting === 0 && this._ended) {
                                this._finalize();
                                return this._ended = false;
                            }
                        };
                        PDFDocument.prototype.write = function (filename, fn) {
                            var err;
                            err = new Error('PDFDocument#write is deprecated, and will be removed in a future version of PDFKit. Please pipe the document into a Node stream.');
                            console.warn(err.stack);
                            this.pipe(fs.createWriteStream(filename));
                            this.end();
                            return this.once('end', fn);
                        };
                        PDFDocument.prototype.output = function (fn) {
                            throw new Error('PDFDocument#output is deprecated, and has been removed from PDFKit. Please pipe the document into a Node stream.');
                        };
                        PDFDocument.prototype.end = function () {
                            var font, key, name, val, _ref, _ref1;
                            this.emit('ending');
                            this.flushPages();
                            this._info = this.ref();
                            _ref = this.info;
                            for (key in _ref) {
                                val = _ref[key];
                                if (typeof val === 'string') {
                                    val = new String(val);
                                }
                                this._info.data[key] = val;
                            }
                            this._info.end();
                            _ref1 = this._fontFamilies;
                            for (name in _ref1) {
                                font = _ref1[name];
                                font.finalize();
                            }
                            this._root.end();
                            this._root.data.Pages.end();
                            if (this._waiting === 0) {
                                return this._finalize();
                            }
                            else {
                                return this._ended = true;
                            }
                        };
                        PDFDocument.prototype._finalize = function (fn) {
                            var offset, xRefOffset, _i, _len, _ref;
                            xRefOffset = this._offset;
                            this._write("xref");
                            this._write("0 " + (this._offsets.length + 1));
                            this._write("0000000000 65535 f ");
                            _ref = this._offsets;
                            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                                offset = _ref[_i];
                                offset = ('0000000000' + offset).slice(-10);
                                this._write(offset + ' 00000 n ');
                            }
                            this._write('trailer');
                            this._write(PDFObject.convert({
                                Size: this._offsets.length + 1,
                                Root: this._root,
                                Info: this._info
                            }));
                            this._write('startxref');
                            this._write("" + xRefOffset);
                            this._write('%%EOF');
                            return this.push(null);
                        };
                        PDFDocument.prototype.toString = function () {
                            return "[object PDFDocument]";
                        };
                        return PDFDocument;
                    })(stream.Readable);
                    localModule.localExports = PDFDocument;
                }).call(this, localRequire("buffer").Buffer);
            }, { "./mixins/annotations": 12, "./mixins/color": 13, "./mixins/fonts": 14, "./mixins/images": 15, "./mixins/text": 16, "./mixins/vector": 17, "./object": 18, "./page": 19, "./reference": 21, "buffer": 60, "fs": 59, "stream": 216 }], 3: [function (localRequire, localModule, localExports) {
                (function (Buffer) {
                    var EmbeddedFont, PDFFont, StandardFont, fontkit;
                    fontkit = localRequire('fontkit');
                    PDFFont = (function () {
                        PDFFont.open = function (document, src, family, id) {
                            var font;
                            if (typeof src === 'string') {
                                if (StandardFont.isStandardFont(src)) {
                                    return new StandardFont(document, src, id);
                                }
                            }
                            else if (Buffer.isBuffer(src)) {
                                font = fontkit.create(src, family);
                            }
                            else if (src instanceof Uint8Array) {
                                font = fontkit.create(new Buffer(src), family);
                            }
                            else if (src instanceof ArrayBuffer) {
                                font = fontkit.create(new Buffer(new Uint8Array(src)), family);
                            }
                            if (font == null) {
                                throw new Error('Not a supported font format or standard PDF font.');
                            }
                            return new EmbeddedFont(document, font, id);
                        };
                        function PDFFont() {
                            throw new Error('Cannot construct a PDFFont directly.');
                        }
                        PDFFont.prototype.encode = function (text) {
                            throw new Error('Must be implemented by subclasses');
                        };
                        PDFFont.prototype.widthOfString = function (text) {
                            throw new Error('Must be implemented by subclasses');
                        };
                        PDFFont.prototype.ref = function () {
                            return this.dictionary != null ? this.dictionary : this.dictionary = this.document.ref();
                        };
                        PDFFont.prototype.finalize = function () {
                            if (this.embedded || (this.dictionary == null)) {
                                return;
                            }
                            this.embed();
                            return this.embedded = true;
                        };
                        PDFFont.prototype.embed = function () {
                            throw new Error('Must be implemented by subclasses');
                        };
                        PDFFont.prototype.lineHeight = function (size, includeGap) {
                            var gap;
                            if (includeGap == null) {
                                includeGap = false;
                            }
                            gap = includeGap ? this.lineGap : 0;
                            return (this.ascender + gap - this.descender) / 1000 * size;
                        };
                        PDFFont.prototype.getAscender = function (size) {
                            return this.ascender / 1000 * size;
                        };
                        PDFFont.prototype.getBBox = function (size) {
                            return {
                                llx: this.bbox[0] / 1000 * size,
                                lly: this.bbox[1] / 1000 * size,
                                urx: this.bbox[2] / 1000 * size,
                                ury: this.bbox[3] / 1000 * size,
                            };
                        };
                        return PDFFont;
                    })();
                    localModule.localExports = PDFFont;
                    StandardFont = localRequire('./font/standard');
                    EmbeddedFont = localRequire('./font/embedded');
                }).call(this, localRequire("buffer").Buffer);
            }, { "./font/embedded": 5, "./font/standard": 6, "buffer": 60, "fontkit": 165 }], 4: [function (localRequire, localModule, localExports) {
                var AFMFont, fs;
                var base64 = localRequire('base64-js');
                AFMFont = (function () {
                    var WIN_ANSI_MAP = { 402: 131, 8211: 150, 8212: 151, 8216: 145, 8217: 146, 8218: 130, 8220: 147, 8221: 148, 8222: 132, 8224: 134, 8225: 135, 8226: 149, 8230: 133, 8364: 128, 8240: 137, 8249: 139, 8250: 155, 710: 136, 8482: 153, 338: 140, 339: 156, 732: 152, 352: 138, 353: 154, 376: 159, 381: 142, 382: 158 };
                    var CHAR_TABLE = "space:exclam:quotedbl:numbersign:dollar:percent:ampersand:quoteright:parenleft:parenright:asterisk:plus:comma:hyphen:period:slash:zero:one:two:three:four:five:six:seven:eight:nine:colon:semicolon:less:equal:greater:question:at:A:B:C:D:E:F:G:H:I:J:K:L:M:N:O:P:Q:R:S:T:U:V:W:X:Y:Z:bracketleft:backslash:bracketright:asciicircum:underscore:quoteleft:a:b:c:d:e:f:g:h:i:j:k:l:m:n:o:p:q:r:s:t:u:v:w:x:y:z:braceleft:bar:braceright:asciitilde:exclamdown:cent:sterling:fraction:yen:florin:section:currency:quotesingle:quotedblleft:guillemotleft:guilsinglleft:guilsinglright:fi:fl:endash:dagger:daggerdbl:periodcentered:paragraph:bullet:quotesinglbase:quotedblbase:quotedblright:guillemotright:ellipsis:perthousand:questiondown:grave:acute:circumflex:tilde:macron:breve:dotaccent:dieresis:ring:cedilla:hungarumlaut:ogonek:caron:emdash:AE:ordfeminine:Lslash:Oslash:OE:ordmasculine:ae:dotlessi:lslash:oslash:oe:germandbls:Idieresis:eacute:abreve:uhungarumlaut:ecaron:Ydieresis:divide:Yacute:Acircumflex:aacute:Ucircumflex:yacute:scommaaccent:ecircumflex:Uring:Udieresis:aogonek:Uacute:uogonek:Edieresis:Dcroat:commaaccent:copyright:Emacron:ccaron:aring:Ncommaaccent:lacute:agrave:Tcommaaccent:Cacute:atilde:Edotaccent:scaron:scedilla:iacute:lozenge:Rcaron:Gcommaaccent:ucircumflex:acircumflex:Amacron:rcaron:ccedilla:Zdotaccent:Thorn:Omacron:Racute:Sacute:dcaron:Umacron:uring:threesuperior:Ograve:Agrave:Abreve:multiply:uacute:Tcaron:partialdiff:ydieresis:Nacute:icircumflex:Ecircumflex:adieresis:edieresis:cacute:nacute:umacron:Ncaron:Iacute:plusminus:brokenbar:registered:Gbreve:Idotaccent:summation:Egrave:racute:omacron:Zacute:Zcaron:greaterequal:Eth:Ccedilla:lcommaaccent:tcaron:eogonek:Uogonek:Aacute:Adieresis:egrave:zacute:iogonek:Oacute:oacute:amacron:sacute:idieresis:Ocircumflex:Ugrave:Delta:thorn:twosuperior:Odieresis:mu:igrave:ohungarumlaut:Eogonek:dcroat:threequarters:Scedilla:lcaron:Kcommaaccent:Lacute:trademark:edotaccent:Igrave:Imacron:Lcaron:onehalf:lessequal:ocircumflex:ntilde:Uhungarumlaut:Eacute:emacron:gbreve:onequarter:Scaron:Scommaaccent:Ohungarumlaut:degree:ograve:Ccaron:ugrave:radical:Dcaron:rcommaaccent:Ntilde:otilde:Rcommaaccent:Lcommaaccent:Atilde:Aogonek:Aring:Otilde:zdotaccent:Ecaron:Iogonek:kcommaaccent:minus:Icircumflex:ncaron:tcommaaccent:logicalnot:odieresis:udieresis:notequal:gcommaaccent:eth:zcaron:ncommaaccent:onesuperior:imacron:Euro:universal:existential:suchthat:asteriskmath:congruent:Alpha:Beta:Chi:Epsilon:Phi:Gamma:Eta:Iota:theta1:Kappa:Lambda:Mu:Nu:Omicron:Pi:Theta:Rho:Sigma:Tau:Upsilon:sigma1:Omega:Xi:Psi:Zeta:therefore:perpendicular:radicalex:alpha:beta:chi:delta:epsilon:phi:gamma:eta:iota:phi1:kappa:lambda:nu:omicron:pi:theta:rho:sigma:tau:upsilon:omega1:omega:xi:psi:zeta:similar:Upsilon1:minute:infinity:club:diamond:heart:spade:arrowboth:arrowleft:arrowup:arrowright:arrowdown:second:proportional:equivalence:approxequal:arrowvertex:arrowhorizex:carriagereturn:aleph:Ifraktur:Rfraktur:weierstrass:circlemultiply:circleplus:emptyset:intersection:union:propersuperset:reflexsuperset:notsubset:propersubset:reflexsubset:element:notelement:angle:gradient:registerserif:copyrightserif:trademarkserif:product:dotmath:logicaland:logicalor:arrowdblboth:arrowdblleft:arrowdblup:arrowdblright:arrowdbldown:angleleft:registersans:copyrightsans:trademarksans:parenlefttp:parenleftex:parenleftbt:bracketlefttp:bracketleftex:bracketleftbt:bracelefttp:braceleftmid:braceleftbt:braceex:angleright:integral:integraltp:integralex:integralbt:parenrighttp:parenrightex:parenrightbt:bracketrighttp:bracketrightex:bracketrightbt:bracerighttp:bracerightmid:bracerightbt:apple:a1:a2:a202:a3:a4:a5:a119:a118:a117:a11:a12:a13:a14:a15:a16:a105:a17:a18:a19:a20:a21:a22:a23:a24:a25:a26:a27:a28:a6:a7:a8:a9:a10:a29:a30:a31:a32:a33:a34:a35:a36:a37:a38:a39:a40:a41:a42:a43:a44:a45:a46:a47:a48:a49:a50:a51:a52:a53:a54:a55:a56:a57:a58:a59:a60:a61:a62:a63:a64:a65:a66:a67:a68:a69:a70:a71:a72:a73:a74:a203:a75:a204:a76:a77:a78:a79:a81:a82:a83:a84:a97:a98:a99:a100:a89:a90:a93:a94:a91:a92:a205:a85:a206:a86:a87:a88:a95:a96:a101:a102:a103:a104:a106:a107:a108:a112:a111:a110:a109:a120:a121:a122:a123:a124:a125:a126:a127:a128:a129:a130:a131:a132:a133:a134:a135:a136:a137:a138:a139:a140:a141:a142:a143:a144:a145:a146:a147:a148:a149:a150:a151:a152:a153:a154:a155:a156:a157:a158:a159:a160:a161:a163:a164:a196:a165:a192:a166:a167:a168:a169:a170:a171:a172:a173:a162:a174:a175:a176:a177:a178:a179:a193:a180:a199:a181:a200:a182:a201:a183:a184:a197:a185:a194:a198:a186:a195:a187:a188:a189:a190:a191".split(":"), CHARACTERS = ".notdef .notdef .notdef .notdef .notdef .notdef .notdef .notdef .notdef .notdef .notdef .notdef .notdef .notdef .notdef .notdef .notdef .notdef .notdef .notdef .notdef .notdef .notdef .notdef .notdef .notdef .notdef .notdef .notdef .notdef .notdef .notdef space exclam quotedbl numbersign dollar percent ampersand quotesingle parenleft parenright asterisk plus comma hyphen period slash zero one two three four five six seven eight nine colon semicolon less equal greater question at A B C D E F G H I J K L M N O P Q R S T U V W X Y Z bracketleft backslash bracketright asciicircum underscore grave a b c d e f g h i j k l m n o p q r s t u v w x y z braceleft bar braceright asciitilde .notdef Euro .notdef quotesinglbase florin quotedblbase ellipsis dagger daggerdbl circumflex perthousand Scaron guilsinglleft OE .notdef Zcaron .notdef .notdef quoteleft quoteright quotedblleft quotedblright bullet endash emdash tilde trademark scaron guilsinglright oe .notdef zcaron ydieresis space exclamdown cent sterling currency yen brokenbar section dieresis copyright ordfeminine guillemotleft logicalnot hyphen registered macron degree plusminus twosuperior threesuperior acute mu paragraph periodcentered cedilla onesuperior ordmasculine guillemotright onequarter onehalf threequarters questiondown Agrave Aacute Acircumflex Atilde Adieresis Aring AE Ccedilla Egrave Eacute Ecircumflex Edieresis Igrave Iacute Icircumflex Idieresis Eth Ntilde Ograve Oacute Ocircumflex Otilde Odieresis multiply Oslash Ugrave Uacute Ucircumflex Udieresis Yacute Thorn germandbls agrave aacute acircumflex atilde adieresis aring ae ccedilla egrave eacute ecircumflex edieresis igrave iacute icircumflex idieresis eth ntilde ograve oacute ocircumflex otilde odieresis divide oslash ugrave uacute ucircumflex udieresis yacute thorn ydieresis".split(" ");
                    function AFMFont(contents) {
                        this.bbox = this._parseFontBBox(contents[1]);
                        this.ascender = contents[4];
                        this.descender = contents[5];
                        this.glyphWidths = this._parseGlyphWidths(contents[6]);
                        this.charWidths = this._getCharWidths();
                        this.kernPairs = this._parseKerningPairs(contents[7]);
                        this.lineGap = (this.bbox[3] - this.bbox[1]) - (this.ascender - this.descender);
                    }
                    AFMFont.prototype.encodeText = function (text) {
                        var res = [];
                        for (var i = 0; i < text.length; i++) {
                            var char = text.charCodeAt(i);
                            char = WIN_ANSI_MAP[char] || char;
                            res.push(char.toString(16));
                        }
                        return res;
                    };
                    AFMFont.prototype.glyphsForString = function (text) {
                        var res = [];
                        for (var i = 0; i < text.length; i++) {
                            var charCode = text.charCodeAt(i);
                            res.push(this.characterToGlyph(charCode));
                        }
                        return res;
                    };
                    AFMFont.prototype.characterToGlyph = function (character) {
                        return CHARACTERS[WIN_ANSI_MAP[character] || character] || '.notdef';
                    };
                    AFMFont.prototype.widthOfGlyph = function (glyph) {
                        return this.glyphWidths[glyph] || 0;
                    };
                    AFMFont.prototype.getKernPair = function (left, right) {
                        return this.kernPairs[left + '\0' + right] || 0;
                    };
                    AFMFont.prototype.advancesForGlyphs = function (glyphs) {
                        var res = [];
                        for (var i = 0; i < glyphs.length; i++) {
                            var left = glyphs[i], right = glyphs[i + 1];
                            res.push(this.widthOfGlyph(left) + this.getKernPair(left, right));
                        }
                        return res;
                    };
                    AFMFont.prototype._parseFontBBox = function (val) {
                        var tmp = val.split(":"), res = [];
                        for (var i = 0; i < tmp.length; i++) {
                            res.push(parseInt(tmp[i]));
                        }
                        return res;
                    };
                    AFMFont.prototype._getCharWidths = function () {
                        var res = [];
                        for (var i = 0; i <= 255; i++) {
                            res.push(this.glyphWidths[CHARACTERS[i]]);
                        }
                        return res;
                    };
                    AFMFont.prototype._parseGlyphWidths = function (val) {
                        var widths = val.split(","), res = {}, width;
                        if (widths.length === 1) {
                            var m = widths[0].match(/(^\d+)-(\d+):(\d+)$/), start = parseInt(m[1]), end = parseInt(m[2]);
                            width = parseInt(m[3]);
                            for (var i = start; i <= end; i++) {
                                res[CHAR_TABLE[i]] = width;
                            }
                        }
                        else {
                            var charTableIndex = 0;
                            for (var i = 0; i < widths.length; i++) {
                                var pair = widths[i].split(":");
                                if (pair.length == 1) {
                                    width = parseInt(pair[0]);
                                }
                                else {
                                    charTableIndex = parseInt(pair[0]);
                                    width = parseInt(pair[1]);
                                }
                                res[CHAR_TABLE[charTableIndex++]] = width;
                            }
                        }
                        return res;
                    };
                    AFMFont.prototype._parseKerningPairs = function (val) {
                        var res = {};
                        return res;
                    };
                    return AFMFont;
                })();
                localModule.localExports = AFMFont;
            }, { "base64-js": 45 }], 5: [function (localRequire, localModule, localExports) {
                var EmbeddedFont, PDFFont, PDFObject, __hasProp = {}.hasOwnProperty, __extends = function (child, parent) { for (var key in parent) {
                    if (__hasProp.call(parent, key))
                        child[key] = parent[key];
                } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }, __slice = [].slice;
                PDFFont = localRequire('../font');
                PDFObject = localRequire('../object');
                EmbeddedFont = (function (_super) {
                    var toHex;
                    __extends(EmbeddedFont, _super);
                    function EmbeddedFont(document, font, id) {
                        this.document = document;
                        this.font = font;
                        this.id = id;
                        this.subset = this.font.createSubset();
                        this.unicode = [[0]];
                        this.widths = [this.font.getGlyph(0).advanceWidth];
                        this.name = this.font.postscriptName;
                        this.scale = 1000 / this.font.unitsPerEm;
                        this.ascender = this.font.ascent * this.scale;
                        this.descender = this.font.descent * this.scale;
                        this.lineGap = this.font.lineGap * this.scale;
                        this.bbox = this.font.bbox;
                    }
                    EmbeddedFont.prototype.encode = function (text, features) {
                        var gid, glyph, glyphs, i, key, positions, res, _base, _base1, _i, _len, _ref;
                        _ref = this.font.layout(text, features), glyphs = _ref.glyphs, positions = _ref.positions;
                        res = [];
                        for (i = _i = 0, _len = glyphs.length; _i < _len; i = ++_i) {
                            glyph = glyphs[i];
                            gid = this.subset.includeGlyph(glyph.id);
                            res.push(('0000' + gid.toString(16)).slice(-4));
                            if ((_base = this.widths)[gid] == null) {
                                _base[gid] = glyph.advanceWidth * this.scale;
                            }
                            if ((_base1 = this.unicode)[gid] == null) {
                                _base1[gid] = glyph.codePoints;
                            }
                            for (key in positions[i]) {
                                positions[i][key] *= this.scale;
                            }
                            positions[i].advanceWidth = glyph.advanceWidth * this.scale;
                        }
                        return [res, positions];
                    };
                    EmbeddedFont.prototype.widthOfString = function (string, size, features) {
                        var scale, width;
                        width = this.font.layout(string, features).advanceWidth;
                        scale = size / this.font.unitsPerEm;
                        return width * scale;
                    };
                    EmbeddedFont.prototype.embed = function () {
                        var bbox, descendantFont, descriptor, familyClass, flags, fontFile, i, isCFF, name, tag, _ref;
                        fontFile = this.document.ref();
                        this.subset.encodeStream().pipe(fontFile);
                        familyClass = (((_ref = this.font['OS/2']) != null ? _ref.sFamilyClass : void 0) || 0) >> 8;
                        flags = 0;
                        if (this.font.post.isFixedPitch) {
                            flags |= 1 << 0;
                        }
                        if ((1 <= familyClass && familyClass <= 7)) {
                            flags |= 1 << 1;
                        }
                        flags |= 1 << 2;
                        if (familyClass === 10) {
                            flags |= 1 << 3;
                        }
                        if (this.font.head.macStyle.italic) {
                            flags |= 1 << 6;
                        }
                        tag = ((function () {
                            var _i, _results;
                            _results = [];
                            for (i = _i = 0; _i < 6; i = ++_i) {
                                _results.push(String.fromCharCode(Math.random() * 26 + 65));
                            }
                            return _results;
                        })()).join('');
                        name = tag + '+' + this.font.postscriptName;
                        bbox = this.font.bbox;
                        descriptor = this.document.ref({
                            Type: 'FontDescriptor',
                            FontName: name,
                            Flags: flags,
                            FontBBox: [bbox.minX * this.scale, bbox.minY * this.scale, bbox.maxX * this.scale, bbox.maxY * this.scale],
                            ItalicAngle: this.font.italicAngle,
                            Ascent: this.ascender,
                            Descent: this.descender,
                            CapHeight: (this.font.capHeight || this.font.ascent) * this.scale,
                            XHeight: (this.font.xHeight || 0) * this.scale,
                            StemV: 0
                        });
                        if (isCFF) {
                            descriptor.data.FontFile3 = fontFile;
                        }
                        else {
                            descriptor.data.FontFile2 = fontFile;
                        }
                        descriptor.end();
                        descendantFont = this.document.ref({
                            Type: 'Font',
                            Subtype: 'CIDFontType2',
                            BaseFont: name,
                            CIDSystemInfo: {
                                Registry: new String('Adobe'),
                                Ordering: new String('Identity'),
                                Supplement: 0
                            },
                            FontDescriptor: descriptor,
                            W: [0, this.widths]
                        });
                        descendantFont.end();
                        this.dictionary.data = {
                            Type: 'Font',
                            Subtype: 'Type0',
                            BaseFont: name,
                            Encoding: 'Identity-H',
                            DescendantFonts: [descendantFont],
                            ToUnicode: this.toUnicodeCmap()
                        };
                        return this.dictionary.end();
                    };
                    toHex = function () {
                        var code, codePoints, codes;
                        codePoints = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
                        codes = (function () {
                            var _i, _len, _results;
                            _results = [];
                            for (_i = 0, _len = codePoints.length; _i < _len; _i++) {
                                code = codePoints[_i];
                                _results.push(('0000' + code.toString(16)).slice(-4));
                            }
                            return _results;
                        })();
                        return codes.join('');
                    };
                    EmbeddedFont.prototype.toUnicodeCmap = function () {
                        var cmap, codePoints, encoded, entries, value, _i, _j, _len, _len1, _ref;
                        cmap = this.document.ref();
                        entries = [];
                        _ref = this.unicode;
                        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                            codePoints = _ref[_i];
                            encoded = [];
                            for (_j = 0, _len1 = codePoints.length; _j < _len1; _j++) {
                                value = codePoints[_j];
                                if (value > 0xffff) {
                                    value -= 0x10000;
                                    encoded.push(toHex(value >>> 10 & 0x3ff | 0xd800));
                                    value = 0xdc00 | value & 0x3ff;
                                }
                                encoded.push(toHex(value));
                            }
                            entries.push("<" + (encoded.join(' ')) + ">");
                        }
                        cmap.end("/CIDInit /ProcSet findresource begin\n12 dict begin\nbegincmap\n/CIDSystemInfo <<\n  /Registry (Adobe)\n  /Ordering (UCS)\n  /Supplement 0\n>> def\n/CMapName /Adobe-Identity-UCS def\n/CMapType 2 def\n1 begincodespacerange\n<0000><ffff>\nendcodespacerange\n1 beginbfrange\n<0000> <" + (toHex(entries.length - 1)) + "> [" + (entries.join(' ')) + "]\nendbfrange\nendcmap\nCMapName currentdict /CMap defineresource pop\nend\nend");
                        return cmap;
                    };
                    return EmbeddedFont;
                })(PDFFont);
                localModule.localExports = EmbeddedFont;
            }, { "../font": 3, "../object": 18 }], 6: [function (localRequire, localModule, localExports) {
                var AFMFont, PDFFont, StandardFont, fs, __hasProp = {}.hasOwnProperty, __extends = function (child, parent) { for (var key in parent) {
                    if (__hasProp.call(parent, key))
                        child[key] = parent[key];
                } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                AFMFont = localRequire('./afm');
                PDFFont = localRequire('../font');
                fs = localRequire('fs');
                StandardFont = (function (_super) {
                    var STANDARD_FONTS;
                    __extends(StandardFont, _super);
                    function StandardFont(document, name, id) {
                        var _ref;
                        this.document = document;
                        this.name = name;
                        this.id = id;
                        this.font = new AFMFont(STANDARD_FONTS[this.name]());
                        _ref = this.font, this.ascender = _ref.ascender, this.descender = _ref.descender, this.bbox = _ref.bbox, this.lineGap = _ref.lineGap;
                    }
                    StandardFont.prototype.embed = function () {
                        this.dictionary.data = {
                            Type: 'Font',
                            BaseFont: this.name,
                            Subtype: 'Type1',
                            Encoding: 'WinAnsiEncoding'
                        };
                        return this.dictionary.end();
                    };
                    StandardFont.prototype.encode = function (text) {
                        var advances, encoded, glyph, glyphs, i, positions, _i, _len;
                        encoded = this.font.encodeText(text);
                        glyphs = this.font.glyphsForString('' + text);
                        advances = this.font.advancesForGlyphs(glyphs);
                        positions = [];
                        for (i = _i = 0, _len = glyphs.length; _i < _len; i = ++_i) {
                            glyph = glyphs[i];
                            positions.push({
                                xAdvance: advances[i],
                                yAdvance: 0,
                                xOffset: 0,
                                yOffset: 0,
                                advanceWidth: this.font.widthOfGlyph(glyph)
                            });
                        }
                        return [encoded, positions];
                    };
                    StandardFont.prototype.widthOfString = function (string, size) {
                        var advance, advances, glyphs, scale, width, _i, _len;
                        glyphs = this.font.glyphsForString('' + string);
                        advances = this.font.advancesForGlyphs(glyphs);
                        width = 0;
                        for (_i = 0, _len = advances.length; _i < _len; _i++) {
                            advance = advances[_i];
                            width += advance;
                        }
                        scale = size / 1000;
                        return width * scale;
                    };
                    StandardFont.isStandardFont = function (name) {
                        return name in STANDARD_FONTS;
                    };
                    STANDARD_FONTS = {
                        "Courier": function () {
                            return [0, "-23:-250:715:805", 562, 426, 629, -157, "0-314:600"];
                        },
                        "Courier-Bold": function () {
                            return [0, "-113:-250:749:801", 562, 439, 629, -157, "0-314:600"];
                        },
                        "Courier-Oblique": function () {
                            return [-12, "-27:-250:849:805", 562, 426, 629, -157, "0-314:600"];
                        },
                        "Courier-BoldOblique": function () {
                            return [-12, "-57:-250:869:801", 562, 439, 629, -157, "0-314:600"];
                        },
                        "Helvetica": function () {
                            return [0, "-166:-225:1000:931", 718, 523, 718, -207, "278,278,355,556,556,889,667,222,333,333,389,584,278,333,278,278,556,556,556,556,556,556,556,556,556,556,278,278,584,584,584,556,1015,667,667,722,722,667,611,778,722,278,500,667,556,833,722,778,667,778,722,667,611,722,667,944,667,667,611,278,278,278,469,556,222,556,556,500,556,556,278,556,556,222,222,500,222,833,556,556,556,556,333,500,278,556,500,722,500,500,500,334,260,334,584,333,556,556,167,556,556,556,556,191,333,556,333,333,500,500,556,556,556,278,537,350,222,333,333,556,1000,1000,611,333,333,333,333,333,333,333,333,333,333,333,333,333,1000,1000,370,556,778,1000,365,889,278,222,611,944,611,278,556,556,556,556,667,584,667,667,556,722,500,500,556,722,722,556,722,556,667,722,250,737,667,500,556,722,222,556,611,722,556,667,500,500,278,471,722,778,556,556,667,333,500,611,667,778,722,667,643,722,556,333,778,667,667,584,556,611,476,500,722,278,667,556,556,500,556,556,722,278,584,260,737,778,278,600,667,333,556,611,611,549,722,722,222,317,556,722,667,667,556,500,222,778,556,556,500,278,778,722,612,556,333,778,556,278,556,667,556,834,667,299,667,556,1000,556,278,278,556,834,549,556,556,722,667,556,556,834,667,667,778,400,556,722,556,453,722,333,722,556,722,556,667,667,667,778,500,667,278,500,584,278,556,278,584,556,556,549,556,556,500,556,333,278,556"];
                        },
                        "Helvetica-Bold": function () {
                            return [0, "-170:-228:1003:962", 718, 532, 718, -207, "278,333,474,556,556,889,722,278,333,333,389,584,278,333,278,278,556,556,556,556,556,556,556,556,556,556,333,333,584,584,584,611,975,722,722,722,722,667,611,778,722,278,556,722,611,833,722,778,667,778,722,667,611,722,667,944,667,667,611,333,278,333,584,556,278,556,611,556,611,556,333,611,611,278,278,556,278,889,611,611,611,611,389,556,333,611,556,778,556,556,500,389,280,389,584,333,556,556,167,556,556,556,556,238,500,556,333,333,611,611,556,556,556,278,556,350,278,500,500,556,1000,1000,611,333,333,333,333,333,333,333,333,333,333,333,333,333,1000,1000,370,611,778,1000,365,889,278,278,611,944,611,278,556,556,611,556,667,584,667,722,556,722,556,556,556,722,722,556,722,611,667,722,250,737,667,556,556,722,278,556,611,722,556,667,556,556,278,494,722,778,611,556,722,389,556,611,667,778,722,667,743,722,611,333,778,722,722,584,611,611,494,556,722,278,667,556,556,556,611,611,722,278,584,280,737,778,278,600,667,389,611,611,611,549,722,722,278,389,556,722,722,722,556,500,278,778,611,556,556,278,778,722,612,611,333,778,611,278,611,667,611,834,667,400,722,611,1000,556,278,278,611,834,549,611,611,722,667,556,611,834,667,667,778,400,611,722,611,549,722,389,722,611,722,611,722,722,722,778,500,667,278,556,584,278,611,333,584,611,611,549,611,611,500,611,333,278,556"];
                        },
                        "Helvetica-Oblique": function () {
                            return [-12, "-170:-225:1116:931", 718, 523, 718, -207, "278,278,355,556,556,889,667,222,333,333,389,584,278,333,278,278,556,556,556,556,556,556,556,556,556,556,278,278,584,584,584,556,1015,667,667,722,722,667,611,778,722,278,500,667,556,833,722,778,667,778,722,667,611,722,667,944,667,667,611,278,278,278,469,556,222,556,556,500,556,556,278,556,556,222,222,500,222,833,556,556,556,556,333,500,278,556,500,722,500,500,500,334,260,334,584,333,556,556,167,556,556,556,556,191,333,556,333,333,500,500,556,556,556,278,537,350,222,333,333,556,1000,1000,611,333,333,333,333,333,333,333,333,333,333,333,333,333,1000,1000,370,556,778,1000,365,889,278,222,611,944,611,278,556,556,556,556,667,584,667,667,556,722,500,500,556,722,722,556,722,556,667,722,250,737,667,500,556,722,222,556,611,722,556,667,500,500,278,471,722,778,556,556,667,333,500,611,667,778,722,667,643,722,556,333,778,667,667,584,556,611,476,500,722,278,667,556,556,500,556,556,722,278,584,260,737,778,278,600,667,333,556,611,611,549,722,722,222,317,556,722,667,667,556,500,222,778,556,556,500,278,778,722,612,556,333,778,556,278,556,667,556,834,667,299,667,556,1000,556,278,278,556,834,549,556,556,722,667,556,556,834,667,667,778,400,556,722,556,453,722,333,722,556,722,556,667,667,667,778,500,667,278,500,584,278,556,278,584,556,556,549,556,556,500,556,333,278,556"];
                        },
                        "Helvetica-BoldOblique": function () {
                            return [-12, "-174:-228:1114:962", 718, 532, 718, -207, "278,333,474,556,556,889,722,278,333,333,389,584,278,333,278,278,556,556,556,556,556,556,556,556,556,556,333,333,584,584,584,611,975,722,722,722,722,667,611,778,722,278,556,722,611,833,722,778,667,778,722,667,611,722,667,944,667,667,611,333,278,333,584,556,278,556,611,556,611,556,333,611,611,278,278,556,278,889,611,611,611,611,389,556,333,611,556,778,556,556,500,389,280,389,584,333,556,556,167,556,556,556,556,238,500,556,333,333,611,611,556,556,556,278,556,350,278,500,500,556,1000,1000,611,333,333,333,333,333,333,333,333,333,333,333,333,333,1000,1000,370,611,778,1000,365,889,278,278,611,944,611,278,556,556,611,556,667,584,667,722,556,722,556,556,556,722,722,556,722,611,667,722,250,737,667,556,556,722,278,556,611,722,556,667,556,556,278,494,722,778,611,556,722,389,556,611,667,778,722,667,743,722,611,333,778,722,722,584,611,611,494,556,722,278,667,556,556,556,611,611,722,278,584,280,737,778,278,600,667,389,611,611,611,549,722,722,278,389,556,722,722,722,556,500,278,778,611,556,556,278,778,722,612,611,333,778,611,278,611,667,611,834,667,400,722,611,1000,556,278,278,611,834,549,611,611,722,667,556,611,834,667,667,778,400,611,722,611,549,722,389,722,611,722,611,722,722,722,778,500,667,278,556,584,278,611,333,584,611,611,549,611,611,500,611,333,278,556"];
                        },
                        "Times-Roman": function () {
                            return [0, "-168:-218:1000:898", 662, 450, 683, -217, "250,333,408,500,500,833,778,333,333,333,500,564,250,333,250,278,500,500,500,500,500,500,500,500,500,500,278,278,564,564,564,444,921,722,667,667,722,611,556,722,722,333,389,722,611,889,722,722,556,722,667,556,611,722,722,944,722,722,611,333,278,333,469,500,333,444,500,444,500,444,333,500,500,278,278,500,278,778,500,500,500,500,333,389,278,500,500,722,500,500,444,480,200,480,541,333,500,500,167,500,500,500,500,180,444,500,333,333,556,556,500,500,500,250,453,350,333,444,444,500,1000,1000,444,333,333,333,333,333,333,333,333,333,333,333,333,333,1000,889,276,611,722,889,310,667,278,278,500,722,500,333,444,444,500,444,722,564,722,722,444,722,500,389,444,722,722,444,722,500,611,722,250,760,611,444,444,722,278,444,611,667,444,611,389,389,278,471,667,722,500,444,722,333,444,611,556,722,667,556,588,722,500,300,722,722,722,564,500,611,476,500,722,278,611,444,444,444,500,500,722,333,564,200,760,722,333,600,611,333,500,611,611,549,722,667,278,326,444,722,722,722,444,444,278,722,500,444,389,278,722,722,612,500,300,722,500,278,500,611,500,750,556,344,722,611,980,444,333,333,611,750,549,500,500,722,611,444,500,750,556,556,722,400,500,667,500,453,722,333,722,500,667,611,722,722,722,722,444,611,333,500,564,333,500,278,564,500,500,549,500,500,444,500,300,278,500"];
                        },
                        "Times-Bold": function () {
                            return [0, "-168:-218:1000:935", 676, 461, 683, -217, "250,333,555,500,500,1000,833,333,333,333,500,570,250,333,250,278,500,500,500,500,500,500,500,500,500,500,333,333,570,570,570,500,930,722,667,722,722,667,611,778,778,389,500,778,667,944,722,778,611,778,722,556,667,722,722,1000,722,722,667,333,278,333,581,500,333,500,556,444,556,444,333,500,556,278,333,556,278,833,556,500,556,556,444,389,333,556,500,722,500,500,444,394,220,394,520,333,500,500,167,500,500,500,500,278,500,500,333,333,556,556,500,500,500,250,540,350,333,500,500,500,1000,1000,500,333,333,333,333,333,333,333,333,333,333,333,333,333,1000,1000,300,667,778,1000,330,722,278,278,500,722,556,389,444,500,556,444,722,570,722,722,500,722,500,389,444,722,722,500,722,556,667,722,250,747,667,444,500,722,278,500,667,722,500,667,389,389,278,494,722,778,556,500,722,444,444,667,611,778,722,556,672,722,556,300,778,722,722,570,556,667,494,500,722,278,667,500,444,444,556,556,722,389,570,220,747,778,389,600,667,444,500,667,667,549,722,722,278,416,444,722,722,722,444,444,278,778,500,500,389,278,778,722,612,556,300,778,556,278,500,667,556,750,556,394,778,667,1000,444,389,389,667,750,549,500,556,722,667,444,500,750,556,556,778,400,500,722,556,549,722,444,722,500,722,667,722,722,722,778,444,667,389,556,570,389,556,333,570,500,556,549,500,500,444,556,300,278,500"];
                        },
                        "Times-Italic": function () {
                            return [-15.5, "-169:-217:1010:883", 653, 441, 683, -217, "250,333,420,500,500,833,778,333,333,333,500,675,250,333,250,278,500,500,500,500,500,500,500,500,500,500,333,333,675,675,675,500,920,611,611,667,722,611,611,722,722,333,444,667,556,833,667,722,611,722,611,500,556,722,611,833,611,556,556,389,278,389,422,500,333,500,500,444,500,444,278,500,500,278,278,444,278,722,500,500,500,500,389,389,278,500,444,667,444,444,389,400,275,400,541,389,500,500,167,500,500,500,500,214,556,500,333,333,500,500,500,500,500,250,523,350,333,556,556,500,889,1000,500,333,333,333,333,333,333,333,333,333,333,333,333,333,889,889,276,556,722,944,310,667,278,278,500,667,500,333,444,500,500,444,556,675,556,611,500,722,444,389,444,722,722,500,722,500,611,722,250,760,611,444,500,667,278,500,556,667,500,611,389,389,278,471,611,722,500,500,611,389,444,556,611,722,611,500,544,722,500,300,722,611,611,675,500,556,476,444,667,278,611,500,444,444,500,500,667,333,675,275,760,722,333,600,611,389,500,556,556,549,722,667,278,300,444,722,611,611,444,389,278,722,500,500,389,278,722,722,612,500,300,722,500,278,500,611,500,750,500,300,667,556,980,444,333,333,611,750,549,500,500,722,611,444,500,750,500,500,722,400,500,667,500,453,722,389,667,500,611,556,611,611,611,722,389,611,333,444,675,333,500,278,675,500,500,549,500,500,389,500,300,278,500"];
                        },
                        "Times-BoldItalic": function () {
                            return [-15, "-200:-218:996:921", 669, 462, 683, -217, "250,389,555,500,500,833,778,333,333,333,500,570,250,333,250,278,500,500,500,500,500,500,500,500,500,500,333,333,570,570,570,500,832,667,667,667,722,667,667,722,778,389,500,667,611,889,722,722,611,722,667,556,611,722,667,889,667,611,611,333,278,333,570,500,333,500,500,444,500,444,333,500,556,278,278,500,278,778,556,500,500,500,389,389,278,556,444,667,500,444,389,348,220,348,570,389,500,500,167,500,500,500,500,278,500,500,333,333,556,556,500,500,500,250,500,350,333,500,500,500,1000,1000,500,333,333,333,333,333,333,333,333,333,333,333,333,333,1000,944,266,611,722,944,300,722,278,278,500,722,500,389,444,500,556,444,611,570,611,667,500,722,444,389,444,722,722,500,722,556,667,722,250,747,667,444,500,722,278,500,611,667,500,667,389,389,278,494,667,722,556,500,667,389,444,611,611,722,667,556,608,722,556,300,722,667,667,570,556,611,494,444,722,278,667,500,444,444,556,556,722,389,570,220,747,722,389,600,667,389,500,611,611,549,722,667,278,366,444,722,667,667,444,389,278,722,500,500,389,278,722,722,612,500,300,722,576,278,500,667,500,750,556,382,667,611,1000,444,389,389,611,750,549,500,556,722,667,444,500,750,556,556,722,400,500,667,556,549,722,389,722,500,667,611,667,667,667,722,389,667,389,500,606,389,556,278,606,500,556,549,500,500,389,556,300,278,500"];
                        },
                        "Symbol": function () {
                            return [0, "-180:-293:1090:1010", 0, 0, 0, 0, "250,333,315:713,3:500,316:549,5:833,778,317:439,8:333,333,318:500,11:549,250,300:549,14:250,278,500,500,500,500,500,500,500,500,500,500,278,278,549,549,549,444,319:549,722,667,722,250:612,323:611,763,603,722,333,631,722,686,889,722,722,768,741,556,592,611,690,439,768,645,795,611,59:333,345:863,61:333,346:658,63:500,347:500,631,549,549,494,439,521,411,603,329,603,549,549,254:576,360:521,549,549,521,549,603,439,576,713,686,493,686,494,91:480,200,480,373:549,314:750,374:620,247,270:549,98:167,376:713,100:500,377:753,753,753,753,1042,987,603,987,603,281:400,220:549,386:411,231:549,205:549,387:713,208:494,115:460,155:549,307:549,388:549,549,120:1000,390:603,1000,658,823,686,795,987,768,768,823,768,768,713,713,713,713,713,713,713,768,713,790,790,890,823,285:549,415:250,304:713,416:603,603,1042,987,603,987,603,185:494,423:329,790,790,786,225:713,427:384,384,384,384,384,384,494,494,494,494,329,274,686,686,686,384,384,384,384,384,384,494,494,494,790"];
                        },
                        "ZapfDingbats": function () {
                            return [0, "-1:-143:981:820", 0, 0, 0, 0, "278,452:974,961,974,980,719,789,790,791,690,960,939,549,855,911,933,911,945,974,755,846,762,761,571,677,763,760,759,754,494,552,537,577,692,786,788,788,790,793,794,816,823,789,841,823,833,816,831,923,744,723,749,790,792,695,776,768,792,759,707,708,682,701,826,815,789,789,707,687,696,689,786,787,713,791,785,791,873,761,762,762,759,759,892,892,788,784,438,138,277,415,392,392,668,668,390,390,317,317,276,276,509,509,410,410,234,234,334,334,732,544,544,910,667,760,760,776,595,694,626,788,788,788,788,788,788,788,788,788,788,788,788,788,788,788,788,788,788,788,788,788,788,788,788,788,788,788,788,788,788,788,788,788,788,788,788,788,788,788,788,894,838,1016,458,748,924,748,918,927,928,928,834,873,828,924,924,917,930,931,463,883,836,836,867,867,696,696,874,874,760,946,771,865,771,888,967,888,831,873,927,970,918"];
                        }
                    };
                    return StandardFont;
                })(PDFFont);
                localModule.localExports = StandardFont;
            }, { "../font": 3, "./afm": 4, "fs": 59 }], 7: [function (localRequire, localModule, localExports) {
                var PDFGradient, PDFLinearGradient, PDFRadialGradient, __hasProp = {}.hasOwnProperty, __extends = function (child, parent) { for (var key in parent) {
                    if (__hasProp.call(parent, key))
                        child[key] = parent[key];
                } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                PDFGradient = (function () {
                    function PDFGradient(doc) {
                        this.doc = doc;
                        this.stops = [];
                        this.embedded = false;
                        this.transform = [1, 0, 0, 1, 0, 0];
                        this._colorSpace = 'DeviceRGB';
                    }
                    PDFGradient.prototype.stop = function (pos, color, opacity) {
                        if (opacity == null) {
                            opacity = 1;
                        }
                        opacity = Math.max(0, Math.min(1, opacity));
                        this.stops.push([pos, this.doc._normalizeColor(color), opacity]);
                        return this;
                    };
                    PDFGradient.prototype.embed = function () {
                        var bounds, dx, dy, encode, fn, form, grad, group, gstate, i, last, m, m0, m1, m11, m12, m2, m21, m22, m3, m4, m5, name, pattern, resources, sMask, shader, stop, stops, v, _i, _j, _len, _ref, _ref1, _ref2;
                        if (this.embedded || this.stops.length === 0) {
                            return;
                        }
                        this.embedded = true;
                        last = this.stops[this.stops.length - 1];
                        if (last[0] < 1) {
                            this.stops.push([1, last[1], last[2]]);
                        }
                        bounds = [];
                        encode = [];
                        stops = [];
                        for (i = _i = 0, _ref = this.stops.length - 1; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
                            encode.push(0, 1);
                            if (i + 2 !== this.stops.length) {
                                bounds.push(this.stops[i + 1][0]);
                            }
                            fn = this.doc.ref({
                                FunctionType: 2,
                                Domain: [0, 1],
                                C0: this.stops[i + 0][1],
                                C1: this.stops[i + 1][1],
                                N: 1
                            });
                            stops.push(fn);
                            fn.end();
                        }
                        if (stops.length === 1) {
                            fn = stops[0];
                        }
                        else {
                            fn = this.doc.ref({
                                FunctionType: 3,
                                Domain: [0, 1],
                                Functions: stops,
                                Bounds: bounds,
                                Encode: encode
                            });
                            fn.end();
                        }
                        this.id = 'Sh' + (++this.doc._gradCount);
                        m = this.doc._ctm.slice();
                        m0 = m[0], m1 = m[1], m2 = m[2], m3 = m[3], m4 = m[4], m5 = m[5];
                        _ref1 = this.transform, m11 = _ref1[0], m12 = _ref1[1], m21 = _ref1[2], m22 = _ref1[3], dx = _ref1[4], dy = _ref1[5];
                        m[0] = m0 * m11 + m2 * m12;
                        m[1] = m1 * m11 + m3 * m12;
                        m[2] = m0 * m21 + m2 * m22;
                        m[3] = m1 * m21 + m3 * m22;
                        m[4] = m0 * dx + m2 * dy + m4;
                        m[5] = m1 * dx + m3 * dy + m5;
                        shader = this.shader(fn);
                        shader.end();
                        pattern = this.doc.ref({
                            Type: 'Pattern',
                            PatternType: 2,
                            Shading: shader,
                            Matrix: (function () {
                                var _j, _len, _results;
                                _results = [];
                                for (_j = 0, _len = m.length; _j < _len; _j++) {
                                    v = m[_j];
                                    _results.push(+v.toFixed(5));
                                }
                                return _results;
                            })()
                        });
                        this.doc.page.patterns[this.id] = pattern;
                        pattern.end();
                        if (this.stops.some(function (stop) {
                            return stop[2] < 1;
                        })) {
                            grad = this.opacityGradient();
                            grad._colorSpace = 'DeviceGray';
                            _ref2 = this.stops;
                            for (_j = 0, _len = _ref2.length; _j < _len; _j++) {
                                stop = _ref2[_j];
                                grad.stop(stop[0], [stop[2]]);
                            }
                            grad = grad.embed();
                            group = this.doc.ref({
                                Type: 'Group',
                                S: 'Transparency',
                                CS: 'DeviceGray'
                            });
                            group.end();
                            resources = this.doc.ref({
                                ProcSet: ['PDF', 'Text', 'ImageB', 'ImageC', 'ImageI'],
                                Shading: {
                                    Sh1: grad.data.Shading
                                }
                            });
                            resources.end();
                            form = this.doc.ref({
                                Type: 'XObject',
                                Subtype: 'Form',
                                FormType: 1,
                                BBox: [0, 0, this.doc.page.width, this.doc.page.height],
                                Group: group,
                                Resources: resources
                            });
                            form.end("/Sh1 sh");
                            sMask = this.doc.ref({
                                Type: 'Mask',
                                S: 'Luminosity',
                                G: form
                            });
                            sMask.end();
                            gstate = this.doc.ref({
                                Type: 'ExtGState',
                                SMask: sMask
                            });
                            this.opacity_id = ++this.doc._opacityCount;
                            name = "Gs" + this.opacity_id;
                            this.doc.page.ext_gstates[name] = gstate;
                            gstate.end();
                        }
                        return pattern;
                    };
                    PDFGradient.prototype.apply = function (op) {
                        if (!this.embedded) {
                            this.embed();
                        }
                        this.doc.addContent("/" + this.id + " " + op);
                        if (this.opacity_id) {
                            this.doc.addContent("/Gs" + this.opacity_id + " gs");
                            return this.doc._sMasked = true;
                        }
                    };
                    return PDFGradient;
                })();
                PDFLinearGradient = (function (_super) {
                    __extends(PDFLinearGradient, _super);
                    function PDFLinearGradient(doc, x1, y1, x2, y2) {
                        this.doc = doc;
                        this.x1 = x1;
                        this.y1 = y1;
                        this.x2 = x2;
                        this.y2 = y2;
                        PDFLinearGradient.__super__.constructor.apply(this, arguments);
                    }
                    PDFLinearGradient.prototype.shader = function (fn) {
                        return this.doc.ref({
                            ShadingType: 2,
                            ColorSpace: this._colorSpace,
                            Coords: [this.x1, this.y1, this.x2, this.y2],
                            Function: fn,
                            Extend: [true, true]
                        });
                    };
                    PDFLinearGradient.prototype.opacityGradient = function () {
                        return new PDFLinearGradient(this.doc, this.x1, this.y1, this.x2, this.y2);
                    };
                    return PDFLinearGradient;
                })(PDFGradient);
                PDFRadialGradient = (function (_super) {
                    __extends(PDFRadialGradient, _super);
                    function PDFRadialGradient(doc, x1, y1, r1, x2, y2, r2) {
                        this.doc = doc;
                        this.x1 = x1;
                        this.y1 = y1;
                        this.r1 = r1;
                        this.x2 = x2;
                        this.y2 = y2;
                        this.r2 = r2;
                        PDFRadialGradient.__super__.constructor.apply(this, arguments);
                    }
                    PDFRadialGradient.prototype.shader = function (fn) {
                        return this.doc.ref({
                            ShadingType: 3,
                            ColorSpace: this._colorSpace,
                            Coords: [this.x1, this.y1, this.r1, this.x2, this.y2, this.r2],
                            Function: fn,
                            Extend: [true, true]
                        });
                    };
                    PDFRadialGradient.prototype.opacityGradient = function () {
                        return new PDFRadialGradient(this.doc, this.x1, this.y1, this.r1, this.x2, this.y2, this.r2);
                    };
                    return PDFRadialGradient;
                })(PDFGradient);
                localModule.localExports = {
                    PDFGradient: PDFGradient,
                    PDFLinearGradient: PDFLinearGradient,
                    PDFRadialGradient: PDFRadialGradient
                };
            }, {}], 8: [function (localRequire, localModule, localExports) {
                (function (Buffer) {
                    var Data, JPEG, PDFImage, PNG, fs;
                    fs = localRequire('fs');
                    Data = localRequire('./data');
                    JPEG = localRequire('./image/jpeg');
                    PNG = localRequire('./image/png');
                    PDFImage = (function () {
                        function PDFImage() { }
                        PDFImage.open = function (src, label) {
                            var data, match;
                            if (Buffer.isBuffer(src)) {
                                data = src;
                            }
                            else if (src instanceof ArrayBuffer) {
                                data = new Buffer(new Uint8Array(src));
                            }
                            else {
                                if (match = /^data:.+;base64,(.*)$/.exec(src)) {
                                    data = new Buffer(match[1], 'base64');
                                }
                                else {
                                    data = fs.readFileSync(src);
                                    if (!data) {
                                        return;
                                    }
                                }
                            }
                            if (data[0] === 0xff && data[1] === 0xd8) {
                                return new JPEG(data, label);
                            }
                            else if (data[0] === 0x89 && data.toString('ascii', 1, 4) === 'PNG') {
                                return new PNG(data, label);
                            }
                            else {
                                throw new Error('Unknown image format.');
                            }
                        };
                        return PDFImage;
                    })();
                    localModule.localExports = PDFImage;
                }).call(this, localRequire("buffer").Buffer);
            }, { "./data": 1, "./image/jpeg": 9, "./image/png": 10, "buffer": 60, "fs": 59 }], 9: [function (localRequire, localModule, localExports) {
                var JPEG, fs, __indexOf = [].indexOf || function (item) { for (var i = 0, l = this.length; i < l; i++) {
                    if (i in this && this[i] === item)
                        return i;
                } return -1; };
                fs = localRequire('fs');
                JPEG = (function () {
                    var MARKERS;
                    MARKERS = [0xFFC0, 0xFFC1, 0xFFC2, 0xFFC3, 0xFFC5, 0xFFC6, 0xFFC7, 0xFFC8, 0xFFC9, 0xFFCA, 0xFFCB, 0xFFCC, 0xFFCD, 0xFFCE, 0xFFCF];
                    function JPEG(data, label) {
                        var channels, marker, pos;
                        this.data = data;
                        this.label = label;
                        if (this.data.readUInt16BE(0) !== 0xFFD8) {
                            throw "SOI not found in JPEG";
                        }
                        pos = 2;
                        while (pos < this.data.length) {
                            marker = this.data.readUInt16BE(pos);
                            pos += 2;
                            if (__indexOf.call(MARKERS, marker) >= 0) {
                                break;
                            }
                            pos += this.data.readUInt16BE(pos);
                        }
                        if (__indexOf.call(MARKERS, marker) < 0) {
                            throw "Invalid JPEG.";
                        }
                        pos += 2;
                        this.bits = this.data[pos++];
                        this.height = this.data.readUInt16BE(pos);
                        pos += 2;
                        this.width = this.data.readUInt16BE(pos);
                        pos += 2;
                        channels = this.data[pos++];
                        this.colorSpace = (function () {
                            switch (channels) {
                                case 1:
                                    return 'DeviceGray';
                                case 3:
                                    return 'DeviceRGB';
                                case 4:
                                    return 'DeviceCMYK';
                            }
                        })();
                        this.obj = null;
                    }
                    JPEG.prototype.embed = function (document) {
                        if (this.obj) {
                            return;
                        }
                        this.obj = document.ref({
                            Type: 'XObject',
                            Subtype: 'Image',
                            BitsPerComponent: this.bits,
                            Width: this.width,
                            Height: this.height,
                            ColorSpace: this.colorSpace,
                            Filter: 'DCTDecode'
                        });
                        if (this.colorSpace === 'DeviceCMYK') {
                            this.obj.data['Decode'] = [1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0];
                        }
                        this.obj.end(this.data);
                        return this.data = null;
                    };
                    return JPEG;
                })();
                localModule.localExports = JPEG;
            }, { "fs": 59 }], 10: [function (localRequire, localModule, localExports) {
                (function (Buffer) {
                    var PNG, PNGImage, zlib;
                    zlib = localRequire('zlib');
                    PNG = localRequire('png-js');
                    PNGImage = (function () {
                        function PNGImage(data, label) {
                            this.label = label;
                            this.image = new PNG(data);
                            this.width = this.image.width;
                            this.height = this.image.height;
                            this.imgData = this.image.imgData;
                            this.obj = null;
                        }
                        PNGImage.prototype.embed = function (document) {
                            var mask, palette, params, rgb, val, x, _i, _len;
                            this.document = document;
                            if (this.obj) {
                                return;
                            }
                            this.obj = this.document.ref({
                                Type: 'XObject',
                                Subtype: 'Image',
                                BitsPerComponent: this.image.bits,
                                Width: this.width,
                                Height: this.height,
                                Filter: 'FlateDecode'
                            });
                            if (!this.image.hasAlphaChannel) {
                                params = this.document.ref({
                                    Predictor: 15,
                                    Colors: this.image.colors,
                                    BitsPerComponent: this.image.bits,
                                    Columns: this.width
                                });
                                this.obj.data['DecodeParms'] = params;
                                params.end();
                            }
                            if (this.image.palette.length === 0) {
                                this.obj.data['ColorSpace'] = this.image.colorSpace;
                            }
                            else {
                                palette = this.document.ref();
                                palette.end(new Buffer(this.image.palette));
                                this.obj.data['ColorSpace'] = ['Indexed', 'DeviceRGB', (this.image.palette.length / 3) - 1, palette];
                            }
                            if (this.image.transparency.grayscale) {
                                val = this.image.transparency.greyscale;
                                return this.obj.data['Mask'] = [val, val];
                            }
                            else if (this.image.transparency.rgb) {
                                rgb = this.image.transparency.rgb;
                                mask = [];
                                for (_i = 0, _len = rgb.length; _i < _len; _i++) {
                                    x = rgb[_i];
                                    mask.push(x, x);
                                }
                                return this.obj.data['Mask'] = mask;
                            }
                            else if (this.image.transparency.indexed) {
                                return this.loadIndexedAlphaChannel();
                            }
                            else if (this.image.hasAlphaChannel) {
                                return this.splitAlphaChannel();
                            }
                            else {
                                return this.finalize();
                            }
                        };
                        PNGImage.prototype.finalize = function () {
                            var sMask;
                            if (this.alphaChannel) {
                                sMask = this.document.ref({
                                    Type: 'XObject',
                                    Subtype: 'Image',
                                    Height: this.height,
                                    Width: this.width,
                                    BitsPerComponent: 8,
                                    Filter: 'FlateDecode',
                                    ColorSpace: 'DeviceGray',
                                    Decode: [0, 1]
                                });
                                sMask.end(this.alphaChannel);
                                this.obj.data['SMask'] = sMask;
                            }
                            this.obj.end(this.imgData);
                            this.image = null;
                            return this.imgData = null;
                        };
                        PNGImage.prototype.splitAlphaChannel = function () {
                            return this.image.decodePixels((function (_this) {
                                return function (pixels) {
                                    var a, alphaChannel, colorByteSize, done, i, imgData, len, p, pixelCount;
                                    colorByteSize = _this.image.colors * _this.image.bits / 8;
                                    pixelCount = _this.width * _this.height;
                                    imgData = new Buffer(pixelCount * colorByteSize);
                                    alphaChannel = new Buffer(pixelCount);
                                    i = p = a = 0;
                                    len = pixels.length;
                                    while (i < len) {
                                        imgData[p++] = pixels[i++];
                                        imgData[p++] = pixels[i++];
                                        imgData[p++] = pixels[i++];
                                        alphaChannel[a++] = pixels[i++];
                                    }
                                    done = 0;
                                    zlib.deflate(imgData, function (err, imgData) {
                                        _this.imgData = imgData;
                                        if (err) {
                                            throw err;
                                        }
                                        if (++done === 2) {
                                            return _this.finalize();
                                        }
                                    });
                                    return zlib.deflate(alphaChannel, function (err, alphaChannel) {
                                        _this.alphaChannel = alphaChannel;
                                        if (err) {
                                            throw err;
                                        }
                                        if (++done === 2) {
                                            return _this.finalize();
                                        }
                                    });
                                };
                            })(this));
                        };
                        PNGImage.prototype.loadIndexedAlphaChannel = function (fn) {
                            var transparency;
                            transparency = this.image.transparency.indexed;
                            return this.image.decodePixels((function (_this) {
                                return function (pixels) {
                                    var alphaChannel, i, j, _i, _ref;
                                    alphaChannel = new Buffer(_this.width * _this.height);
                                    i = 0;
                                    for (j = _i = 0, _ref = pixels.length; _i < _ref; j = _i += 1) {
                                        alphaChannel[i++] = transparency[pixels[j]];
                                    }
                                    return zlib.deflate(alphaChannel, function (err, alphaChannel) {
                                        _this.alphaChannel = alphaChannel;
                                        if (err) {
                                            throw err;
                                        }
                                        return _this.finalize();
                                    });
                                };
                            })(this));
                        };
                        return PNGImage;
                    })();
                    localModule.localExports = PNGImage;
                }).call(this, localRequire("buffer").Buffer);
            }, { "buffer": 60, "png-js": 186, "zlib": 58 }], 11: [function (localRequire, localModule, localExports) {
                var EventEmitter, LineBreaker, LineWrapper, __hasProp = {}.hasOwnProperty, __extends = function (child, parent) { for (var key in parent) {
                    if (__hasProp.call(parent, key))
                        child[key] = parent[key];
                } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                EventEmitter = localRequire('events').EventEmitter;
                LineBreaker = localRequire('linebreak');
                LineWrapper = (function (_super) {
                    __extends(LineWrapper, _super);
                    function LineWrapper(document, options) {
                        var _ref;
                        this.document = document;
                        this.indent = options.indent || 0;
                        this.characterSpacing = options.characterSpacing || 0;
                        this.wordSpacing = options.wordSpacing === 0;
                        this.columns = options.columns || 1;
                        this.columnGap = (_ref = options.columnGap) != null ? _ref : 18;
                        this.lineWidth = (options.width - (this.columnGap * (this.columns - 1))) / this.columns;
                        this.spaceLeft = this.lineWidth;
                        this.startX = this.document.x;
                        this.startY = this.document.y;
                        this.column = 1;
                        this.ellipsis = options.ellipsis;
                        this.continuedX = 0;
                        this.features = options.features;
                        if (options.height != null) {
                            this.height = options.height;
                            this.maxY = this.startY + options.height;
                        }
                        else {
                            this.maxY = this.document.page.maxY();
                        }
                        this.on('firstLine', (function (_this) {
                            return function (options) {
                                var indent;
                                indent = _this.continuedX || _this.indent;
                                _this.document.x += indent;
                                _this.lineWidth -= indent;
                                return _this.once('line', function () {
                                    _this.document.x -= indent;
                                    _this.lineWidth += indent;
                                    if (options.continued && !_this.continuedX) {
                                        _this.continuedX = _this.indent;
                                    }
                                    if (!options.continued) {
                                        return _this.continuedX = 0;
                                    }
                                });
                            };
                        })(this));
                        this.on('lastLine', (function (_this) {
                            return function (options) {
                                var align;
                                align = options.align;
                                if (align === 'justify') {
                                    options.align = 'left';
                                }
                                _this.lastLine = true;
                                return _this.once('line', function () {
                                    _this.document.y += options.paragraphGap || 0;
                                    options.align = align;
                                    return _this.lastLine = false;
                                });
                            };
                        })(this));
                    }
                    LineWrapper.prototype.wordWidth = function (word) {
                        return this.document.widthOfString(word, this) + this.characterSpacing + this.wordSpacing;
                    };
                    LineWrapper.prototype.eachWord = function (text, fn) {
                        var bk, breaker, fbk, l, last, lbk, shouldContinue, w, word, wordWidths;
                        breaker = new LineBreaker(text);
                        last = null;
                        wordWidths = Object.create(null);
                        while (bk = breaker.nextBreak()) {
                            word = text.slice((last != null ? last.position : void 0) || 0, bk.position);
                            w = wordWidths[word] != null ? wordWidths[word] : wordWidths[word] = this.wordWidth(word);
                            if (w > this.lineWidth + this.continuedX) {
                                lbk = last;
                                fbk = {};
                                while (word.length) {
                                    l = word.length;
                                    while (w > this.spaceLeft) {
                                        w = this.wordWidth(word.slice(0, --l));
                                    }
                                    fbk.required = l < word.length;
                                    shouldContinue = fn(word.slice(0, l), w, fbk, lbk);
                                    lbk = {
                                        required: false
                                    };
                                    word = word.slice(l);
                                    w = this.wordWidth(word);
                                    if (shouldContinue === false) {
                                        break;
                                    }
                                }
                            }
                            else {
                                shouldContinue = fn(word, w, bk, last);
                            }
                            if (shouldContinue === false) {
                                break;
                            }
                            last = bk;
                        }
                    };
                    LineWrapper.prototype.wrap = function (text, options) {
                        var buffer, emitLine, lc, nextY, textWidth, wc, y;
                        if (options.indent != null) {
                            this.indent = options.indent;
                        }
                        if (options.characterSpacing != null) {
                            this.characterSpacing = options.characterSpacing;
                        }
                        if (options.wordSpacing != null) {
                            this.wordSpacing = options.wordSpacing;
                        }
                        if (options.ellipsis != null) {
                            this.ellipsis = options.ellipsis;
                        }
                        nextY = this.document.y + this.document.currentLineHeight(true);
                        if (this.document.y > this.maxY || nextY > this.maxY) {
                            this.nextSection();
                        }
                        buffer = '';
                        textWidth = 0;
                        wc = 0;
                        lc = 0;
                        y = this.document.y;
                        emitLine = (function (_this) {
                            return function () {
                                options.textWidth = textWidth + _this.wordSpacing * (wc - 1);
                                options.wordCount = wc;
                                options.lineWidth = _this.lineWidth;
                                y = _this.document.y;
                                _this.emit('line', buffer, options, _this);
                                return lc++;
                            };
                        })(this);
                        this.emit('sectionStart', options, this);
                        this.eachWord(text, (function (_this) {
                            return function (word, w, bk, last) {
                                var lh, shouldContinue;
                                if ((last == null) || last.required) {
                                    _this.emit('firstLine', options, _this);
                                    _this.spaceLeft = _this.lineWidth;
                                }
                                if (w <= _this.spaceLeft) {
                                    buffer += word;
                                    textWidth += w;
                                    wc++;
                                }
                                if (bk.required || w > _this.spaceLeft) {
                                    if (bk.required) {
                                        _this.emit('lastLine', options, _this);
                                    }
                                    lh = _this.document.currentLineHeight(true);
                                    if ((_this.height != null) && _this.ellipsis && _this.document.y + lh * 2 > _this.maxY && _this.column >= _this.columns) {
                                        if (_this.ellipsis === true) {
                                            _this.ellipsis = '';
                                        }
                                        buffer = buffer.replace(/\s+$/, '');
                                        textWidth = _this.wordWidth(buffer + _this.ellipsis);
                                        while (textWidth > _this.lineWidth) {
                                            buffer = buffer.slice(0, -1).replace(/\s+$/, '');
                                            textWidth = _this.wordWidth(buffer + _this.ellipsis);
                                        }
                                        buffer = buffer + _this.ellipsis;
                                    }
                                    emitLine();
                                    if (_this.maxY - (_this.document.y + lh) < -1e-6) {
                                        shouldContinue = _this.nextSection();
                                        if (!shouldContinue) {
                                            wc = 0;
                                            buffer = '';
                                            return false;
                                        }
                                    }
                                    if (bk.required) {
                                        if (w > _this.spaceLeft) {
                                            buffer = word;
                                            textWidth = w;
                                            wc = 1;
                                            emitLine();
                                        }
                                        _this.spaceLeft = _this.lineWidth;
                                        buffer = '';
                                        textWidth = 0;
                                        return wc = 0;
                                    }
                                    else {
                                        _this.spaceLeft = _this.lineWidth - w;
                                        buffer = word;
                                        textWidth = w;
                                        return wc = 1;
                                    }
                                }
                                else {
                                    return _this.spaceLeft -= w;
                                }
                            };
                        })(this));
                        if (wc > 0) {
                            this.emit('lastLine', options, this);
                            emitLine();
                        }
                        this.emit('sectionEnd', options, this);
                        if (options.continued === true) {
                            if (lc > 1) {
                                this.continuedX = 0;
                            }
                            this.continuedX += options.textWidth;
                            return this.document.y = y;
                        }
                        else {
                            return this.document.x = this.startX;
                        }
                    };
                    LineWrapper.prototype.nextSection = function (options) {
                        var _ref;
                        this.emit('sectionEnd', options, this);
                        if (++this.column > this.columns) {
                            if (this.height != null) {
                                return false;
                            }
                            this.document.addPage();
                            this.column = 1;
                            this.startY = this.document.page.margins.top;
                            this.maxY = this.document.page.maxY();
                            this.document.x = this.startX;
                            if (this.document._fillColor) {
                                (_ref = this.document).fillColor.apply(_ref, this.document._fillColor);
                            }
                            this.emit('pageBreak', options, this);
                        }
                        else {
                            this.document.x += this.lineWidth + this.columnGap;
                            this.document.y = this.startY;
                            this.emit('columnBreak', options, this);
                        }
                        this.emit('sectionStart', options, this);
                        return true;
                    };
                    return LineWrapper;
                })(EventEmitter);
                localModule.localExports = LineWrapper;
            }, { "events": 164, "linebreak": 173 }], 12: [function (localRequire, localModule, localExports) {
                localModule.localExports = {
                    annotate: function (x, y, w, h, options) {
                        var key, ref, val;
                        options.Type = 'Annot';
                        options.Rect = this._convertRect(x, y, w, h);
                        options.Border = [0, 0, 0];
                        if (options.Subtype !== 'Link') {
                            if (options.C == null) {
                                options.C = this._normalizeColor(options.color || [0, 0, 0]);
                            }
                        }
                        delete options.color;
                        if (typeof options.Dest === 'string') {
                            options.Dest = new String(options.Dest);
                        }
                        for (key in options) {
                            val = options[key];
                            options[key[0].toUpperCase() + key.slice(1)] = val;
                        }
                        ref = this.ref(options);
                        this.page.annotations.push(ref);
                        ref.end();
                        return this;
                    },
                    note: function (x, y, w, h, contents, options) {
                        if (options == null) {
                            options = {};
                        }
                        options.Subtype = 'Text';
                        options.Contents = new String(contents);
                        options.Name = 'Comment';
                        if (options.color == null) {
                            options.color = [243, 223, 92];
                        }
                        return this.annotate(x, y, w, h, options);
                    },
                    link: function (x, y, w, h, url, options) {
                        if (options == null) {
                            options = {};
                        }
                        options.Subtype = 'Link';
                        options.A = this.ref({
                            S: 'URI',
                            URI: new String(url)
                        });
                        options.A.end();
                        return this.annotate(x, y, w, h, options);
                    },
                    _markup: function (x, y, w, h, options) {
                        var x1, x2, y1, y2, _ref;
                        if (options == null) {
                            options = {};
                        }
                        _ref = this._convertRect(x, y, w, h), x1 = _ref[0], y1 = _ref[1], x2 = _ref[2], y2 = _ref[3];
                        options.QuadPoints = [x1, y2, x2, y2, x1, y1, x2, y1];
                        options.Contents = new String;
                        return this.annotate(x, y, w, h, options);
                    },
                    highlight: function (x, y, w, h, options) {
                        if (options == null) {
                            options = {};
                        }
                        options.Subtype = 'Highlight';
                        if (options.color == null) {
                            options.color = [241, 238, 148];
                        }
                        return this._markup(x, y, w, h, options);
                    },
                    underline: function (x, y, w, h, options) {
                        if (options == null) {
                            options = {};
                        }
                        options.Subtype = 'Underline';
                        return this._markup(x, y, w, h, options);
                    },
                    strike: function (x, y, w, h, options) {
                        if (options == null) {
                            options = {};
                        }
                        options.Subtype = 'StrikeOut';
                        return this._markup(x, y, w, h, options);
                    },
                    lineAnnotation: function (x1, y1, x2, y2, options) {
                        if (options == null) {
                            options = {};
                        }
                        options.Subtype = 'Line';
                        options.Contents = new String;
                        options.L = [x1, this.page.height - y1, x2, this.page.height - y2];
                        return this.annotate(x1, y1, x2, y2, options);
                    },
                    rectAnnotation: function (x, y, w, h, options) {
                        if (options == null) {
                            options = {};
                        }
                        options.Subtype = 'Square';
                        options.Contents = new String;
                        return this.annotate(x, y, w, h, options);
                    },
                    ellipseAnnotation: function (x, y, w, h, options) {
                        if (options == null) {
                            options = {};
                        }
                        options.Subtype = 'Circle';
                        options.Contents = new String;
                        return this.annotate(x, y, w, h, options);
                    },
                    textAnnotation: function (x, y, w, h, text, options) {
                        if (options == null) {
                            options = {};
                        }
                        options.Subtype = 'FreeText';
                        options.Contents = new String(text);
                        options.DA = new String;
                        return this.annotate(x, y, w, h, options);
                    },
                    _convertRect: function (x1, y1, w, h) {
                        var m0, m1, m2, m3, m4, m5, x2, y2, _ref;
                        y2 = y1;
                        y1 += h;
                        x2 = x1 + w;
                        _ref = this._ctm, m0 = _ref[0], m1 = _ref[1], m2 = _ref[2], m3 = _ref[3], m4 = _ref[4], m5 = _ref[5];
                        x1 = m0 * x1 + m2 * y1 + m4;
                        y1 = m1 * x1 + m3 * y1 + m5;
                        x2 = m0 * x2 + m2 * y2 + m4;
                        y2 = m1 * x2 + m3 * y2 + m5;
                        return [x1, y1, x2, y2];
                    }
                };
            }, {}], 13: [function (localRequire, localModule, localExports) {
                var PDFGradient, PDFLinearGradient, PDFRadialGradient, namedColors, _ref;
                _ref = localRequire('../gradient'), PDFGradient = _ref.PDFGradient, PDFLinearGradient = _ref.PDFLinearGradient, PDFRadialGradient = _ref.PDFRadialGradient;
                localModule.localExports = {
                    initColor: function () {
                        this._opacityRegistry = {};
                        this._opacityCount = 0;
                        return this._gradCount = 0;
                    },
                    _normalizeColor: function (color) {
                        var hex, part;
                        if (color instanceof PDFGradient) {
                            return color;
                        }
                        if (typeof color === 'string') {
                            if (color.charAt(0) === '#') {
                                if (color.length === 4) {
                                    color = color.replace(/#([0-9A-F])([0-9A-F])([0-9A-F])/i, "#$1$1$2$2$3$3");
                                }
                                hex = parseInt(color.slice(1), 16);
                                color = [hex >> 16, hex >> 8 & 0xff, hex & 0xff];
                            }
                            else if (namedColors[color]) {
                                color = namedColors[color];
                            }
                        }
                        if (Array.isArray(color)) {
                            if (color.length === 3) {
                                color = (function () {
                                    var _i, _len, _results;
                                    _results = [];
                                    for (_i = 0, _len = color.length; _i < _len; _i++) {
                                        part = color[_i];
                                        _results.push(part / 255);
                                    }
                                    return _results;
                                })();
                            }
                            else if (color.length === 4) {
                                color = (function () {
                                    var _i, _len, _results;
                                    _results = [];
                                    for (_i = 0, _len = color.length; _i < _len; _i++) {
                                        part = color[_i];
                                        _results.push(part / 100);
                                    }
                                    return _results;
                                })();
                            }
                            return color;
                        }
                        return null;
                    },
                    _setColor: function (color, stroke) {
                        var gstate, name, op, space;
                        color = this._normalizeColor(color);
                        if (!color) {
                            return false;
                        }
                        if (this._sMasked) {
                            gstate = this.ref({
                                Type: 'ExtGState',
                                SMask: 'None'
                            });
                            gstate.end();
                            name = "Gs" + (++this._opacityCount);
                            this.page.ext_gstates[name] = gstate;
                            this.addContent("/" + name + " gs");
                            this._sMasked = false;
                        }
                        op = stroke ? 'SCN' : 'scn';
                        if (color instanceof PDFGradient) {
                            this._setColorSpace('Pattern', stroke);
                            color.apply(op);
                        }
                        else {
                            space = color.length === 4 ? 'DeviceCMYK' : 'DeviceRGB';
                            this._setColorSpace(space, stroke);
                            color = color.join(' ');
                            this.addContent("" + color + " " + op);
                        }
                        return true;
                    },
                    _setColorSpace: function (space, stroke) {
                        var op;
                        op = stroke ? 'CS' : 'cs';
                        return this.addContent("/" + space + " " + op);
                    },
                    fillColor: function (color, opacity) {
                        var set;
                        if (opacity == null) {
                            opacity = 1;
                        }
                        set = this._setColor(color, false);
                        if (set) {
                            this.fillOpacity(opacity);
                        }
                        this._fillColor = [color, opacity];
                        return this;
                    },
                    strokeColor: function (color, opacity) {
                        var set;
                        if (opacity == null) {
                            opacity = 1;
                        }
                        set = this._setColor(color, true);
                        if (set) {
                            this.strokeOpacity(opacity);
                        }
                        return this;
                    },
                    opacity: function (opacity) {
                        this._doOpacity(opacity, opacity);
                        return this;
                    },
                    fillOpacity: function (opacity) {
                        this._doOpacity(opacity, null);
                        return this;
                    },
                    strokeOpacity: function (opacity) {
                        this._doOpacity(null, opacity);
                        return this;
                    },
                    _doOpacity: function (fillOpacity, strokeOpacity) {
                        var dictionary, id, key, name, _ref1;
                        if (!((fillOpacity != null) || (strokeOpacity != null))) {
                            return;
                        }
                        if (fillOpacity != null) {
                            fillOpacity = Math.max(0, Math.min(1, fillOpacity));
                        }
                        if (strokeOpacity != null) {
                            strokeOpacity = Math.max(0, Math.min(1, strokeOpacity));
                        }
                        key = "" + fillOpacity + "_" + strokeOpacity;
                        if (this._opacityRegistry[key]) {
                            _ref1 = this._opacityRegistry[key], dictionary = _ref1[0], name = _ref1[1];
                        }
                        else {
                            dictionary = {
                                Type: 'ExtGState'
                            };
                            if (fillOpacity != null) {
                                dictionary.ca = fillOpacity;
                            }
                            if (strokeOpacity != null) {
                                dictionary.CA = strokeOpacity;
                            }
                            dictionary = this.ref(dictionary);
                            dictionary.end();
                            id = ++this._opacityCount;
                            name = "Gs" + id;
                            this._opacityRegistry[key] = [dictionary, name];
                        }
                        this.page.ext_gstates[name] = dictionary;
                        return this.addContent("/" + name + " gs");
                    },
                    linearGradient: function (x1, y1, x2, y2) {
                        return new PDFLinearGradient(this, x1, y1, x2, y2);
                    },
                    radialGradient: function (x1, y1, r1, x2, y2, r2) {
                        return new PDFRadialGradient(this, x1, y1, r1, x2, y2, r2);
                    }
                };
                namedColors = {
                    aliceblue: [240, 248, 255],
                    antiquewhite: [250, 235, 215],
                    aqua: [0, 255, 255],
                    aquamarine: [127, 255, 212],
                    azure: [240, 255, 255],
                    beige: [245, 245, 220],
                    bisque: [255, 228, 196],
                    black: [0, 0, 0],
                    blanchedalmond: [255, 235, 205],
                    blue: [0, 0, 255],
                    blueviolet: [138, 43, 226],
                    brown: [165, 42, 42],
                    burlywood: [222, 184, 135],
                    cadetblue: [95, 158, 160],
                    chartreuse: [127, 255, 0],
                    chocolate: [210, 105, 30],
                    coral: [255, 127, 80],
                    cornflowerblue: [100, 149, 237],
                    cornsilk: [255, 248, 220],
                    crimson: [220, 20, 60],
                    cyan: [0, 255, 255],
                    darkblue: [0, 0, 139],
                    darkcyan: [0, 139, 139],
                    darkgoldenrod: [184, 134, 11],
                    darkgray: [169, 169, 169],
                    darkgreen: [0, 100, 0],
                    darkgrey: [169, 169, 169],
                    darkkhaki: [189, 183, 107],
                    darkmagenta: [139, 0, 139],
                    darkolivegreen: [85, 107, 47],
                    darkorange: [255, 140, 0],
                    darkorchid: [153, 50, 204],
                    darkred: [139, 0, 0],
                    darksalmon: [233, 150, 122],
                    darkseagreen: [143, 188, 143],
                    darkslateblue: [72, 61, 139],
                    darkslategray: [47, 79, 79],
                    darkslategrey: [47, 79, 79],
                    darkturquoise: [0, 206, 209],
                    darkviolet: [148, 0, 211],
                    deeppink: [255, 20, 147],
                    deepskyblue: [0, 191, 255],
                    dimgray: [105, 105, 105],
                    dimgrey: [105, 105, 105],
                    dodgerblue: [30, 144, 255],
                    firebrick: [178, 34, 34],
                    floralwhite: [255, 250, 240],
                    forestgreen: [34, 139, 34],
                    fuchsia: [255, 0, 255],
                    gainsboro: [220, 220, 220],
                    ghostwhite: [248, 248, 255],
                    gold: [255, 215, 0],
                    goldenrod: [218, 165, 32],
                    gray: [128, 128, 128],
                    grey: [128, 128, 128],
                    green: [0, 128, 0],
                    greenyellow: [173, 255, 47],
                    honeydew: [240, 255, 240],
                    hotpink: [255, 105, 180],
                    indianred: [205, 92, 92],
                    indigo: [75, 0, 130],
                    ivory: [255, 255, 240],
                    khaki: [240, 230, 140],
                    lavender: [230, 230, 250],
                    lavenderblush: [255, 240, 245],
                    lawngreen: [124, 252, 0],
                    lemonchiffon: [255, 250, 205],
                    lightblue: [173, 216, 230],
                    lightcoral: [240, 128, 128],
                    lightcyan: [224, 255, 255],
                    lightgoldenrodyellow: [250, 250, 210],
                    lightgray: [211, 211, 211],
                    lightgreen: [144, 238, 144],
                    lightgrey: [211, 211, 211],
                    lightpink: [255, 182, 193],
                    lightsalmon: [255, 160, 122],
                    lightseagreen: [32, 178, 170],
                    lightskyblue: [135, 206, 250],
                    lightslategray: [119, 136, 153],
                    lightslategrey: [119, 136, 153],
                    lightsteelblue: [176, 196, 222],
                    lightyellow: [255, 255, 224],
                    lime: [0, 255, 0],
                    limegreen: [50, 205, 50],
                    linen: [250, 240, 230],
                    magenta: [255, 0, 255],
                    maroon: [128, 0, 0],
                    mediumaquamarine: [102, 205, 170],
                    mediumblue: [0, 0, 205],
                    mediumorchid: [186, 85, 211],
                    mediumpurple: [147, 112, 219],
                    mediumseagreen: [60, 179, 113],
                    mediumslateblue: [123, 104, 238],
                    mediumspringgreen: [0, 250, 154],
                    mediumturquoise: [72, 209, 204],
                    mediumvioletred: [199, 21, 133],
                    midnightblue: [25, 25, 112],
                    mintcream: [245, 255, 250],
                    mistyrose: [255, 228, 225],
                    moccasin: [255, 228, 181],
                    navajowhite: [255, 222, 173],
                    navy: [0, 0, 128],
                    oldlace: [253, 245, 230],
                    olive: [128, 128, 0],
                    olivedrab: [107, 142, 35],
                    orange: [255, 165, 0],
                    orangered: [255, 69, 0],
                    orchid: [218, 112, 214],
                    palegoldenrod: [238, 232, 170],
                    palegreen: [152, 251, 152],
                    paleturquoise: [175, 238, 238],
                    palevioletred: [219, 112, 147],
                    papayawhip: [255, 239, 213],
                    peachpuff: [255, 218, 185],
                    peru: [205, 133, 63],
                    pink: [255, 192, 203],
                    plum: [221, 160, 221],
                    powderblue: [176, 224, 230],
                    purple: [128, 0, 128],
                    red: [255, 0, 0],
                    rosybrown: [188, 143, 143],
                    royalblue: [65, 105, 225],
                    saddlebrown: [139, 69, 19],
                    salmon: [250, 128, 114],
                    sandybrown: [244, 164, 96],
                    seagreen: [46, 139, 87],
                    seashell: [255, 245, 238],
                    sienna: [160, 82, 45],
                    silver: [192, 192, 192],
                    skyblue: [135, 206, 235],
                    slateblue: [106, 90, 205],
                    slategray: [112, 128, 144],
                    slategrey: [112, 128, 144],
                    snow: [255, 250, 250],
                    springgreen: [0, 255, 127],
                    steelblue: [70, 130, 180],
                    tan: [210, 180, 140],
                    teal: [0, 128, 128],
                    thistle: [216, 191, 216],
                    tomato: [255, 99, 71],
                    turquoise: [64, 224, 208],
                    violet: [238, 130, 238],
                    wheat: [245, 222, 179],
                    white: [255, 255, 255],
                    whitesmoke: [245, 245, 245],
                    yellow: [255, 255, 0],
                    yellowgreen: [154, 205, 50]
                };
            }, { "../gradient": 7 }], 14: [function (localRequire, localModule, localExports) {
                var PDFFont;
                PDFFont = localRequire('../font');
                localModule.localExports = {
                    initFonts: function () {
                        this._fontFamilies = {};
                        this._fontCount = 0;
                        this._fontSize = 12;
                        this._font = null;
                        this._registeredFonts = {};
                        return this.font('Helvetica');
                    },
                    font: function (src, family, size) {
                        var cacheKey, font, id, _ref;
                        if (typeof family === 'number') {
                            size = family;
                            family = null;
                        }
                        if (typeof src === 'string' && this._registeredFonts[src]) {
                            cacheKey = src;
                            _ref = this._registeredFonts[src], src = _ref.src, family = _ref.family;
                        }
                        else {
                            cacheKey = family || src;
                            if (typeof cacheKey !== 'string') {
                                cacheKey = null;
                            }
                        }
                        if (size != null) {
                            this.fontSize(size);
                        }
                        if (font = this._fontFamilies[cacheKey]) {
                            this._font = font;
                            return this;
                        }
                        id = 'F' + (++this._fontCount);
                        this._font = PDFFont.open(this, src, family, id);
                        if (font = this._fontFamilies[this._font.name]) {
                            this._font = font;
                            return this;
                        }
                        if (cacheKey) {
                            this._fontFamilies[cacheKey] = this._font;
                        }
                        this._fontFamilies[this._font.name] = this._font;
                        return this;
                    },
                    fontSize: function (_fontSize) {
                        this._fontSize = _fontSize;
                        return this;
                    },
                    currentLineHeight: function (includeGap) {
                        if (includeGap == null) {
                            includeGap = false;
                        }
                        return this._font.lineHeight(this._fontSize, includeGap);
                    },
                    currentFontAscender: function () {
                        return this._font.getAscender(this._fontSize);
                    },
                    currentFontBBox: function () {
                        return this._font.getBBox(this._fontSize);
                    },
                    currentFontSize: function () {
                        return this._fontSize;
                    },
                    registerFont: function (name, src, family) {
                        this._registeredFonts[name] = {
                            src: src,
                            family: family
                        };
                        return this;
                    }
                };
            }, { "../font": 3 }], 15: [function (localRequire, localModule, localExports) {
                (function (Buffer) {
                    var PDFImage;
                    PDFImage = localRequire('../image');
                    localModule.localExports = {
                        initImages: function () {
                            this._imageRegistry = {};
                            return this._imageCount = 0;
                        },
                        image: function (src, x, y, options) {
                            var bh, bp, bw, h, hp, image, ip, w, wp, _base, _name, _ref, _ref1, _ref2;
                            if (options == null) {
                                options = {};
                            }
                            if (typeof x === 'object') {
                                options = x;
                                x = null;
                            }
                            x = (_ref = x != null ? x : options.x) != null ? _ref : this.x;
                            y = (_ref1 = y != null ? y : options.y) != null ? _ref1 : this.y;
                            if (!Buffer.isBuffer(src)) {
                                image = this._imageRegistry[src];
                            }
                            if (!image) {
                                image = PDFImage.open(src, 'I' + (++this._imageCount));
                                image.embed(this);
                                if (!Buffer.isBuffer(src)) {
                                    this._imageRegistry[src] = image;
                                }
                            }
                            if ((_base = this.page.xobjects)[_name = image.label] == null) {
                                _base[_name] = image.obj;
                            }
                            var imageWidth = image.width * 0.75;
                            var imageHeight = image.height * 0.75;
                            w = options.width || imageWidth;
                            h = options.height || imageHeight;
                            if (options.width && !options.height) {
                                wp = w / imageWidth;
                                w = imageWidth * wp;
                                h = imageHeight * wp;
                            }
                            else if (options.height && !options.width) {
                                hp = h / imageHeight;
                                w = imageWidth * hp;
                                h = imageHeight * hp;
                            }
                            else if (options.scale) {
                                w = imageWidth * options.scale;
                                h = imageHeight * options.scale;
                            }
                            else if (options.fit) {
                                _ref2 = options.fit, bw = _ref2[0], bh = _ref2[1];
                                bp = bw / bh;
                                ip = imageWidth / imageHeight;
                                if (ip > bp) {
                                    w = bw;
                                    h = bw / ip;
                                }
                                else {
                                    h = bh;
                                    w = bh * ip;
                                }
                                if (options.align === 'center') {
                                    x = x + bw / 2 - w / 2;
                                }
                                else if (options.align === 'right') {
                                    x = x + bw - w;
                                }
                                if (options.valign === 'center') {
                                    y = y + bh / 2 - h / 2;
                                }
                                else if (options.valign === 'bottom') {
                                    y = y + bh - h;
                                }
                            }
                            if (this.y === y) {
                                this.y += h;
                            }
                            this.save();
                            this.transform(w, 0, 0, -h, x, y + h);
                            this.addContent("/" + image.label + " Do");
                            this.restore();
                            return this;
                        }
                    };
                }).call(this, { "isBuffer": localRequire("../../node_modules/is-buffer/index.js") });
            }, { "../../node_modules/is-buffer/index.js": 168, "../image": 8 }], 16: [function (localRequire, localModule, localExports) {
                var LineWrapper;
                LineWrapper = localRequire('../line_wrapper');
                localModule.localExports = {
                    initText: function () {
                        this.x = 0;
                        this.y = 0;
                        return this._lineGap = 0;
                    },
                    currentLineGap: function () {
                        return this._lineGap;
                    },
                    lineGap: function (_lineGap) {
                        this._lineGap = _lineGap;
                        return this;
                    },
                    moveDown: function (lines) {
                        if (lines == null) {
                            lines = 1;
                        }
                        this.y += this.currentLineHeight(true) * lines + this._lineGap;
                        return this;
                    },
                    moveUp: function (lines) {
                        if (lines == null) {
                            lines = 1;
                        }
                        this.y -= this.currentLineHeight(true) * lines + this._lineGap;
                        return this;
                    },
                    _text: function (text, x, y, options, lineCallback) {
                        var line, wrapper, _i, _len, _ref;
                        options = this._initOptions(x, y, options);
                        text = '' + text;
                        if (options.wordSpacing) {
                            text = text.replace(/\s{2,}/g, ' ');
                        }
                        if (options.width) {
                            wrapper = this._wrapper;
                            if (!wrapper) {
                                wrapper = new LineWrapper(this, options);
                                wrapper.on('line', lineCallback);
                            }
                            this._wrapper = options.continued ? wrapper : null;
                            this._textOptions = options.continued ? options : null;
                            wrapper.wrap(text, options);
                        }
                        else {
                            _ref = text.split('\n');
                            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                                line = _ref[_i];
                                lineCallback(line, options);
                            }
                        }
                        return this;
                    },
                    text: function (text, x, y, options) {
                        return this._text(text, x, y, options, this._line.bind(this));
                    },
                    widthOfString: function (string, options) {
                        if (options == null) {
                            options = {};
                        }
                        return this._font.widthOfString(string, this._fontSize, options.features) + (options.characterSpacing || 0) * (string.length - 1);
                    },
                    heightOfString: function (text, options) {
                        var height, lineGap, x, y;
                        if (options == null) {
                            options = {};
                        }
                        x = this.x, y = this.y;
                        options = this._initOptions(options);
                        options.height = Infinity;
                        lineGap = options.lineGap || this._lineGap || 0;
                        this._text(text, this.x, this.y, options, (function (_this) {
                            return function (line, options) {
                                return _this.y += _this.currentLineHeight(true) + lineGap;
                            };
                        })(this));
                        height = this.y - y;
                        this.x = x;
                        this.y = y;
                        return height;
                    },
                    textAndMeasure: function (text, x, y, options, measureOnly) {
                        options = options || {};
                        if (x == null) {
                            x = this.x;
                            y = this.y;
                        }
                        var self = this, tx = this.x, ty = this.y, sz = { width: 0, height: 0, charCount: 0 }, lineGap = options.lineGap || this._lineGap || 0, columnGap = options.columnGap || 18, lastColX = x == null ? this.x : x, col = [], colCnt = 0;
                        if (measureOnly) {
                            if (options.height == null) {
                                options.height = Infinity;
                            }
                        }
                        this._text(text, x, y, options, function (line, options, wrapper) {
                            sz.charCount += line.length;
                            if (self.x === x) {
                                sz.height += self.currentLineHeight(true) + lineGap;
                            }
                            if (options.textWidth) {
                                if (self.x > lastColX) {
                                    lastColX = self.x;
                                    col[colCnt++] = options.lineWidth;
                                }
                                col[colCnt] = Math.max(col[colCnt] || 0, options.textWidth);
                            }
                            if (measureOnly) {
                                if (!wrapper) {
                                    self.x += self.widthOfString(text);
                                }
                                else {
                                    self.y += self.currentLineHeight(true) + lineGap;
                                }
                            }
                            else {
                                self._line.apply(self, arguments);
                            }
                        });
                        if (!col.length) {
                            sz.width = this.x - tx;
                        }
                        else {
                            col.forEach(function (v) { sz.width += v + columnGap; });
                            sz.width -= columnGap;
                        }
                        if (options.includeLastLineExternalLeading === false) {
                            sz.height -= this.currentLineHeight(true) - this.currentLineHeight(false);
                        }
                        sz.height = Math.max(0, sz.height);
                        if (measureOnly) {
                            this.x = tx;
                            this.y = ty;
                        }
                        return sz;
                    },
                    list: function (list, x, y, options, wrapper) {
                        var flatten, i, indent, itemIndent, items, level, levels, r;
                        options = this._initOptions(x, y, options);
                        r = Math.round((this._font.ascender / 1000 * this._fontSize) / 3);
                        indent = options.textIndent || r * 5;
                        itemIndent = options.bulletIndent || r * 8;
                        level = 1;
                        items = [];
                        levels = [];
                        flatten = function (list) {
                            var i, item, _i, _len, _results;
                            _results = [];
                            for (i = _i = 0, _len = list.length; _i < _len; i = ++_i) {
                                item = list[i];
                                if (Array.isArray(item)) {
                                    level++;
                                    flatten(item);
                                    _results.push(level--);
                                }
                                else {
                                    items.push(item);
                                    _results.push(levels.push(level));
                                }
                            }
                            return _results;
                        };
                        flatten(list);
                        wrapper = new LineWrapper(this, options);
                        wrapper.on('line', this._line.bind(this));
                        level = 1;
                        i = 0;
                        wrapper.on('firstLine', (function (_this) {
                            return function () {
                                var diff, l;
                                if ((l = levels[i++]) !== level) {
                                    diff = itemIndent * (l - level);
                                    _this.x += diff;
                                    wrapper.lineWidth -= diff;
                                    level = l;
                                }
                                _this.circle(_this.x - indent + r, _this.y + r + (r / 2), r);
                                return _this.fill();
                            };
                        })(this));
                        wrapper.on('sectionStart', (function (_this) {
                            return function () {
                                var pos;
                                pos = indent + itemIndent * (level - 1);
                                _this.x += pos;
                                return wrapper.lineWidth -= pos;
                            };
                        })(this));
                        wrapper.on('sectionEnd', (function (_this) {
                            return function () {
                                var pos;
                                pos = indent + itemIndent * (level - 1);
                                _this.x -= pos;
                                return wrapper.lineWidth += pos;
                            };
                        })(this));
                        wrapper.wrap(items.join('\n'), options);
                        return this;
                    },
                    _initOptions: function (x, y, options) {
                        var key, margins, val, _ref;
                        if (x == null) {
                            x = {};
                        }
                        if (options == null) {
                            options = {};
                        }
                        if (typeof x === 'object') {
                            options = x;
                            x = null;
                        }
                        options = (function () {
                            var k, opts, v;
                            opts = {};
                            for (k in options) {
                                v = options[k];
                                opts[k] = v;
                            }
                            return opts;
                        })();
                        if (this._textOptions) {
                            _ref = this._textOptions;
                            for (key in _ref) {
                                val = _ref[key];
                                if (key !== 'continued') {
                                    if (options[key] == null) {
                                        options[key] = val;
                                    }
                                }
                            }
                        }
                        if (x != null) {
                            this.x = x;
                        }
                        if (y != null) {
                            this.y = y;
                        }
                        if (options.lineBreak !== false) {
                            margins = this.page.margins;
                            if (options.width == null) {
                                options.width = this.page.width - this.x - margins.right;
                                options.width = Math.max(options.width, 0);
                            }
                        }
                        options.columns || (options.columns = 0);
                        if (options.columnGap == null) {
                            options.columnGap = 18;
                        }
                        return options;
                    },
                    _line: function (text, options, wrapper) {
                        var lineGap;
                        if (options == null) {
                            options = {};
                        }
                        this._fragment(text, this.x, this.y, options);
                        lineGap = options.lineGap || this._lineGap || 0;
                        if (!wrapper) {
                            return this.x += this.widthOfString(text);
                        }
                        else {
                            return this.y += this.currentLineHeight(true) + lineGap;
                        }
                    },
                    _fragment: function (text, x, y, options) {
                        var addSegment, align, characterSpacing, commands, d, encoded, encodedWord, flush, hadOffset, i, last, lineWidth, lineY, mode, pos, positions, positionsWord, renderedWidth, scale, spaceWidth, textWidth, word, wordSpacing, words, _base, _i, _j, _len, _len1, _name, _ref, _ref1;
                        text = ('' + text).replace(/\n/g, '');
                        if (text.length === 0) {
                            return;
                        }
                        align = options.align || 'left';
                        wordSpacing = options.wordSpacing || 0;
                        characterSpacing = options.characterSpacing || 0;
                        if (options.width) {
                            switch (align) {
                                case 'right':
                                    textWidth = this.widthOfString(text.replace(/\s+$/, ''), options);
                                    x += options.lineWidth - textWidth;
                                    break;
                                case 'center':
                                    x += options.lineWidth / 2 - options.textWidth / 2;
                                    break;
                                case 'justify':
                                    words = text.trim().split(/\s+/);
                                    textWidth = this.widthOfString(text.replace(/\s+/g, ''), options);
                                    spaceWidth = this.widthOfString(' ') + characterSpacing;
                                    wordSpacing = Math.max(0, (options.lineWidth - textWidth) / Math.max(1, words.length - 1) - spaceWidth);
                            }
                        }
                        renderedWidth = options.textWidth + (wordSpacing * (options.wordCount - 1)) + (characterSpacing * (text.length - 1));
                        if (options.link) {
                            this.link(x, y, renderedWidth, this.currentLineHeight(), options.link);
                        }
                        if (options.underline || options.strike) {
                            this.save();
                            if (!options.stroke) {
                                this.strokeColor.apply(this, this._fillColor);
                            }
                            lineWidth = this._fontSize < 10 ? 0.5 : Math.floor(this._fontSize / 10);
                            this.lineWidth(lineWidth);
                            d = options.underline ? 1 : 2;
                            lineY = y + this.currentLineHeight() / d;
                            if (options.underline) {
                                lineY -= lineWidth;
                            }
                            this.moveTo(x, lineY);
                            this.lineTo(x + renderedWidth, lineY);
                            this.stroke();
                            this.restore();
                        }
                        this.save();
                        this.transform(1, 0, 0, -1, 0, this.page.height);
                        y = this.page.height - y - (this._font.ascender / 1000 * this._fontSize);
                        if ((_base = this.page.fonts)[_name = this._font.id] == null) {
                            _base[_name] = this._font.ref();
                        }
                        this.addContent("BT");
                        this.addContent("1 0 0 1 " + x + " " + y + " Tm");
                        this.addContent("/" + this._font.id + " " + this._fontSize + " Tf");
                        mode = options.fill && options.stroke ? 2 : options.stroke ? 1 : 0;
                        if (mode) {
                            this.addContent("" + mode + " Tr");
                        }
                        if (characterSpacing) {
                            this.addContent("" + characterSpacing + " Tc");
                        }
                        if (wordSpacing) {
                            words = text.trim().split(/\s+/);
                            wordSpacing += this.widthOfString(' ') + characterSpacing;
                            wordSpacing *= 1000 / this._fontSize;
                            encoded = [];
                            positions = [];
                            for (_i = 0, _len = words.length; _i < _len; _i++) {
                                word = words[_i];
                                _ref = this._font.encode(word, options.features), encodedWord = _ref[0], positionsWord = _ref[1];
                                encoded.push.apply(encoded, encodedWord);
                                positions.push.apply(positions, positionsWord);
                                positions[positions.length - 1].xAdvance += wordSpacing;
                            }
                        }
                        else {
                            _ref1 = this._font.encode(text, options.features), encoded = _ref1[0], positions = _ref1[1];
                        }
                        scale = this._fontSize / 1000;
                        commands = [];
                        last = 0;
                        hadOffset = false;
                        addSegment = (function (_this) {
                            return function (cur) {
                                var advance, hex;
                                if (last < cur) {
                                    hex = encoded.slice(last, cur).join('');
                                    advance = positions[cur - 1].xAdvance - positions[cur - 1].advanceWidth;
                                    commands.push("<" + hex + "> " + (-advance));
                                }
                                return last = cur;
                            };
                        })(this);
                        flush = (function (_this) {
                            return function (i) {
                                addSegment(i);
                                if (commands.length > 0) {
                                    _this.addContent("[" + (commands.join(' ')) + "] TJ");
                                    return commands.length = 0;
                                }
                            };
                        })(this);
                        for (i = _j = 0, _len1 = positions.length; _j < _len1; i = ++_j) {
                            pos = positions[i];
                            if (pos.xOffset || pos.yOffset) {
                                flush(i);
                                this.addContent("1 0 0 1 " + (x + pos.xOffset * scale) + " " + (y + pos.yOffset * scale) + " Tm");
                                flush(i + 1);
                                hadOffset = true;
                            }
                            else {
                                if (hadOffset) {
                                    this.addContent("1 0 0 1 " + x + " " + y + " Tm");
                                    hadOffset = false;
                                }
                                if (pos.xAdvance - pos.advanceWidth !== 0) {
                                    addSegment(i + 1);
                                }
                            }
                            x += pos.xAdvance * scale;
                        }
                        flush(i);
                        this.addContent("ET");
                        return this.restore();
                    }
                };
            }, { "../line_wrapper": 11 }], 17: [function (localRequire, localModule, localExports) {
                var KAPPA, SVGPath, __slice = [].slice;
                SVGPath = localRequire('../path');
                KAPPA = 4.0 * ((Math.sqrt(2) - 1.0) / 3.0);
                localModule.localExports = {
                    initVector: function () {
                        this._ctm = [1, 0, 0, 1, 0, 0];
                        return this._ctmStack = [];
                    },
                    save: function () {
                        this._ctmStack.push(this._ctm.slice());
                        return this.addContent('q');
                    },
                    restore: function () {
                        this._ctm = this._ctmStack.pop() || [1, 0, 0, 1, 0, 0];
                        return this.addContent('Q');
                    },
                    closePath: function () {
                        return this.addContent('h');
                    },
                    lineWidth: function (w) {
                        return this.addContent("" + w + " w");
                    },
                    _CAP_STYLES: {
                        BUTT: 0,
                        ROUND: 1,
                        SQUARE: 2
                    },
                    lineCap: function (c) {
                        if (typeof c === 'string') {
                            c = this._CAP_STYLES[c.toUpperCase()];
                        }
                        return this.addContent("" + c + " J");
                    },
                    _JOIN_STYLES: {
                        MITER: 0,
                        ROUND: 1,
                        BEVEL: 2
                    },
                    lineJoin: function (j) {
                        if (typeof j === 'string') {
                            j = this._JOIN_STYLES[j.toUpperCase()];
                        }
                        return this.addContent("" + j + " j");
                    },
                    miterLimit: function (m) {
                        return this.addContent("" + m + " M");
                    },
                    dash: function (length, options) {
                        var phase, space, _ref;
                        if (options == null) {
                            options = {};
                        }
                        if (length == null) {
                            return this;
                        }
                        space = (_ref = options.space) != null ? _ref : length;
                        phase = options.phase || 0;
                        return this.addContent("[" + length + " " + space + "] " + phase + " d");
                    },
                    undash: function () {
                        return this.addContent("[] 0 d");
                    },
                    moveTo: function (x, y) {
                        return this.addContent("" + x + " " + y + " m");
                    },
                    lineTo: function (x, y) {
                        return this.addContent("" + x + " " + y + " l");
                    },
                    bezierCurveTo: function (cp1x, cp1y, cp2x, cp2y, x, y) {
                        return this.addContent("" + cp1x + " " + cp1y + " " + cp2x + " " + cp2y + " " + x + " " + y + " c");
                    },
                    quadraticCurveTo: function (cpx, cpy, x, y) {
                        return this.addContent("" + cpx + " " + cpy + " " + x + " " + y + " v");
                    },
                    rect: function (x, y, w, h) {
                        return this.addContent("" + x + " " + y + " " + w + " " + h + " re");
                    },
                    roundedRect: function (x, y, w, h, r) {
                        if (r == null) {
                            r = 0;
                        }
                        this.moveTo(x + r, y);
                        this.lineTo(x + w - r, y);
                        this.quadraticCurveTo(x + w, y, x + w, y + r);
                        this.lineTo(x + w, y + h - r);
                        this.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
                        this.lineTo(x + r, y + h);
                        this.quadraticCurveTo(x, y + h, x, y + h - r);
                        this.lineTo(x, y + r);
                        return this.quadraticCurveTo(x, y, x + r, y);
                    },
                    ellipse: function (x, y, r1, r2) {
                        var ox, oy, xe, xm, ye, ym;
                        if (r2 == null) {
                            r2 = r1;
                        }
                        x -= r1;
                        y -= r2;
                        ox = r1 * KAPPA;
                        oy = r2 * KAPPA;
                        xe = x + r1 * 2;
                        ye = y + r2 * 2;
                        xm = x + r1;
                        ym = y + r2;
                        this.moveTo(x, ym);
                        this.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);
                        this.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);
                        this.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);
                        this.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);
                        return this.closePath();
                    },
                    circle: function (x, y, radius) {
                        return this.ellipse(x, y, radius);
                    },
                    polygon: function () {
                        var point, points, _i, _len;
                        points = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
                        this.moveTo.apply(this, points.shift());
                        for (_i = 0, _len = points.length; _i < _len; _i++) {
                            point = points[_i];
                            this.lineTo.apply(this, point);
                        }
                        return this.closePath();
                    },
                    path: function (path) {
                        SVGPath.apply(this, path);
                        return this;
                    },
                    _windingRule: function (rule) {
                        if (/even-?odd/.test(rule)) {
                            return '*';
                        }
                        return '';
                    },
                    fill: function (color, rule) {
                        if (/(even-?odd)|(non-?zero)/.test(color)) {
                            rule = color;
                            color = null;
                        }
                        if (color) {
                            this.fillColor(color);
                        }
                        return this.addContent('f' + this._windingRule(rule));
                    },
                    stroke: function (color) {
                        if (color) {
                            this.strokeColor(color);
                        }
                        return this.addContent('S');
                    },
                    fillAndStroke: function (fillColor, strokeColor, rule) {
                        var isFillRule;
                        if (strokeColor == null) {
                            strokeColor = fillColor;
                        }
                        isFillRule = /(even-?odd)|(non-?zero)/;
                        if (isFillRule.test(fillColor)) {
                            rule = fillColor;
                            fillColor = null;
                        }
                        if (isFillRule.test(strokeColor)) {
                            rule = strokeColor;
                            strokeColor = fillColor;
                        }
                        if (fillColor) {
                            this.fillColor(fillColor);
                            this.strokeColor(strokeColor);
                        }
                        return this.addContent('B' + this._windingRule(rule));
                    },
                    clip: function (rule) {
                        return this.addContent('W' + this._windingRule(rule) + ' n');
                    },
                    transform: function (m11, m12, m21, m22, dx, dy) {
                        var m, m0, m1, m2, m3, m4, m5, v, values;
                        m = this._ctm;
                        m0 = m[0], m1 = m[1], m2 = m[2], m3 = m[3], m4 = m[4], m5 = m[5];
                        m[0] = m0 * m11 + m2 * m12;
                        m[1] = m1 * m11 + m3 * m12;
                        m[2] = m0 * m21 + m2 * m22;
                        m[3] = m1 * m21 + m3 * m22;
                        m[4] = m0 * dx + m2 * dy + m4;
                        m[5] = m1 * dx + m3 * dy + m5;
                        values = ((function () {
                            var _i, _len, _ref, _results;
                            _ref = [m11, m12, m21, m22, dx, dy];
                            _results = [];
                            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                                v = _ref[_i];
                                _results.push(+v.toFixed(5));
                            }
                            return _results;
                        })()).join(' ');
                        return this.addContent("" + values + " cm");
                    },
                    translate: function (x, y) {
                        return this.transform(1, 0, 0, 1, x, y);
                    },
                    rotate: function (angle, options) {
                        var cos, rad, sin, x, x1, y, y1, _ref;
                        if (options == null) {
                            options = {};
                        }
                        rad = angle * Math.PI / 180;
                        cos = Math.cos(rad);
                        sin = Math.sin(rad);
                        x = y = 0;
                        if (options.origin != null) {
                            _ref = options.origin, x = _ref[0], y = _ref[1];
                            x1 = x * cos - y * sin;
                            y1 = x * sin + y * cos;
                            x -= x1;
                            y -= y1;
                        }
                        return this.transform(cos, sin, -sin, cos, x, y);
                    },
                    scale: function (xFactor, yFactor, options) {
                        var x, y, _ref;
                        if (yFactor == null) {
                            yFactor = xFactor;
                        }
                        if (options == null) {
                            options = {};
                        }
                        if (arguments.length === 2) {
                            yFactor = xFactor;
                            options = yFactor;
                        }
                        x = y = 0;
                        if (options.origin != null) {
                            _ref = options.origin, x = _ref[0], y = _ref[1];
                            x -= xFactor * x;
                            y -= yFactor * y;
                        }
                        return this.transform(xFactor, 0, 0, yFactor, x, y);
                    }
                };
            }, { "../path": 20 }], 18: [function (localRequire, localModule, localExports) {
                (function (Buffer) {
                    var PDFObject, PDFReference;
                    PDFObject = (function () {
                        var escapable, escapableRe, pad, swapBytes;
                        function PDFObject() { }
                        pad = function (str, length) {
                            return (Array(length + 1).join('0') + str).slice(-length);
                        };
                        escapableRe = /[\n\r\t\b\f\(\)\\]/g;
                        escapable = {
                            '\n': '\\n',
                            '\r': '\\r',
                            '\t': '\\t',
                            '\b': '\\b',
                            '\f': '\\f',
                            '\\': '\\\\',
                            '(': '\\(',
                            ')': '\\)'
                        };
                        swapBytes = function (buff) {
                            var a, i, l, _i, _ref;
                            l = buff.length;
                            if (l & 0x01) {
                                throw new Error("Buffer length must be even");
                            }
                            else {
                                for (i = _i = 0, _ref = l - 1; _i < _ref; i = _i += 2) {
                                    a = buff[i];
                                    buff[i] = buff[i + 1];
                                    buff[i + 1] = a;
                                }
                            }
                            return buff;
                        };
                        PDFObject.convert = function (object) {
                            var e, i, isUnicode, items, key, out, string, val, _i, _ref;
                            if (typeof object === 'string') {
                                return '/' + object;
                            }
                            else if (object instanceof String) {
                                string = object.replace(escapableRe, function (c) {
                                    return escapable[c];
                                });
                                isUnicode = false;
                                for (i = _i = 0, _ref = string.length; _i < _ref; i = _i += 1) {
                                    if (string.charCodeAt(i) > 0x7f) {
                                        isUnicode = true;
                                        break;
                                    }
                                }
                                if (isUnicode) {
                                    string = swapBytes(new Buffer('\ufeff' + string, 'utf16le')).toString('binary');
                                }
                                return '(' + string + ')';
                            }
                            else if (Buffer.isBuffer(object)) {
                                return '<' + object.toString('hex') + '>';
                            }
                            else if (object instanceof PDFReference) {
                                return object.toString();
                            }
                            else if (object instanceof Date) {
                                return '(D:' + pad(object.getUTCFullYear(), 4) + pad(object.getUTCMonth() + 1, 2) + pad(object.getUTCDate(), 2) + pad(object.getUTCHours(), 2) + pad(object.getUTCMinutes(), 2) + pad(object.getUTCSeconds(), 2) + 'Z)';
                            }
                            else if (Array.isArray(object)) {
                                items = ((function () {
                                    var _j, _len, _results;
                                    _results = [];
                                    for (_j = 0, _len = object.length; _j < _len; _j++) {
                                        e = object[_j];
                                        _results.push(PDFObject.convert(e));
                                    }
                                    return _results;
                                })()).join(' ');
                                return '[' + items + ']';
                            }
                            else if ({}.toString.call(object) === '[object Object]') {
                                out = ['<<'];
                                for (key in object) {
                                    val = object[key];
                                    out.push('/' + key + ' ' + PDFObject.convert(val));
                                }
                                out.push('>>');
                                return out.join('\n');
                            }
                            else {
                                return '' + object;
                            }
                        };
                        return PDFObject;
                    })();
                    localModule.localExports = PDFObject;
                    PDFReference = localRequire('./reference');
                }).call(this, localRequire("buffer").Buffer);
            }, { "./reference": 21, "buffer": 60 }], 19: [function (localRequire, localModule, localExports) {
                var PDFPage;
                PDFPage = (function () {
                    var DEFAULT_MARGINS, SIZES;
                    function PDFPage(document, options) {
                        var dimensions;
                        this.document = document;
                        if (options == null) {
                            options = {};
                        }
                        this.size = options.size || 'letter';
                        this.layout = options.layout || 'portrait';
                        if (typeof options.margin === 'number') {
                            this.margins = {
                                top: options.margin,
                                left: options.margin,
                                bottom: options.margin,
                                right: options.margin
                            };
                        }
                        else {
                            this.margins = options.margins || DEFAULT_MARGINS;
                            this.margins = {
                                top: this.margins.top,
                                left: this.margins.left,
                                bottom: this.margins.bottom,
                                right: this.margins.right
                            };
                        }
                        dimensions = Array.isArray(this.size) ? this.size : SIZES[this.size.toUpperCase()];
                        this.width = dimensions[this.layout === 'portrait' ? 0 : 1];
                        this.height = dimensions[this.layout === 'portrait' ? 1 : 0];
                        this.content = this.document.ref();
                        this.resources = this.document.ref({
                            ProcSet: ['PDF', 'Text', 'ImageB', 'ImageC', 'ImageI']
                        });
                        Object.defineProperties(this, {
                            fonts: {
                                get: (function (_this) {
                                    return function () {
                                        var _base;
                                        return (_base = _this.resources.data).Font != null ? _base.Font : _base.Font = {};
                                    };
                                })(this)
                            },
                            xobjects: {
                                get: (function (_this) {
                                    return function () {
                                        var _base;
                                        return (_base = _this.resources.data).XObject != null ? _base.XObject : _base.XObject = {};
                                    };
                                })(this)
                            },
                            ext_gstates: {
                                get: (function (_this) {
                                    return function () {
                                        var _base;
                                        return (_base = _this.resources.data).ExtGState != null ? _base.ExtGState : _base.ExtGState = {};
                                    };
                                })(this)
                            },
                            patterns: {
                                get: (function (_this) {
                                    return function () {
                                        var _base;
                                        return (_base = _this.resources.data).Pattern != null ? _base.Pattern : _base.Pattern = {};
                                    };
                                })(this)
                            },
                            annotations: {
                                get: (function (_this) {
                                    return function () {
                                        var _base;
                                        return (_base = _this.dictionary.data).Annots != null ? _base.Annots : _base.Annots = [];
                                    };
                                })(this)
                            }
                        });
                        this.dictionary = this.document.ref({
                            Type: 'Page',
                            Parent: this.document._root.data.Pages,
                            MediaBox: [0, 0, this.width, this.height],
                            Contents: this.content,
                            Resources: this.resources
                        });
                    }
                    PDFPage.prototype.maxY = function () {
                        return this.height - this.margins.bottom;
                    };
                    PDFPage.prototype.write = function (chunk) {
                        return this.content.write(chunk);
                    };
                    PDFPage.prototype.end = function () {
                        this.dictionary.end();
                        this.resources.end();
                        return this.content.end();
                    };
                    DEFAULT_MARGINS = {
                        top: 72,
                        left: 72,
                        bottom: 72,
                        right: 72
                    };
                    SIZES = {
                        '4A0': [4767.87, 6740.79],
                        '2A0': [3370.39, 4767.87],
                        A0: [2383.94, 3370.39],
                        A1: [1683.78, 2383.94],
                        A2: [1190.55, 1683.78],
                        A3: [841.89, 1190.55],
                        A4: [595.28, 841.89],
                        A5: [419.53, 595.28],
                        A6: [297.64, 419.53],
                        A7: [209.76, 297.64],
                        A8: [147.40, 209.76],
                        A9: [104.88, 147.40],
                        A10: [73.70, 104.88],
                        B0: [2834.65, 4008.19],
                        B1: [2004.09, 2834.65],
                        B2: [1417.32, 2004.09],
                        B3: [1000.63, 1417.32],
                        B4: [708.66, 1000.63],
                        B5: [498.90, 708.66],
                        B6: [354.33, 498.90],
                        B7: [249.45, 354.33],
                        B8: [175.75, 249.45],
                        B9: [124.72, 175.75],
                        B10: [87.87, 124.72],
                        C0: [2599.37, 3676.54],
                        C1: [1836.85, 2599.37],
                        C2: [1298.27, 1836.85],
                        C3: [918.43, 1298.27],
                        C4: [649.13, 918.43],
                        C5: [459.21, 649.13],
                        C6: [323.15, 459.21],
                        C7: [229.61, 323.15],
                        C8: [161.57, 229.61],
                        C9: [113.39, 161.57],
                        C10: [79.37, 113.39],
                        RA0: [2437.80, 3458.27],
                        RA1: [1729.13, 2437.80],
                        RA2: [1218.90, 1729.13],
                        RA3: [864.57, 1218.90],
                        RA4: [609.45, 864.57],
                        SRA0: [2551.18, 3628.35],
                        SRA1: [1814.17, 2551.18],
                        SRA2: [1275.59, 1814.17],
                        SRA3: [907.09, 1275.59],
                        SRA4: [637.80, 907.09],
                        EXECUTIVE: [521.86, 756.00],
                        FOLIO: [612.00, 936.00],
                        LEGAL: [612.00, 1008.00],
                        LETTER: [612.00, 792.00],
                        TABLOID: [792.00, 1224.00]
                    };
                    return PDFPage;
                })();
                localModule.localExports = PDFPage;
            }, {}], 20: [function (localRequire, localModule, localExports) {
                var SVGPath;
                SVGPath = (function () {
                    var apply, arcToSegments, cx, cy, fixRoundingError, parameters, parse, px, py, runners, segmentToBezier, solveArc, sx, sy;
                    function SVGPath() { }
                    SVGPath.apply = function (doc, path) {
                        var commands;
                        commands = parse(path);
                        return apply(commands, doc);
                    };
                    parameters = {
                        A: 7,
                        a: 7,
                        C: 6,
                        c: 6,
                        H: 1,
                        h: 1,
                        L: 2,
                        l: 2,
                        M: 2,
                        m: 2,
                        Q: 4,
                        q: 4,
                        S: 4,
                        s: 4,
                        T: 2,
                        t: 2,
                        V: 1,
                        v: 1,
                        Z: 0,
                        z: 0
                    };
                    parse = function (path) {
                        var args, c, cmd, curArg, foundDecimal, params, ret, _i, _len;
                        ret = [];
                        args = [];
                        curArg = "";
                        foundDecimal = false;
                        params = 0;
                        for (_i = 0, _len = path.length; _i < _len; _i++) {
                            c = path[_i];
                            if (parameters[c] != null) {
                                params = parameters[c];
                                if (cmd) {
                                    if (curArg.length > 0) {
                                        args[args.length] = +curArg;
                                    }
                                    ret[ret.length] = {
                                        cmd: cmd,
                                        args: args
                                    };
                                    args = [];
                                    curArg = "";
                                    foundDecimal = false;
                                }
                                cmd = c;
                            }
                            else if ((c === " " || c === ",") || (c === "-" && curArg.length > 0 && curArg[curArg.length - 1] !== 'e') || (c === "." && foundDecimal)) {
                                if (curArg.length === 0) {
                                    continue;
                                }
                                if (args.length === params) {
                                    ret[ret.length] = {
                                        cmd: cmd,
                                        args: args
                                    };
                                    args = [+curArg];
                                    if (cmd === "M") {
                                        cmd = "L";
                                    }
                                    if (cmd === "m") {
                                        cmd = "l";
                                    }
                                }
                                else {
                                    args[args.length] = +curArg;
                                }
                                foundDecimal = c === ".";
                                curArg = c === '-' || c === '.' ? c : '';
                            }
                            else {
                                curArg += c;
                                if (c === '.') {
                                    foundDecimal = true;
                                }
                            }
                        }
                        if (curArg.length > 0) {
                            if (args.length === params) {
                                ret[ret.length] = {
                                    cmd: cmd,
                                    args: args
                                };
                                args = [+curArg];
                                if (cmd === "M") {
                                    cmd = "L";
                                }
                                if (cmd === "m") {
                                    cmd = "l";
                                }
                            }
                            else {
                                args[args.length] = +curArg;
                            }
                        }
                        ret[ret.length] = {
                            cmd: cmd,
                            args: args
                        };
                        return ret;
                    };
                    cx = cy = px = py = sx = sy = 0;
                    apply = function (commands, doc) {
                        var c, i, _i, _len, _name;
                        cx = cy = px = py = sx = sy = 0;
                        for (i = _i = 0, _len = commands.length; _i < _len; i = ++_i) {
                            c = commands[i];
                            if (typeof runners[_name = c.cmd] === "function") {
                                runners[_name](doc, c.args);
                            }
                        }
                        return cx = cy = px = py = 0;
                    };
                    runners = {
                        M: function (doc, a) {
                            cx = a[0];
                            cy = a[1];
                            px = py = null;
                            sx = cx;
                            sy = cy;
                            return doc.moveTo(cx, cy);
                        },
                        m: function (doc, a) {
                            cx += a[0];
                            cy += a[1];
                            px = py = null;
                            sx = cx;
                            sy = cy;
                            return doc.moveTo(cx, cy);
                        },
                        C: function (doc, a) {
                            cx = a[4];
                            cy = a[5];
                            px = a[2];
                            py = a[3];
                            return doc.bezierCurveTo.apply(doc, a);
                        },
                        c: function (doc, a) {
                            doc.bezierCurveTo(a[0] + cx, a[1] + cy, a[2] + cx, a[3] + cy, a[4] + cx, a[5] + cy);
                            px = cx + a[2];
                            py = cy + a[3];
                            cx += a[4];
                            return cy += a[5];
                        },
                        S: function (doc, a) {
                            if (px === null) {
                                px = cx;
                                py = cy;
                            }
                            doc.bezierCurveTo(cx - (px - cx), cy - (py - cy), a[0], a[1], a[2], a[3]);
                            px = a[0];
                            py = a[1];
                            cx = a[2];
                            return cy = a[3];
                        },
                        s: function (doc, a) {
                            if (px === null) {
                                px = cx;
                                py = cy;
                            }
                            doc.bezierCurveTo(cx - (px - cx), cy - (py - cy), cx + a[0], cy + a[1], cx + a[2], cy + a[3]);
                            px = cx + a[0];
                            py = cy + a[1];
                            cx += a[2];
                            return cy += a[3];
                        },
                        Q: function (doc, a) {
                            px = a[0];
                            py = a[1];
                            cx = a[2];
                            cy = a[3];
                            return doc.quadraticCurveTo(a[0], a[1], cx, cy);
                        },
                        q: function (doc, a) {
                            doc.quadraticCurveTo(a[0] + cx, a[1] + cy, a[2] + cx, a[3] + cy);
                            px = cx + a[0];
                            py = cy + a[1];
                            cx += a[2];
                            return cy += a[3];
                        },
                        T: function (doc, a) {
                            if (px === null) {
                                px = cx;
                                py = cy;
                            }
                            else {
                                px = cx - (px - cx);
                                py = cy - (py - cy);
                            }
                            doc.quadraticCurveTo(px, py, a[0], a[1]);
                            px = cx - (px - cx);
                            py = cy - (py - cy);
                            cx = a[0];
                            return cy = a[1];
                        },
                        t: function (doc, a) {
                            if (px === null) {
                                px = cx;
                                py = cy;
                            }
                            else {
                                px = cx - (px - cx);
                                py = cy - (py - cy);
                            }
                            doc.quadraticCurveTo(px, py, cx + a[0], cy + a[1]);
                            cx += a[0];
                            return cy += a[1];
                        },
                        A: function (doc, a) {
                            solveArc(doc, cx, cy, a);
                            cx = a[5];
                            return cy = a[6];
                        },
                        a: function (doc, a) {
                            a[5] += cx;
                            a[6] += cy;
                            solveArc(doc, cx, cy, a);
                            cx = a[5];
                            return cy = a[6];
                        },
                        L: function (doc, a) {
                            cx = a[0];
                            cy = a[1];
                            px = py = null;
                            return doc.lineTo(cx, cy);
                        },
                        l: function (doc, a) {
                            cx += a[0];
                            cy += a[1];
                            px = py = null;
                            return doc.lineTo(cx, cy);
                        },
                        H: function (doc, a) {
                            cx = a[0];
                            px = py = null;
                            return doc.lineTo(cx, cy);
                        },
                        h: function (doc, a) {
                            cx += a[0];
                            px = py = null;
                            return doc.lineTo(cx, cy);
                        },
                        V: function (doc, a) {
                            cy = a[0];
                            px = py = null;
                            return doc.lineTo(cx, cy);
                        },
                        v: function (doc, a) {
                            cy += a[0];
                            px = py = null;
                            return doc.lineTo(cx, cy);
                        },
                        Z: function (doc) {
                            doc.closePath();
                            cx = sx;
                            return cy = sy;
                        },
                        z: function (doc) {
                            doc.closePath();
                            cx = sx;
                            return cy = sy;
                        }
                    };
                    solveArc = function (doc, x, y, coords) {
                        var bez, ex, ey, large, rot, rx, ry, seg, segs, sweep, _i, _len, _results;
                        rx = coords[0], ry = coords[1], rot = coords[2], large = coords[3], sweep = coords[4], ex = coords[5], ey = coords[6];
                        segs = arcToSegments(ex, ey, rx, ry, large, sweep, rot, x, y);
                        _results = [];
                        for (_i = 0, _len = segs.length; _i < _len; _i++) {
                            seg = segs[_i];
                            bez = segmentToBezier.apply(null, seg);
                            _results.push(doc.bezierCurveTo.apply(doc, bez));
                        }
                        return _results;
                    };
                    arcToSegments = function (x, y, rx, ry, large, sweep, rotateX, ox, oy) {
                        var a00, a01, a10, a11, cos_th, d, i, pl, result, segments, sfactor, sfactor_sq, sin_th, th, th0, th1, th2, th3, th_arc, x0, x1, xc, y0, y1, yc, _i;
                        th = rotateX * (Math.PI / 180);
                        sin_th = Math.sin(th);
                        cos_th = Math.cos(th);
                        rx = Math.abs(rx);
                        ry = Math.abs(ry);
                        px = cos_th * (ox - x) * 0.5 + sin_th * (oy - y) * 0.5;
                        py = cos_th * (oy - y) * 0.5 - sin_th * (ox - x) * 0.5;
                        pl = (px * px) / (rx * rx) + (py * py) / (ry * ry);
                        if (pl > 1) {
                            pl = Math.sqrt(pl);
                            rx *= pl;
                            ry *= pl;
                        }
                        a00 = cos_th / rx;
                        a01 = sin_th / rx;
                        a10 = (-sin_th) / ry;
                        a11 = cos_th / ry;
                        x0 = a00 * ox + a01 * oy;
                        y0 = a10 * ox + a11 * oy;
                        x1 = a00 * x + a01 * y;
                        y1 = a10 * x + a11 * y;
                        d = (x1 - x0) * (x1 - x0) + (y1 - y0) * (y1 - y0);
                        sfactor_sq = 1 / d - 0.25;
                        if (sfactor_sq < 0) {
                            sfactor_sq = 0;
                        }
                        sfactor = Math.sqrt(sfactor_sq);
                        if (sweep === large) {
                            sfactor = -sfactor;
                        }
                        xc = 0.5 * (x0 + x1) - sfactor * (y1 - y0);
                        yc = 0.5 * (y0 + y1) + sfactor * (x1 - x0);
                        th0 = Math.atan2(y0 - yc, x0 - xc);
                        th1 = Math.atan2(y1 - yc, x1 - xc);
                        th_arc = th1 - th0;
                        if (th_arc < 0 && sweep === 1) {
                            th_arc += 2 * Math.PI;
                        }
                        else if (th_arc > 0 && sweep === 0) {
                            th_arc -= 2 * Math.PI;
                        }
                        segments = Math.ceil(Math.abs(th_arc / (Math.PI * 0.5 + 0.001)));
                        result = [];
                        for (i = _i = 0; 0 <= segments ? _i < segments : _i > segments; i = 0 <= segments ? ++_i : --_i) {
                            th2 = th0 + i * th_arc / segments;
                            th3 = th0 + (i + 1) * th_arc / segments;
                            result[i] = [xc, yc, th2, th3, rx, ry, sin_th, cos_th];
                        }
                        return result;
                    };
                    segmentToBezier = function (cx, cy, th0, th1, rx, ry, sin_th, cos_th) {
                        var a00, a01, a10, a11, t, th_half, x1, x2, x3, y1, y2, y3;
                        a00 = cos_th * rx;
                        a01 = -sin_th * ry;
                        a10 = sin_th * rx;
                        a11 = cos_th * ry;
                        th_half = 0.5 * (th1 - th0);
                        t = (8 / 3) * Math.sin(th_half * 0.5) * Math.sin(th_half * 0.5) / Math.sin(th_half);
                        x1 = fixRoundingError(cx + Math.cos(th0) - t * Math.sin(th0));
                        y1 = fixRoundingError(cy + Math.sin(th0) + t * Math.cos(th0));
                        x3 = fixRoundingError(cx + Math.cos(th1));
                        y3 = fixRoundingError(cy + Math.sin(th1));
                        x2 = fixRoundingError(x3 + t * Math.sin(th1));
                        y2 = fixRoundingError(y3 - t * Math.cos(th1));
                        return [a00 * x1 + a01 * y1, a10 * x1 + a11 * y1, a00 * x2 + a01 * y2, a10 * x2 + a11 * y2, a00 * x3 + a01 * y3, a10 * x3 + a11 * y3];
                    };
                    fixRoundingError = function (x) {
                        if (Math.abs(Math.round(x) - x) < 0.0000000000001) {
                            return Math.round(x);
                        }
                        return x;
                    };
                    return SVGPath;
                })();
                localModule.localExports = SVGPath;
            }, {}], 21: [function (localRequire, localModule, localExports) {
                (function (Buffer) {
                    var PDFObject, PDFReference, stream, zlib, __bind = function (fn, me) { return function () { return fn.apply(me, arguments); }; }, __hasProp = {}.hasOwnProperty, __extends = function (child, parent) { for (var key in parent) {
                        if (__hasProp.call(parent, key))
                            child[key] = parent[key];
                    } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };
                    zlib = localRequire('zlib');
                    stream = localRequire('stream');
                    PDFReference = (function (_super) {
                        __extends(PDFReference, _super);
                        function PDFReference(document, id, data) {
                            this.document = document;
                            this.id = id;
                            this.data = data != null ? data : {};
                            this.finalize = __bind(this.finalize, this);
                            PDFReference.__super__.constructor.call(this, {
                                decodeStrings: false
                            });
                            this.gen = 0;
                            this.deflate = null;
                            this.compress = this.document.compress && !this.data.Filter;
                            this.uncompressedLength = 0;
                            this.chunks = [];
                        }
                        PDFReference.prototype.initDeflate = function () {
                            this.data.Filter = 'FlateDecode';
                            this.deflate = zlib.createDeflate();
                            this.deflate.on('data', (function (_this) {
                                return function (chunk) {
                                    _this.chunks.push(chunk);
                                    return _this.data.Length += chunk.length;
                                };
                            })(this));
                            return this.deflate.on('end', this.finalize);
                        };
                        PDFReference.prototype._write = function (chunk, encoding, callback) {
                            var _base;
                            if (!Buffer.isBuffer(chunk)) {
                                chunk = new Buffer(chunk + '\n', 'binary');
                            }
                            this.uncompressedLength += chunk.length;
                            if ((_base = this.data).Length == null) {
                                _base.Length = 0;
                            }
                            if (this.compress) {
                                if (!this.deflate) {
                                    this.initDeflate();
                                }
                                this.deflate.write(chunk);
                            }
                            else {
                                this.chunks.push(chunk);
                                this.data.Length += chunk.length;
                            }
                            return callback();
                        };
                        PDFReference.prototype.end = function (chunk) {
                            PDFReference.__super__.end.apply(this, arguments);
                            if (this.deflate) {
                                return this.deflate.end();
                            }
                            else {
                                return this.finalize();
                            }
                        };
                        PDFReference.prototype.finalize = function () {
                            var chunk, _i, _len, _ref;
                            this.offset = this.document._offset;
                            this.document._write("" + this.id + " " + this.gen + " obj");
                            this.document._write(PDFObject.convert(this.data));
                            if (this.chunks.length) {
                                this.document._write('stream');
                                _ref = this.chunks;
                                for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                                    chunk = _ref[_i];
                                    this.document._write(chunk);
                                }
                                this.chunks.length = 0;
                                this.document._write('\nendstream');
                            }
                            this.document._write('endobj');
                            return this.document._refEnd(this);
                        };
                        PDFReference.prototype.toString = function () {
                            return "" + this.id + " " + this.gen + " R";
                        };
                        return PDFReference;
                    })(stream.Writable);
                    localModule.localExports = PDFReference;
                    PDFObject = localRequire('./object');
                }).call(this, localRequire("buffer").Buffer);
            }, { "./object": 18, "buffer": 60, "stream": 216, "zlib": 58 }], 22: [function (localRequire, localModule, localExports) {
                var util = localRequire('util/');
                var pSlice = Array.prototype.slice;
                var hasOwn = Object.prototype.hasOwnProperty;
                var assert = localModule.localExports = ok;
                assert.AssertionError = function AssertionError(options) {
                    this.name = 'AssertionError';
                    this.actual = options.actual;
                    this.expected = options.expected;
                    this.operator = options.operator;
                    if (options.message) {
                        this.message = options.message;
                        this.generatedMessage = false;
                    }
                    else {
                        this.message = getMessage(this);
                        this.generatedMessage = true;
                    }
                    var stackStartFunction = options.stackStartFunction || fail;
                    if (Error.captureStackTrace) {
                        Error.captureStackTrace(this, stackStartFunction);
                    }
                    else {
                        var err = new Error();
                        if (err.stack) {
                            var out = err.stack;
                            var fn_name = stackStartFunction.name;
                            var idx = out.indexOf('\n' + fn_name);
                            if (idx >= 0) {
                                var next_line = out.indexOf('\n', idx + 1);
                                out = out.substring(next_line + 1);
                            }
                            this.stack = out;
                        }
                    }
                };
                util.inherits(assert.AssertionError, Error);
                function replacer(key, value) {
                    if (util.isUndefined(value)) {
                        return '' + value;
                    }
                    if (util.isNumber(value) && !isFinite(value)) {
                        return value.toString();
                    }
                    if (util.isFunction(value) || util.isRegExp(value)) {
                        return value.toString();
                    }
                    return value;
                }
                function truncate(s, n) {
                    if (util.isString(s)) {
                        return s.length < n ? s : s.slice(0, n);
                    }
                    else {
                        return s;
                    }
                }
                function getMessage(self) {
                    return truncate(JSON.stringify(self.actual, replacer), 128) + ' ' +
                        self.operator + ' ' +
                        truncate(JSON.stringify(self.expected, replacer), 128);
                }
                function fail(actual, expected, message, operator, stackStartFunction) {
                    throw new assert.AssertionError({
                        message: message,
                        actual: actual,
                        expected: expected,
                        operator: operator,
                        stackStartFunction: stackStartFunction
                    });
                }
                assert.fail = fail;
                function ok(value, message) {
                    if (!value)
                        fail(value, true, message, '==', assert.ok);
                }
                assert.ok = ok;
                assert.equal = function equal(actual, expected, message) {
                    if (actual != expected)
                        fail(actual, expected, message, '==', assert.equal);
                };
                assert.notEqual = function notEqual(actual, expected, message) {
                    if (actual == expected) {
                        fail(actual, expected, message, '!=', assert.notEqual);
                    }
                };
                assert.deepEqual = function deepEqual(actual, expected, message) {
                    if (!_deepEqual(actual, expected)) {
                        fail(actual, expected, message, 'deepEqual', assert.deepEqual);
                    }
                };
                function _deepEqual(actual, expected) {
                    if (actual === expected) {
                        return true;
                    }
                    else if (util.isBuffer(actual) && util.isBuffer(expected)) {
                        if (actual.length != expected.length)
                            return false;
                        for (var i = 0; i < actual.length; i++) {
                            if (actual[i] !== expected[i])
                                return false;
                        }
                        return true;
                    }
                    else if (util.isDate(actual) && util.isDate(expected)) {
                        return actual.getTime() === expected.getTime();
                    }
                    else if (util.isRegExp(actual) && util.isRegExp(expected)) {
                        return actual.source === expected.source &&
                            actual.global === expected.global &&
                            actual.multiline === expected.multiline &&
                            actual.lastIndex === expected.lastIndex &&
                            actual.ignoreCase === expected.ignoreCase;
                    }
                    else if (!util.isObject(actual) && !util.isObject(expected)) {
                        return actual == expected;
                    }
                    else {
                        return objEquiv(actual, expected);
                    }
                }
                function isArguments(object) {
                    return Object.prototype.toString.call(object) == '[object Arguments]';
                }
                function objEquiv(a, b) {
                    if (util.isNullOrUndefined(a) || util.isNullOrUndefined(b))
                        return false;
                    if (a.prototype !== b.prototype)
                        return false;
                    if (util.isPrimitive(a) || util.isPrimitive(b)) {
                        return a === b;
                    }
                    var aIsArgs = isArguments(a), bIsArgs = isArguments(b);
                    if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs))
                        return false;
                    if (aIsArgs) {
                        a = pSlice.call(a);
                        b = pSlice.call(b);
                        return _deepEqual(a, b);
                    }
                    var ka = objectKeys(a), kb = objectKeys(b), key, i;
                    if (ka.length != kb.length)
                        return false;
                    ka.sort();
                    kb.sort();
                    for (i = ka.length - 1; i >= 0; i--) {
                        if (ka[i] != kb[i])
                            return false;
                    }
                    for (i = ka.length - 1; i >= 0; i--) {
                        key = ka[i];
                        if (!_deepEqual(a[key], b[key]))
                            return false;
                    }
                    return true;
                }
                assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
                    if (_deepEqual(actual, expected)) {
                        fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
                    }
                };
                assert.strictEqual = function strictEqual(actual, expected, message) {
                    if (actual !== expected) {
                        fail(actual, expected, message, '===', assert.strictEqual);
                    }
                };
                assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
                    if (actual === expected) {
                        fail(actual, expected, message, '!==', assert.notStrictEqual);
                    }
                };
                function expectedException(actual, expected) {
                    if (!actual || !expected) {
                        return false;
                    }
                    if (Object.prototype.toString.call(expected) == '[object RegExp]') {
                        return expected.test(actual);
                    }
                    else if (actual instanceof expected) {
                        return true;
                    }
                    else if (expected.call({}, actual) === true) {
                        return true;
                    }
                    return false;
                }
                function _throws(shouldThrow, block, expected, message) {
                    var actual;
                    if (util.isString(expected)) {
                        message = expected;
                        expected = null;
                    }
                    try {
                        block();
                    }
                    catch (e) {
                        actual = e;
                    }
                    message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +
                        (message ? ' ' + message : '.');
                    if (shouldThrow && !actual) {
                        fail(actual, expected, 'Missing expected exception' + message);
                    }
                    if (!shouldThrow && expectedException(actual, expected)) {
                        fail(actual, expected, 'Got unwanted exception' + message);
                    }
                    if ((shouldThrow && actual && expected &&
                        !expectedException(actual, expected)) || (!shouldThrow && actual)) {
                        throw actual;
                    }
                }
                assert.throws = function (block, error, message) {
                    _throws.apply(this, [true].concat(pSlice.call(arguments)));
                };
                assert.doesNotThrow = function (block, message) {
                    _throws.apply(this, [false].concat(pSlice.call(arguments)));
                };
                assert.ifError = function (err) { if (err) {
                    throw err;
                } };
                var objectKeys = Object.keys || function (obj) {
                    var keys = [];
                    for (var key in obj) {
                        if (hasOwn.call(obj, key))
                            keys.push(key);
                    }
                    return keys;
                };
            }, { "util/": 224 }], 23: [function (localRequire, localModule, localExports) {
                localModule.localExports = { "default": localRequire("core-js/library/fn/array/from"), __esModule: true };
            }, { "core-js/library/fn/array/from": 62 }], 24: [function (localRequire, localModule, localExports) {
                localModule.localExports = { "default": localRequire("core-js/library/fn/get-iterator"), __esModule: true };
            }, { "core-js/library/fn/get-iterator": 63 }], 25: [function (localRequire, localModule, localExports) {
                localModule.localExports = { "default": localRequire("core-js/library/fn/is-iterable"), __esModule: true };
            }, { "core-js/library/fn/is-iterable": 64 }], 26: [function (localRequire, localModule, localExports) {
                localModule.localExports = { "default": localRequire("core-js/library/fn/object/assign"), __esModule: true };
            }, { "core-js/library/fn/object/assign": 65 }], 27: [function (localRequire, localModule, localExports) {
                localModule.localExports = { "default": localRequire("core-js/library/fn/object/create"), __esModule: true };
            }, { "core-js/library/fn/object/create": 66 }], 28: [function (localRequire, localModule, localExports) {
                localModule.localExports = { "default": localRequire("core-js/library/fn/object/define-properties"), __esModule: true };
            }, { "core-js/library/fn/object/define-properties": 67 }], 29: [function (localRequire, localModule, localExports) {
                localModule.localExports = { "default": localRequire("core-js/library/fn/object/define-property"), __esModule: true };
            }, { "core-js/library/fn/object/define-property": 68 }], 30: [function (localRequire, localModule, localExports) {
                localModule.localExports = { "default": localRequire("core-js/library/fn/object/freeze"), __esModule: true };
            }, { "core-js/library/fn/object/freeze": 69 }], 31: [function (localRequire, localModule, localExports) {
                localModule.localExports = { "default": localRequire("core-js/library/fn/object/get-own-property-descriptor"), __esModule: true };
            }, { "core-js/library/fn/object/get-own-property-descriptor": 70 }], 32: [function (localRequire, localModule, localExports) {
                localModule.localExports = { "default": localRequire("core-js/library/fn/object/get-prototype-of"), __esModule: true };
            }, { "core-js/library/fn/object/get-prototype-of": 71 }], 33: [function (localRequire, localModule, localExports) {
                localModule.localExports = { "default": localRequire("core-js/library/fn/object/keys"), __esModule: true };
            }, { "core-js/library/fn/object/keys": 72 }], 34: [function (localRequire, localModule, localExports) {
                localModule.localExports = { "default": localRequire("core-js/library/fn/object/set-prototype-of"), __esModule: true };
            }, { "core-js/library/fn/object/set-prototype-of": 73 }], 35: [function (localRequire, localModule, localExports) {
                localModule.localExports = { "default": localRequire("core-js/library/fn/symbol"), __esModule: true };
            }, { "core-js/library/fn/symbol": 74 }], 36: [function (localRequire, localModule, localExports) {
                localModule.localExports = { "default": localRequire("core-js/library/fn/symbol/iterator"), __esModule: true };
            }, { "core-js/library/fn/symbol/iterator": 75 }], 37: [function (localRequire, localModule, localExports) {
                "use strict";
                localExports.__esModule = true;
                localExports.default = function (instance, Constructor) {
                    if (!(instance instanceof Constructor)) {
                        throw new TypeError("Cannot call a class as a function");
                    }
                };
            }, {}], 38: [function (localRequire, localModule, localExports) {
                "use strict";
                localExports.__esModule = true;
                var _defineProperty = localRequire("../core-js/object/define-property");
                var _defineProperty2 = _interopRequireDefault(_defineProperty);
                function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
                localExports.default = function () {
                    function defineProperties(target, props) {
                        for (var i = 0; i < props.length; i++) {
                            var descriptor = props[i];
                            descriptor.enumerable = descriptor.enumerable || false;
                            descriptor.configurable = true;
                            if ("value" in descriptor)
                                descriptor.writable = true;
                            (_defineProperty2.default)(target, descriptor.key, descriptor);
                        }
                    }
                    return function (Constructor, protoProps, staticProps) {
                        if (protoProps)
                            defineProperties(Constructor.prototype, protoProps);
                        if (staticProps)
                            defineProperties(Constructor, staticProps);
                        return Constructor;
                    };
                }();
            }, { "../core-js/object/define-property": 29 }], 39: [function (localRequire, localModule, localExports) {
                "use strict";
                localExports.__esModule = true;
                var _getPrototypeOf = localRequire("../core-js/object/get-prototype-of");
                var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
                var _getOwnPropertyDescriptor = localRequire("../core-js/object/get-own-property-descriptor");
                var _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);
                function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
                localExports.default = function get(object, property, receiver) {
                    if (object === null)
                        object = Function.prototype;
                    var desc = (_getOwnPropertyDescriptor2.default)(object, property);
                    if (desc === undefined) {
                        var parent = (_getPrototypeOf2.default)(object);
                        if (parent === null) {
                            return undefined;
                        }
                        else {
                            return get(parent, property, receiver);
                        }
                    }
                    else if ("value" in desc) {
                        return desc.value;
                    }
                    else {
                        var getter = desc.get;
                        if (getter === undefined) {
                            return undefined;
                        }
                        return getter.call(receiver);
                    }
                };
            }, { "../core-js/object/get-own-property-descriptor": 31, "../core-js/object/get-prototype-of": 32 }], 40: [function (localRequire, localModule, localExports) {
                "use strict";
                localExports.__esModule = true;
                var _setPrototypeOf = localRequire("../core-js/object/set-prototype-of");
                var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);
                var _create = localRequire("../core-js/object/create");
                var _create2 = _interopRequireDefault(_create);
                var _typeof2 = localRequire("../helpers/typeof");
                var _typeof3 = _interopRequireDefault(_typeof2);
                function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
                localExports.default = function (subClass, superClass) {
                    if (typeof superClass !== "function" && superClass !== null) {
                        throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : (_typeof3.default)(superClass)));
                    }
                    subClass.prototype = (_create2.default)(superClass && superClass.prototype, {
                        constructor: {
                            value: subClass,
                            enumerable: false,
                            writable: true,
                            configurable: true
                        }
                    });
                    if (superClass)
                        _setPrototypeOf2.default ? (_setPrototypeOf2.default)(subClass, superClass) : subClass.__proto__ = superClass;
                };
            }, { "../core-js/object/create": 27, "../core-js/object/set-prototype-of": 34, "../helpers/typeof": 44 }], 41: [function (localRequire, localModule, localExports) {
                "use strict";
                localExports.__esModule = true;
                var _typeof2 = localRequire("../helpers/typeof");
                var _typeof3 = _interopRequireDefault(_typeof2);
                function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
                localExports.default = function (self, call) {
                    if (!self) {
                        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    }
                    return call && ((typeof call === "undefined" ? "undefined" : (_typeof3.default)(call)) === "object" || typeof call === "function") ? call : self;
                };
            }, { "../helpers/typeof": 44 }], 42: [function (localRequire, localModule, localExports) {
                "use strict";
                localExports.__esModule = true;
                var _isIterable2 = localRequire("../core-js/is-iterable");
                var _isIterable3 = _interopRequireDefault(_isIterable2);
                var _getIterator2 = localRequire("../core-js/get-iterator");
                var _getIterator3 = _interopRequireDefault(_getIterator2);
                function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
                localExports.default = function () {
                    function sliceIterator(arr, i) {
                        var _arr = [];
                        var _n = true;
                        var _d = false;
                        var _e = undefined;
                        try {
                            for (var _i = (_getIterator3.default)(arr), _s; !(_n = (_s = _i.next()).done); _n = true) {
                                _arr.push(_s.value);
                                if (i && _arr.length === i)
                                    break;
                            }
                        }
                        catch (err) {
                            _d = true;
                            _e = err;
                        }
                        finally {
                            try {
                                if (!_n && _i["return"])
                                    _i["return"]();
                            }
                            finally {
                                if (_d)
                                    throw _e;
                            }
                        }
                        return _arr;
                    }
                    return function (arr, i) {
                        if (Array.isArray(arr)) {
                            return arr;
                        }
                        else if ((_isIterable3.default)(Object(arr))) {
                            return sliceIterator(arr, i);
                        }
                        else {
                            throw new TypeError("Invalid attempt to destructure non-iterable instance");
                        }
                    };
                }();
            }, { "../core-js/get-iterator": 24, "../core-js/is-iterable": 25 }], 43: [function (localRequire, localModule, localExports) {
                "use strict";
                localExports.__esModule = true;
                var _from = localRequire("../core-js/array/from");
                var _from2 = _interopRequireDefault(_from);
                function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
                localExports.default = function (arr) {
                    if (Array.isArray(arr)) {
                        for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
                            arr2[i] = arr[i];
                        }
                        return arr2;
                    }
                    else {
                        return (_from2.default)(arr);
                    }
                };
            }, { "../core-js/array/from": 23 }], 44: [function (localRequire, localModule, localExports) {
                "use strict";
                localExports.__esModule = true;
                var _iterator = localRequire("../core-js/symbol/iterator");
                var _iterator2 = _interopRequireDefault(_iterator);
                var _symbol = localRequire("../core-js/symbol");
                var _symbol2 = _interopRequireDefault(_symbol);
                var _typeof = typeof _symbol2.default === "function" && typeof _iterator2.default === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default ? "symbol" : typeof obj; };
                function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
                localExports.default = typeof _symbol2.default === "function" && _typeof(_iterator2.default) === "symbol" ? function (obj) {
                    return typeof obj === "undefined" ? "undefined" : _typeof(obj);
                } : function (obj) {
                    return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof(obj);
                };
            }, { "../core-js/symbol": 35, "../core-js/symbol/iterator": 36 }], 45: [function (localRequire, localModule, localExports) {
                'use strict';
                localExports.toByteArray = toByteArray;
                localExports.fromByteArray = fromByteArray;
                var lookup = [];
                var revLookup = [];
                var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
                function init() {
                    var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
                    for (var i = 0, len = code.length; i < len; ++i) {
                        lookup[i] = code[i];
                        revLookup[code.charCodeAt(i)] = i;
                    }
                    revLookup['-'.charCodeAt(0)] = 62;
                    revLookup['_'.charCodeAt(0)] = 63;
                }
                init();
                function toByteArray(b64) {
                    var i, j, l, tmp, placeHolders, arr;
                    var len = b64.length;
                    if (len % 4 > 0) {
                        throw new Error('Invalid string. Length must be a multiple of 4');
                    }
                    placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0;
                    arr = new Arr(len * 3 / 4 - placeHolders);
                    l = placeHolders > 0 ? len - 4 : len;
                    var L = 0;
                    for (i = 0, j = 0; i < l; i += 4, j += 3) {
                        tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)];
                        arr[L++] = (tmp >> 16) & 0xFF;
                        arr[L++] = (tmp >> 8) & 0xFF;
                        arr[L++] = tmp & 0xFF;
                    }
                    if (placeHolders === 2) {
                        tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4);
                        arr[L++] = tmp & 0xFF;
                    }
                    else if (placeHolders === 1) {
                        tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2);
                        arr[L++] = (tmp >> 8) & 0xFF;
                        arr[L++] = tmp & 0xFF;
                    }
                    return arr;
                }
                function tripletToBase64(num) {
                    return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
                }
                function encodeChunk(uint8, start, end) {
                    var tmp;
                    var output = [];
                    for (var i = start; i < end; i += 3) {
                        tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);
                        output.push(tripletToBase64(tmp));
                    }
                    return output.join('');
                }
                function fromByteArray(uint8) {
                    var tmp;
                    var len = uint8.length;
                    var extraBytes = len % 3;
                    var output = '';
                    var parts = [];
                    var maxChunkLength = 16383;
                    for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
                        parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)));
                    }
                    if (extraBytes === 1) {
                        tmp = uint8[len - 1];
                        output += lookup[tmp >> 2];
                        output += lookup[(tmp << 4) & 0x3F];
                        output += '==';
                    }
                    else if (extraBytes === 2) {
                        tmp = (uint8[len - 2] << 8) + (uint8[len - 1]);
                        output += lookup[tmp >> 10];
                        output += lookup[(tmp >> 4) & 0x3F];
                        output += lookup[(tmp << 2) & 0x3F];
                        output += '=';
                    }
                    parts.push(output);
                    return parts.join('');
                }
            }, {}],
        56: [function (localRequire, localModule, localExports) {
            }, {}], 57: [function (localRequire, localModule, localExports) {
                (function (process, Buffer) {
                    var msg = localRequire('pako/lib/zlib/messages');
                    var zstream = localRequire('pako/lib/zlib/zstream');
                    var zlib_deflate = localRequire('pako/lib/zlib/deflate.js');
                    var zlib_inflate = localRequire('pako/lib/zlib/inflate.js');
                    var constants = localRequire('pako/lib/zlib/constants');
                    for (var key in constants) {
                        localExports[key] = constants[key];
                    }
                    localExports.NONE = 0;
                    localExports.DEFLATE = 1;
                    localExports.INFLATE = 2;
                    localExports.GZIP = 3;
                    localExports.GUNZIP = 4;
                    localExports.DEFLATERAW = 5;
                    localExports.INFLATERAW = 6;
                    localExports.UNZIP = 7;
                    function Zlib(mode) {
                        if (mode < localExports.DEFLATE || mode > localExports.UNZIP)
                            throw new TypeError("Bad argument");
                        this.mode = mode;
                        this.init_done = false;
                        this.write_in_progress = false;
                        this.pending_close = false;
                        this.windowBits = 0;
                        this.level = 0;
                        this.memLevel = 0;
                        this.strategy = 0;
                        this.dictionary = null;
                    }
                    Zlib.prototype.init = function (windowBits, level, memLevel, strategy, dictionary) {
                        this.windowBits = windowBits;
                        this.level = level;
                        this.memLevel = memLevel;
                        this.strategy = strategy;
                        if (this.mode === localExports.GZIP || this.mode === localExports.GUNZIP)
                            this.windowBits += 16;
                        if (this.mode === localExports.UNZIP)
                            this.windowBits += 32;
                        if (this.mode === localExports.DEFLATERAW || this.mode === localExports.INFLATERAW)
                            this.windowBits = -this.windowBits;
                        this.strm = new zstream();
                        switch (this.mode) {
                            case localExports.DEFLATE:
                            case localExports.GZIP:
                            case localExports.DEFLATERAW:
                                var status = zlib_deflate.deflateInit2(this.strm, this.level, localExports.Z_DEFLATED, this.windowBits, this.memLevel, this.strategy);
                                break;
                            case localExports.INFLATE:
                            case localExports.GUNZIP:
                            case localExports.INFLATERAW:
                            case localExports.UNZIP:
                                var status = zlib_inflate.inflateInit2(this.strm, this.windowBits);
                                break;
                            default:
                                throw new Error("Unknown mode " + this.mode);
                        }
                        if (status !== localExports.Z_OK) {
                            this._error(status);
                            return;
                        }
                        this.write_in_progress = false;
                        this.init_done = true;
                    };
                    Zlib.prototype.params = function () {
                        throw new Error("deflateParams Not supported");
                    };
                    Zlib.prototype._writeCheck = function () {
                        if (!this.init_done)
                            throw new Error("write before init");
                        if (this.mode === localExports.NONE)
                            throw new Error("already finalized");
                        if (this.write_in_progress)
                            throw new Error("write already in progress");
                        if (this.pending_close)
                            throw new Error("close is pending");
                    };
                    Zlib.prototype.write = function (flush, input, in_off, in_len, out, out_off, out_len) {
                        this._writeCheck();
                        this.write_in_progress = true;
                        var self = this;
                        process.nextTick(function () {
                            self.write_in_progress = false;
                            var res = self._write(flush, input, in_off, in_len, out, out_off, out_len);
                            self.callback(res[0], res[1]);
                            if (self.pending_close)
                                self.close();
                        });
                        return this;
                    };
                    function bufferSet(data, offset) {
                        for (var i = 0; i < data.length; i++) {
                            this[offset + i] = data[i];
                        }
                    }
                    Zlib.prototype.writeSync = function (flush, input, in_off, in_len, out, out_off, out_len) {
                        this._writeCheck();
                        return this._write(flush, input, in_off, in_len, out, out_off, out_len);
                    };
                    Zlib.prototype._write = function (flush, input, in_off, in_len, out, out_off, out_len) {
                        this.write_in_progress = true;
                        if (flush !== localExports.Z_NO_FLUSH &&
                            flush !== localExports.Z_PARTIAL_FLUSH &&
                            flush !== localExports.Z_SYNC_FLUSH &&
                            flush !== localExports.Z_FULL_FLUSH &&
                            flush !== localExports.Z_FINISH &&
                            flush !== localExports.Z_BLOCK) {
                            throw new Error("Invalid flush value");
                        }
                        if (input == null) {
                            input = new Buffer(0);
                            in_len = 0;
                            in_off = 0;
                        }
                        if (out._set)
                            out.set = out._set;
                        else
                            out.set = bufferSet;
                        var strm = this.strm;
                        strm.avail_in = in_len;
                        strm.input = input;
                        strm.next_in = in_off;
                        strm.avail_out = out_len;
                        strm.output = out;
                        strm.next_out = out_off;
                        switch (this.mode) {
                            case localExports.DEFLATE:
                            case localExports.GZIP:
                            case localExports.DEFLATERAW:
                                var status = zlib_deflate.deflate(strm, flush);
                                break;
                            case localExports.UNZIP:
                            case localExports.INFLATE:
                            case localExports.GUNZIP:
                            case localExports.INFLATERAW:
                                var status = zlib_inflate.inflate(strm, flush);
                                break;
                            default:
                                throw new Error("Unknown mode " + this.mode);
                        }
                        if (status !== localExports.Z_STREAM_END && status !== localExports.Z_OK) {
                            this._error(status);
                        }
                        this.write_in_progress = false;
                        return [strm.avail_in, strm.avail_out];
                    };
                    Zlib.prototype.close = function () {
                        if (this.write_in_progress) {
                            this.pending_close = true;
                            return;
                        }
                        this.pending_close = false;
                        if (this.mode === localExports.DEFLATE || this.mode === localExports.GZIP || this.mode === localExports.DEFLATERAW) {
                            zlib_deflate.deflateEnd(this.strm);
                        }
                        else {
                            zlib_inflate.inflateEnd(this.strm);
                        }
                        this.mode = localExports.NONE;
                    };
                    Zlib.prototype.reset = function () {
                        switch (this.mode) {
                            case localExports.DEFLATE:
                            case localExports.DEFLATERAW:
                                var status = zlib_deflate.deflateReset(this.strm);
                                break;
                            case localExports.INFLATE:
                            case localExports.INFLATERAW:
                                var status = zlib_inflate.inflateReset(this.strm);
                                break;
                        }
                        if (status !== localExports.Z_OK) {
                            this._error(status);
                        }
                    };
                    Zlib.prototype._error = function (status) {
                        this.onerror(msg[status] + ': ' + this.strm.msg, status);
                        this.write_in_progress = false;
                        if (this.pending_close)
                            this.close();
                    };
                    localExports.Zlib = Zlib;
                }).call(this, localRequire('_process'), localRequire("buffer").Buffer);
            }, { "_process": 188, "buffer": 60, "pako/lib/zlib/constants": 177, "pako/lib/zlib/deflate.js": 179, "pako/lib/zlib/inflate.js": 181, "pako/lib/zlib/messages": 183, "pako/lib/zlib/zstream": 185 }], 58: [function (localRequire, localModule, localExports) {
                (function (process, Buffer) {
                    var Transform = localRequire('_stream_transform');
                    var binding = localRequire('./binding');
                    var util = localRequire('util');
                    var assert = localRequire('assert').ok;
                    binding.Z_MIN_WINDOWBITS = 8;
                    binding.Z_MAX_WINDOWBITS = 15;
                    binding.Z_DEFAULT_WINDOWBITS = 15;
                    binding.Z_MIN_CHUNK = 64;
                    binding.Z_MAX_CHUNK = Infinity;
                    binding.Z_DEFAULT_CHUNK = (16 * 1024);
                    binding.Z_MIN_MEMLEVEL = 1;
                    binding.Z_MAX_MEMLEVEL = 9;
                    binding.Z_DEFAULT_MEMLEVEL = 8;
                    binding.Z_MIN_LEVEL = -1;
                    binding.Z_MAX_LEVEL = 9;
                    binding.Z_DEFAULT_LEVEL = binding.Z_DEFAULT_COMPRESSION;
                    Object.keys(binding).forEach(function (k) {
                        if (k.match(/^Z/))
                            localExports[k] = binding[k];
                    });
                    localExports.codes = {
                        Z_OK: binding.Z_OK,
                        Z_STREAM_END: binding.Z_STREAM_END,
                        Z_NEED_DICT: binding.Z_NEED_DICT,
                        Z_ERRNO: binding.Z_ERRNO,
                        Z_STREAM_ERROR: binding.Z_STREAM_ERROR,
                        Z_DATA_ERROR: binding.Z_DATA_ERROR,
                        Z_MEM_ERROR: binding.Z_MEM_ERROR,
                        Z_BUF_ERROR: binding.Z_BUF_ERROR,
                        Z_VERSION_ERROR: binding.Z_VERSION_ERROR
                    };
                    Object.keys(localExports.codes).forEach(function (k) {
                        localExports.codes[localExports.codes[k]] = k;
                    });
                    localExports.Deflate = Deflate;
                    localExports.Inflate = Inflate;
                    localExports.Gzip = Gzip;
                    localExports.Gunzip = Gunzip;
                    localExports.DeflateRaw = DeflateRaw;
                    localExports.InflateRaw = InflateRaw;
                    localExports.Unzip = Unzip;
                    localExports.createDeflate = function (o) {
                        return new Deflate(o);
                    };
                    localExports.createInflate = function (o) {
                        return new Inflate(o);
                    };
                    localExports.createDeflateRaw = function (o) {
                        return new DeflateRaw(o);
                    };
                    localExports.createInflateRaw = function (o) {
                        return new InflateRaw(o);
                    };
                    localExports.createGzip = function (o) {
                        return new Gzip(o);
                    };
                    localExports.createGunzip = function (o) {
                        return new Gunzip(o);
                    };
                    localExports.createUnzip = function (o) {
                        return new Unzip(o);
                    };
                    localExports.deflate = function (buffer, opts, callback) {
                        if (typeof opts === 'function') {
                            callback = opts;
                            opts = {};
                        }
                        return zlibBuffer(new Deflate(opts), buffer, callback);
                    };
                    localExports.deflateSync = function (buffer, opts) {
                        return zlibBufferSync(new Deflate(opts), buffer);
                    };
                    localExports.gzip = function (buffer, opts, callback) {
                        if (typeof opts === 'function') {
                            callback = opts;
                            opts = {};
                        }
                        return zlibBuffer(new Gzip(opts), buffer, callback);
                    };
                    localExports.gzipSync = function (buffer, opts) {
                        return zlibBufferSync(new Gzip(opts), buffer);
                    };
                    localExports.deflateRaw = function (buffer, opts, callback) {
                        if (typeof opts === 'function') {
                            callback = opts;
                            opts = {};
                        }
                        return zlibBuffer(new DeflateRaw(opts), buffer, callback);
                    };
                    localExports.deflateRawSync = function (buffer, opts) {
                        return zlibBufferSync(new DeflateRaw(opts), buffer);
                    };
                    localExports.unzip = function (buffer, opts, callback) {
                        if (typeof opts === 'function') {
                            callback = opts;
                            opts = {};
                        }
                        return zlibBuffer(new Unzip(opts), buffer, callback);
                    };
                    localExports.unzipSync = function (buffer, opts) {
                        return zlibBufferSync(new Unzip(opts), buffer);
                    };
                    localExports.inflate = function (buffer, opts, callback) {
                        if (typeof opts === 'function') {
                            callback = opts;
                            opts = {};
                        }
                        return zlibBuffer(new Inflate(opts), buffer, callback);
                    };
                    localExports.inflateSync = function (buffer, opts) {
                        return zlibBufferSync(new Inflate(opts), buffer);
                    };
                    localExports.gunzip = function (buffer, opts, callback) {
                        if (typeof opts === 'function') {
                            callback = opts;
                            opts = {};
                        }
                        return zlibBuffer(new Gunzip(opts), buffer, callback);
                    };
                    localExports.gunzipSync = function (buffer, opts) {
                        return zlibBufferSync(new Gunzip(opts), buffer);
                    };
                    localExports.inflateRaw = function (buffer, opts, callback) {
                        if (typeof opts === 'function') {
                            callback = opts;
                            opts = {};
                        }
                        return zlibBuffer(new InflateRaw(opts), buffer, callback);
                    };
                    localExports.inflateRawSync = function (buffer, opts) {
                        return zlibBufferSync(new InflateRaw(opts), buffer);
                    };
                    function zlibBuffer(engine, buffer, callback) {
                        var buffers = [];
                        var nread = 0;
                        engine.on('error', onError);
                        engine.on('end', onEnd);
                        engine.end(buffer);
                        flow();
                        function flow() {
                            var chunk;
                            while (null !== (chunk = engine.read())) {
                                buffers.push(chunk);
                                nread += chunk.length;
                            }
                            engine.once('readable', flow);
                        }
                        function onError(err) {
                            engine.removeListener('end', onEnd);
                            engine.removeListener('readable', flow);
                            callback(err);
                        }
                        function onEnd() {
                            var buf = Buffer.concat(buffers, nread);
                            buffers = [];
                            callback(null, buf);
                            engine.close();
                        }
                    }
                    function zlibBufferSync(engine, buffer) {
                        if (typeof buffer === 'string')
                            buffer = new Buffer(buffer);
                        if (!Buffer.isBuffer(buffer))
                            throw new TypeError('Not a string or buffer');
                        var flushFlag = binding.Z_FINISH;
                        return engine._processChunk(buffer, flushFlag);
                    }
                    function Deflate(opts) {
                        if (!(this instanceof Deflate))
                            return new Deflate(opts);
                        Zlib.call(this, opts, binding.DEFLATE);
                    }
                    function Inflate(opts) {
                        if (!(this instanceof Inflate))
                            return new Inflate(opts);
                        Zlib.call(this, opts, binding.INFLATE);
                    }
                    function Gzip(opts) {
                        if (!(this instanceof Gzip))
                            return new Gzip(opts);
                        Zlib.call(this, opts, binding.GZIP);
                    }
                    function Gunzip(opts) {
                        if (!(this instanceof Gunzip))
                            return new Gunzip(opts);
                        Zlib.call(this, opts, binding.GUNZIP);
                    }
                    function DeflateRaw(opts) {
                        if (!(this instanceof DeflateRaw))
                            return new DeflateRaw(opts);
                        Zlib.call(this, opts, binding.DEFLATERAW);
                    }
                    function InflateRaw(opts) {
                        if (!(this instanceof InflateRaw))
                            return new InflateRaw(opts);
                        Zlib.call(this, opts, binding.INFLATERAW);
                    }
                    function Unzip(opts) {
                        if (!(this instanceof Unzip))
                            return new Unzip(opts);
                        Zlib.call(this, opts, binding.UNZIP);
                    }
                    function Zlib(opts, mode) {
                        this._opts = opts = opts || {};
                        this._chunkSize = opts.chunkSize || localExports.Z_DEFAULT_CHUNK;
                        Transform.call(this, opts);
                        if (opts.flush) {
                            if (opts.flush !== binding.Z_NO_FLUSH &&
                                opts.flush !== binding.Z_PARTIAL_FLUSH &&
                                opts.flush !== binding.Z_SYNC_FLUSH &&
                                opts.flush !== binding.Z_FULL_FLUSH &&
                                opts.flush !== binding.Z_FINISH &&
                                opts.flush !== binding.Z_BLOCK) {
                                throw new Error('Invalid flush flag: ' + opts.flush);
                            }
                        }
                        this._flushFlag = opts.flush || binding.Z_NO_FLUSH;
                        if (opts.chunkSize) {
                            if (opts.chunkSize < localExports.Z_MIN_CHUNK ||
                                opts.chunkSize > localExports.Z_MAX_CHUNK) {
                                throw new Error('Invalid chunk size: ' + opts.chunkSize);
                            }
                        }
                        if (opts.windowBits) {
                            if (opts.windowBits < localExports.Z_MIN_WINDOWBITS ||
                                opts.windowBits > localExports.Z_MAX_WINDOWBITS) {
                                throw new Error('Invalid windowBits: ' + opts.windowBits);
                            }
                        }
                        if (opts.level) {
                            if (opts.level < localExports.Z_MIN_LEVEL ||
                                opts.level > localExports.Z_MAX_LEVEL) {
                                throw new Error('Invalid compression level: ' + opts.level);
                            }
                        }
                        if (opts.memLevel) {
                            if (opts.memLevel < localExports.Z_MIN_MEMLEVEL ||
                                opts.memLevel > localExports.Z_MAX_MEMLEVEL) {
                                throw new Error('Invalid memLevel: ' + opts.memLevel);
                            }
                        }
                        if (opts.strategy) {
                            if (opts.strategy != localExports.Z_FILTERED &&
                                opts.strategy != localExports.Z_HUFFMAN_ONLY &&
                                opts.strategy != localExports.Z_RLE &&
                                opts.strategy != localExports.Z_FIXED &&
                                opts.strategy != localExports.Z_DEFAULT_STRATEGY) {
                                throw new Error('Invalid strategy: ' + opts.strategy);
                            }
                        }
                        if (opts.dictionary) {
                            if (!Buffer.isBuffer(opts.dictionary)) {
                                throw new Error('Invalid dictionary: it should be a Buffer instance');
                            }
                        }
                        this._binding = new binding.Zlib(mode);
                        var self = this;
                        this._hadError = false;
                        this._binding.onerror = function (message, errno) {
                            self._binding = null;
                            self._hadError = true;
                            var error = new Error(message);
                            error.errno = errno;
                            error.code = localExports.codes[errno];
                            self.emit('error', error);
                        };
                        var level = localExports.Z_DEFAULT_COMPRESSION;
                        if (typeof opts.level === 'number')
                            level = opts.level;
                        var strategy = localExports.Z_DEFAULT_STRATEGY;
                        if (typeof opts.strategy === 'number')
                            strategy = opts.strategy;
                        this._binding.init(opts.windowBits || localExports.Z_DEFAULT_WINDOWBITS, level, opts.memLevel || localExports.Z_DEFAULT_MEMLEVEL, strategy, opts.dictionary);
                        this._buffer = new Buffer(this._chunkSize);
                        this._offset = 0;
                        this._closed = false;
                        this._level = level;
                        this._strategy = strategy;
                        this.once('end', this.close);
                    }
                    util.inherits(Zlib, Transform);
                    Zlib.prototype.params = function (level, strategy, callback) {
                        if (level < localExports.Z_MIN_LEVEL ||
                            level > localExports.Z_MAX_LEVEL) {
                            throw new RangeError('Invalid compression level: ' + level);
                        }
                        if (strategy != localExports.Z_FILTERED &&
                            strategy != localExports.Z_HUFFMAN_ONLY &&
                            strategy != localExports.Z_RLE &&
                            strategy != localExports.Z_FIXED &&
                            strategy != localExports.Z_DEFAULT_STRATEGY) {
                            throw new TypeError('Invalid strategy: ' + strategy);
                        }
                        if (this._level !== level || this._strategy !== strategy) {
                            var self = this;
                            this.flush(binding.Z_SYNC_FLUSH, function () {
                                self._binding.params(level, strategy);
                                if (!self._hadError) {
                                    self._level = level;
                                    self._strategy = strategy;
                                    if (callback)
                                        callback();
                                }
                            });
                        }
                        else {
                            process.nextTick(callback);
                        }
                    };
                    Zlib.prototype.reset = function () {
                        return this._binding.reset();
                    };
                    Zlib.prototype._flush = function (callback) {
                        this._transform(new Buffer(0), '', callback);
                    };
                    Zlib.prototype.flush = function (kind, callback) {
                        var ws = this._writableState;
                        if (typeof kind === 'function' || (kind === void 0 && !callback)) {
                            callback = kind;
                            kind = binding.Z_FULL_FLUSH;
                        }
                        if (ws.ended) {
                            if (callback)
                                process.nextTick(callback);
                        }
                        else if (ws.ending) {
                            if (callback)
                                this.once('end', callback);
                        }
                        else if (ws.needDrain) {
                            var self = this;
                            this.once('drain', function () {
                                self.flush(callback);
                            });
                        }
                        else {
                            this._flushFlag = kind;
                            this.write(new Buffer(0), '', callback);
                        }
                    };
                    Zlib.prototype.close = function (callback) {
                        if (callback)
                            process.nextTick(callback);
                        if (this._closed)
                            return;
                        this._closed = true;
                        this._binding.close();
                        var self = this;
                        process.nextTick(function () {
                            self.emit('close');
                        });
                    };
                    Zlib.prototype._transform = function (chunk, encoding, cb) {
                        var flushFlag;
                        var ws = this._writableState;
                        var ending = ws.ending || ws.ended;
                        var last = ending && (!chunk || ws.length === chunk.length);
                        if (!chunk === null && !Buffer.isBuffer(chunk))
                            return cb(new Error('invalid input'));
                        if (last)
                            flushFlag = binding.Z_FINISH;
                        else {
                            flushFlag = this._flushFlag;
                            if (chunk.length >= ws.length) {
                                this._flushFlag = this._opts.flush || binding.Z_NO_FLUSH;
                            }
                        }
                        var self = this;
                        this._processChunk(chunk, flushFlag, cb);
                    };
                    Zlib.prototype._processChunk = function (chunk, flushFlag, cb) {
                        var availInBefore = chunk && chunk.length;
                        var availOutBefore = this._chunkSize - this._offset;
                        var inOff = 0;
                        var self = this;
                        var async = typeof cb === 'function';
                        if (!async) {
                            var buffers = [];
                            var nread = 0;
                            var error;
                            this.on('error', function (er) {
                                error = er;
                            });
                            do {
                                var res = this._binding.writeSync(flushFlag, chunk, inOff, availInBefore, this._buffer, this._offset, availOutBefore);
                            } while (!this._hadError && callback(res[0], res[1]));
                            if (this._hadError) {
                                throw error;
                            }
                            var buf = Buffer.concat(buffers, nread);
                            this.close();
                            return buf;
                        }
                        var req = this._binding.write(flushFlag, chunk, inOff, availInBefore, this._buffer, this._offset, availOutBefore);
                        req.buffer = chunk;
                        req.callback = callback;
                        function callback(availInAfter, availOutAfter) {
                            if (self._hadError)
                                return;
                            var have = availOutBefore - availOutAfter;
                            assert(have >= 0, 'have should not go down');
                            if (have > 0) {
                                var out = self._buffer.slice(self._offset, self._offset + have);
                                self._offset += have;
                                if (async) {
                                    self.push(out);
                                }
                                else {
                                    buffers.push(out);
                                    nread += out.length;
                                }
                            }
                            if (availOutAfter === 0 || self._offset >= self._chunkSize) {
                                availOutBefore = self._chunkSize;
                                self._offset = 0;
                                self._buffer = new Buffer(self._chunkSize);
                            }
                            if (availOutAfter === 0) {
                                inOff += (availInBefore - availInAfter);
                                availInBefore = availInAfter;
                                if (!async)
                                    return true;
                                var newReq = self._binding.write(flushFlag, chunk, inOff, availInBefore, self._buffer, self._offset, self._chunkSize);
                                newReq.callback = callback;
                                newReq.buffer = chunk;
                                return;
                            }
                            if (!async)
                                return false;
                            cb();
                        }
                    };
                    util.inherits(Deflate, Zlib);
                    util.inherits(Inflate, Zlib);
                    util.inherits(Gzip, Zlib);
                    util.inherits(Gunzip, Zlib);
                    util.inherits(DeflateRaw, Zlib);
                    util.inherits(InflateRaw, Zlib);
                    util.inherits(Unzip, Zlib);
                }).call(this, localRequire('_process'), localRequire("buffer").Buffer);
            }, { "./binding": 57, "_process": 188, "_stream_transform": 197, "assert": 22, "buffer": 60, "util": 224 }], 59: [function (localRequire, localModule, localExports) {
                arguments[4][56][0].apply(localExports, arguments);
            }, { "dup": 56 }], 60: [function (localRequire, localModule, localExports) {
                (function (global) {
                    'use strict';
                    var base64 = localRequire('base64-js');
                    var ieee754 = localRequire('ieee754');
                    var isArray = localRequire('isarray');
                    localExports.Buffer = Buffer;
                    localExports.SlowBuffer = SlowBuffer;
                    localExports.INSPECT_MAX_BYTES = 50;
                    Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
                        ? global.TYPED_ARRAY_SUPPORT
                        : typedArraySupport();
                    localExports.kMaxLength = kMaxLength();
                    function typedArraySupport() {
                        try {
                            var arr = new Uint8Array(1);
                            arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function () { return 42; } };
                            return arr.foo() === 42 &&
                                typeof arr.subarray === 'function' &&
                                arr.subarray(1, 1).byteLength === 0;
                        }
                        catch (e) {
                            return false;
                        }
                    }
                    function kMaxLength() {
                        return Buffer.TYPED_ARRAY_SUPPORT
                            ? 0x7fffffff
                            : 0x3fffffff;
                    }
                    function createBuffer(that, length) {
                        if (kMaxLength() < length) {
                            throw new RangeError('Invalid typed array length');
                        }
                        if (Buffer.TYPED_ARRAY_SUPPORT) {
                            that = new Uint8Array(length);
                            that.__proto__ = Buffer.prototype;
                        }
                        else {
                            if (that === null) {
                                that = new Buffer(length);
                            }
                            that.length = length;
                        }
                        return that;
                    }
                    function Buffer(arg, encodingOrOffset, length) {
                        if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
                            return new Buffer(arg, encodingOrOffset, length);
                        }
                        if (typeof arg === 'number') {
                            if (typeof encodingOrOffset === 'string') {
                                throw new Error('If encoding is specified then the first argument must be a string');
                            }
                            return allocUnsafe(this, arg);
                        }
                        return from(this, arg, encodingOrOffset, length);
                    }
                    Buffer.poolSize = 8192;
                    Buffer._augment = function (arr) {
                        arr.__proto__ = Buffer.prototype;
                        return arr;
                    };
                    function from(that, value, encodingOrOffset, length) {
                        if (typeof value === 'number') {
                            throw new TypeError('"value" argument must not be a number');
                        }
                        if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
                            return fromArrayBuffer(that, value, encodingOrOffset, length);
                        }
                        if (typeof value === 'string') {
                            return fromString(that, value, encodingOrOffset);
                        }
                        return fromObject(that, value);
                    }
                    Buffer.from = function (value, encodingOrOffset, length) {
                        return from(null, value, encodingOrOffset, length);
                    };
                    if (Buffer.TYPED_ARRAY_SUPPORT) {
                        Buffer.prototype.__proto__ = Uint8Array.prototype;
                        Buffer.__proto__ = Uint8Array;
                        if (typeof Symbol !== 'undefined' && Symbol.species &&
                            Buffer[Symbol.species] === Buffer) {
                            Object.defineProperty(Buffer, Symbol.species, {
                                value: null,
                                configurable: true
                            });
                        }
                    }
                    function assertSize(size) {
                        if (typeof size !== 'number') {
                            throw new TypeError('"size" argument must be a number');
                        }
                        else if (size < 0) {
                            throw new RangeError('"size" argument must not be negative');
                        }
                    }
                    function alloc(that, size, fill, encoding) {
                        assertSize(size);
                        if (size <= 0) {
                            return createBuffer(that, size);
                        }
                        if (fill !== undefined) {
                            return typeof encoding === 'string'
                                ? createBuffer(that, size).fill(fill, encoding)
                                : createBuffer(that, size).fill(fill);
                        }
                        return createBuffer(that, size);
                    }
                    Buffer.alloc = function (size, fill, encoding) {
                        return alloc(null, size, fill, encoding);
                    };
                    function allocUnsafe(that, size) {
                        assertSize(size);
                        that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
                        if (!Buffer.TYPED_ARRAY_SUPPORT) {
                            for (var i = 0; i < size; ++i) {
                                that[i] = 0;
                            }
                        }
                        return that;
                    }
                    Buffer.allocUnsafe = function (size) {
                        return allocUnsafe(null, size);
                    };
                    Buffer.allocUnsafeSlow = function (size) {
                        return allocUnsafe(null, size);
                    };
                    function fromString(that, string, encoding) {
                        if (typeof encoding !== 'string' || encoding === '') {
                            encoding = 'utf8';
                        }
                        if (!Buffer.isEncoding(encoding)) {
                            throw new TypeError('"encoding" must be a valid string encoding');
                        }
                        var length = byteLength(string, encoding) | 0;
                        that = createBuffer(that, length);
                        var actual = that.write(string, encoding);
                        if (actual !== length) {
                            that = that.slice(0, actual);
                        }
                        return that;
                    }
                    function fromArrayLike(that, array) {
                        var length = array.length < 0 ? 0 : checked(array.length) | 0;
                        that = createBuffer(that, length);
                        for (var i = 0; i < length; i += 1) {
                            that[i] = array[i] & 255;
                        }
                        return that;
                    }
                    function fromArrayBuffer(that, array, byteOffset, length) {
                        array.byteLength;
                        if (byteOffset < 0 || array.byteLength < byteOffset) {
                            throw new RangeError('\'offset\' is out of bounds');
                        }
                        if (array.byteLength < byteOffset + (length || 0)) {
                            throw new RangeError('\'length\' is out of bounds');
                        }
                        if (byteOffset === undefined && length === undefined) {
                            array = new Uint8Array(array);
                        }
                        else if (length === undefined) {
                            array = new Uint8Array(array, byteOffset);
                        }
                        else {
                            array = new Uint8Array(array, byteOffset, length);
                        }
                        if (Buffer.TYPED_ARRAY_SUPPORT) {
                            that = array;
                            that.__proto__ = Buffer.prototype;
                        }
                        else {
                            that = fromArrayLike(that, array);
                        }
                        return that;
                    }
                    function fromObject(that, obj) {
                        if (Buffer.isBuffer(obj)) {
                            var len = checked(obj.length) | 0;
                            that = createBuffer(that, len);
                            if (that.length === 0) {
                                return that;
                            }
                            obj.copy(that, 0, 0, len);
                            return that;
                        }
                        if (obj) {
                            if ((typeof ArrayBuffer !== 'undefined' &&
                                obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
                                if (typeof obj.length !== 'number' || isnan(obj.length)) {
                                    return createBuffer(that, 0);
                                }
                                return fromArrayLike(that, obj);
                            }
                            if (obj.type === 'Buffer' && isArray(obj.data)) {
                                return fromArrayLike(that, obj.data);
                            }
                        }
                        throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.');
                    }
                    function checked(length) {
                        if (length >= kMaxLength()) {
                            throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                                'size: 0x' + kMaxLength().toString(16) + ' bytes');
                        }
                        return length | 0;
                    }
                    function SlowBuffer(length) {
                        if (+length != length) {
                            length = 0;
                        }
                        return Buffer.alloc(+length);
                    }
                    Buffer.isBuffer = function isBuffer(b) {
                        return !!(b != null && b._isBuffer);
                    };
                    Buffer.compare = function compare(a, b) {
                        if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
                            throw new TypeError('Arguments must be Buffers');
                        }
                        if (a === b)
                            return 0;
                        var x = a.length;
                        var y = b.length;
                        for (var i = 0, len = Math.min(x, y); i < len; ++i) {
                            if (a[i] !== b[i]) {
                                x = a[i];
                                y = b[i];
                                break;
                            }
                        }
                        if (x < y)
                            return -1;
                        if (y < x)
                            return 1;
                        return 0;
                    };
                    Buffer.isEncoding = function isEncoding(encoding) {
                        switch (String(encoding).toLowerCase()) {
                            case 'hex':
                            case 'utf8':
                            case 'utf-8':
                            case 'ascii':
                            case 'latin1':
                            case 'binary':
                            case 'base64':
                            case 'ucs2':
                            case 'ucs-2':
                            case 'utf16le':
                            case 'utf-16le':
                                return true;
                            default:
                                return false;
                        }
                    };
                    Buffer.concat = function concat(list, length) {
                        if (!isArray(list)) {
                            throw new TypeError('"list" argument must be an Array of Buffers');
                        }
                        if (list.length === 0) {
                            return Buffer.alloc(0);
                        }
                        var i;
                        if (length === undefined) {
                            length = 0;
                            for (i = 0; i < list.length; ++i) {
                                length += list[i].length;
                            }
                        }
                        var buffer = Buffer.allocUnsafe(length);
                        var pos = 0;
                        for (i = 0; i < list.length; ++i) {
                            var buf = list[i];
                            if (!Buffer.isBuffer(buf)) {
                                throw new TypeError('"list" argument must be an Array of Buffers');
                            }
                            buf.copy(buffer, pos);
                            pos += buf.length;
                        }
                        return buffer;
                    };
                    function byteLength(string, encoding) {
                        if (Buffer.isBuffer(string)) {
                            return string.length;
                        }
                        if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
                            (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
                            return string.byteLength;
                        }
                        if (typeof string !== 'string') {
                            string = '' + string;
                        }
                        var len = string.length;
                        if (len === 0)
                            return 0;
                        var loweredCase = false;
                        for (;;) {
                            switch (encoding) {
                                case 'ascii':
                                case 'latin1':
                                case 'binary':
                                    return len;
                                case 'utf8':
                                case 'utf-8':
                                case undefined:
                                    return utf8ToBytes(string).length;
                                case 'ucs2':
                                case 'ucs-2':
                                case 'utf16le':
                                case 'utf-16le':
                                    return len * 2;
                                case 'hex':
                                    return len >>> 1;
                                case 'base64':
                                    return base64ToBytes(string).length;
                                default:
                                    if (loweredCase)
                                        return utf8ToBytes(string).length;
                                    encoding = ('' + encoding).toLowerCase();
                                    loweredCase = true;
                            }
                        }
                    }
                    Buffer.byteLength = byteLength;
                    function slowToString(encoding, start, end) {
                        var loweredCase = false;
                        if (start === undefined || start < 0) {
                            start = 0;
                        }
                        if (start > this.length) {
                            return '';
                        }
                        if (end === undefined || end > this.length) {
                            end = this.length;
                        }
                        if (end <= 0) {
                            return '';
                        }
                        end >>>= 0;
                        start >>>= 0;
                        if (end <= start) {
                            return '';
                        }
                        if (!encoding)
                            encoding = 'utf8';
                        while (true) {
                            switch (encoding) {
                                case 'hex':
                                    return hexSlice(this, start, end);
                                case 'utf8':
                                case 'utf-8':
                                    return utf8Slice(this, start, end);
                                case 'ascii':
                                    return asciiSlice(this, start, end);
                                case 'latin1':
                                case 'binary':
                                    return latin1Slice(this, start, end);
                                case 'base64':
                                    return base64Slice(this, start, end);
                                case 'ucs2':
                                case 'ucs-2':
                                case 'utf16le':
                                case 'utf-16le':
                                    return utf16leSlice(this, start, end);
                                default:
                                    if (loweredCase)
                                        throw new TypeError('Unknown encoding: ' + encoding);
                                    encoding = (encoding + '').toLowerCase();
                                    loweredCase = true;
                            }
                        }
                    }
                    Buffer.prototype._isBuffer = true;
                    function swap(b, n, m) {
                        var i = b[n];
                        b[n] = b[m];
                        b[m] = i;
                    }
                    Buffer.prototype.swap16 = function swap16() {
                        var len = this.length;
                        if (len % 2 !== 0) {
                            throw new RangeError('Buffer size must be a multiple of 16-bits');
                        }
                        for (var i = 0; i < len; i += 2) {
                            swap(this, i, i + 1);
                        }
                        return this;
                    };
                    Buffer.prototype.swap32 = function swap32() {
                        var len = this.length;
                        if (len % 4 !== 0) {
                            throw new RangeError('Buffer size must be a multiple of 32-bits');
                        }
                        for (var i = 0; i < len; i += 4) {
                            swap(this, i, i + 3);
                            swap(this, i + 1, i + 2);
                        }
                        return this;
                    };
                    Buffer.prototype.swap64 = function swap64() {
                        var len = this.length;
                        if (len % 8 !== 0) {
                            throw new RangeError('Buffer size must be a multiple of 64-bits');
                        }
                        for (var i = 0; i < len; i += 8) {
                            swap(this, i, i + 7);
                            swap(this, i + 1, i + 6);
                            swap(this, i + 2, i + 5);
                            swap(this, i + 3, i + 4);
                        }
                        return this;
                    };
                    Buffer.prototype.toString = function toString() {
                        var length = this.length | 0;
                        if (length === 0)
                            return '';
                        if (arguments.length === 0)
                            return utf8Slice(this, 0, length);
                        return slowToString.apply(this, arguments);
                    };
                    Buffer.prototype.equals = function equals(b) {
                        if (!Buffer.isBuffer(b))
                            throw new TypeError('Argument must be a Buffer');
                        if (this === b)
                            return true;
                        return Buffer.compare(this, b) === 0;
                    };
                    Buffer.prototype.inspect = function inspect() {
                        var str = '';
                        var max = localExports.INSPECT_MAX_BYTES;
                        if (this.length > 0) {
                            str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
                            if (this.length > max)
                                str += ' ... ';
                        }
                        return '<Buffer ' + str + '>';
                    };
                    Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
                        if (!Buffer.isBuffer(target)) {
                            throw new TypeError('Argument must be a Buffer');
                        }
                        if (start === undefined) {
                            start = 0;
                        }
                        if (end === undefined) {
                            end = target ? target.length : 0;
                        }
                        if (thisStart === undefined) {
                            thisStart = 0;
                        }
                        if (thisEnd === undefined) {
                            thisEnd = this.length;
                        }
                        if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
                            throw new RangeError('out of range index');
                        }
                        if (thisStart >= thisEnd && start >= end) {
                            return 0;
                        }
                        if (thisStart >= thisEnd) {
                            return -1;
                        }
                        if (start >= end) {
                            return 1;
                        }
                        start >>>= 0;
                        end >>>= 0;
                        thisStart >>>= 0;
                        thisEnd >>>= 0;
                        if (this === target)
                            return 0;
                        var x = thisEnd - thisStart;
                        var y = end - start;
                        var len = Math.min(x, y);
                        var thisCopy = this.slice(thisStart, thisEnd);
                        var targetCopy = target.slice(start, end);
                        for (var i = 0; i < len; ++i) {
                            if (thisCopy[i] !== targetCopy[i]) {
                                x = thisCopy[i];
                                y = targetCopy[i];
                                break;
                            }
                        }
                        if (x < y)
                            return -1;
                        if (y < x)
                            return 1;
                        return 0;
                    };
                    function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
                        if (buffer.length === 0)
                            return -1;
                        if (typeof byteOffset === 'string') {
                            encoding = byteOffset;
                            byteOffset = 0;
                        }
                        else if (byteOffset > 0x7fffffff) {
                            byteOffset = 0x7fffffff;
                        }
                        else if (byteOffset < -0x80000000) {
                            byteOffset = -0x80000000;
                        }
                        byteOffset = +byteOffset;
                        if (isNaN(byteOffset)) {
                            byteOffset = dir ? 0 : (buffer.length - 1);
                        }
                        if (byteOffset < 0)
                            byteOffset = buffer.length + byteOffset;
                        if (byteOffset >= buffer.length) {
                            if (dir)
                                return -1;
                            else
                                byteOffset = buffer.length - 1;
                        }
                        else if (byteOffset < 0) {
                            if (dir)
                                byteOffset = 0;
                            else
                                return -1;
                        }
                        if (typeof val === 'string') {
                            val = Buffer.from(val, encoding);
                        }
                        if (Buffer.isBuffer(val)) {
                            if (val.length === 0) {
                                return -1;
                            }
                            return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
                        }
                        else if (typeof val === 'number') {
                            val = val & 0xFF;
                            if (Buffer.TYPED_ARRAY_SUPPORT &&
                                typeof Uint8Array.prototype.indexOf === 'function') {
                                if (dir) {
                                    return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
                                }
                                else {
                                    return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
                                }
                            }
                            return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
                        }
                        throw new TypeError('val must be string, number or Buffer');
                    }
                    function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
                        var indexSize = 1;
                        var arrLength = arr.length;
                        var valLength = val.length;
                        if (encoding !== undefined) {
                            encoding = String(encoding).toLowerCase();
                            if (encoding === 'ucs2' || encoding === 'ucs-2' ||
                                encoding === 'utf16le' || encoding === 'utf-16le') {
                                if (arr.length < 2 || val.length < 2) {
                                    return -1;
                                }
                                indexSize = 2;
                                arrLength /= 2;
                                valLength /= 2;
                                byteOffset /= 2;
                            }
                        }
                        function read(buf, i) {
                            if (indexSize === 1) {
                                return buf[i];
                            }
                            else {
                                return buf.readUInt16BE(i * indexSize);
                            }
                        }
                        var i;
                        if (dir) {
                            var foundIndex = -1;
                            for (i = byteOffset; i < arrLength; i++) {
                                if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
                                    if (foundIndex === -1)
                                        foundIndex = i;
                                    if (i - foundIndex + 1 === valLength)
                                        return foundIndex * indexSize;
                                }
                                else {
                                    if (foundIndex !== -1)
                                        i -= i - foundIndex;
                                    foundIndex = -1;
                                }
                            }
                        }
                        else {
                            if (byteOffset + valLength > arrLength)
                                byteOffset = arrLength - valLength;
                            for (i = byteOffset; i >= 0; i--) {
                                var found = true;
                                for (var j = 0; j < valLength; j++) {
                                    if (read(arr, i + j) !== read(val, j)) {
                                        found = false;
                                        break;
                                    }
                                }
                                if (found)
                                    return i;
                            }
                        }
                        return -1;
                    }
                    Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
                        return this.indexOf(val, byteOffset, encoding) !== -1;
                    };
                    Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
                        return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
                    };
                    Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
                        return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
                    };
                    function hexWrite(buf, string, offset, length) {
                        offset = Number(offset) || 0;
                        var remaining = buf.length - offset;
                        if (!length) {
                            length = remaining;
                        }
                        else {
                            length = Number(length);
                            if (length > remaining) {
                                length = remaining;
                            }
                        }
                        var strLen = string.length;
                        if (strLen % 2 !== 0)
                            throw new TypeError('Invalid hex string');
                        if (length > strLen / 2) {
                            length = strLen / 2;
                        }
                        for (var i = 0; i < length; ++i) {
                            var parsed = parseInt(string.substr(i * 2, 2), 16);
                            if (isNaN(parsed))
                                return i;
                            buf[offset + i] = parsed;
                        }
                        return i;
                    }
                    function utf8Write(buf, string, offset, length) {
                        return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
                    }
                    function asciiWrite(buf, string, offset, length) {
                        return blitBuffer(asciiToBytes(string), buf, offset, length);
                    }
                    function latin1Write(buf, string, offset, length) {
                        return asciiWrite(buf, string, offset, length);
                    }
                    function base64Write(buf, string, offset, length) {
                        return blitBuffer(base64ToBytes(string), buf, offset, length);
                    }
                    function ucs2Write(buf, string, offset, length) {
                        return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
                    }
                    Buffer.prototype.write = function write(string, offset, length, encoding) {
                        if (offset === undefined) {
                            encoding = 'utf8';
                            length = this.length;
                            offset = 0;
                        }
                        else if (length === undefined && typeof offset === 'string') {
                            encoding = offset;
                            length = this.length;
                            offset = 0;
                        }
                        else if (isFinite(offset)) {
                            offset = offset | 0;
                            if (isFinite(length)) {
                                length = length | 0;
                                if (encoding === undefined)
                                    encoding = 'utf8';
                            }
                            else {
                                encoding = length;
                                length = undefined;
                            }
                        }
                        else {
                            throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');
                        }
                        var remaining = this.length - offset;
                        if (length === undefined || length > remaining)
                            length = remaining;
                        if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
                            throw new RangeError('Attempt to write outside buffer bounds');
                        }
                        if (!encoding)
                            encoding = 'utf8';
                        var loweredCase = false;
                        for (;;) {
                            switch (encoding) {
                                case 'hex':
                                    return hexWrite(this, string, offset, length);
                                case 'utf8':
                                case 'utf-8':
                                    return utf8Write(this, string, offset, length);
                                case 'ascii':
                                    return asciiWrite(this, string, offset, length);
                                case 'latin1':
                                case 'binary':
                                    return latin1Write(this, string, offset, length);
                                case 'base64':
                                    return base64Write(this, string, offset, length);
                                case 'ucs2':
                                case 'ucs-2':
                                case 'utf16le':
                                case 'utf-16le':
                                    return ucs2Write(this, string, offset, length);
                                default:
                                    if (loweredCase)
                                        throw new TypeError('Unknown encoding: ' + encoding);
                                    encoding = ('' + encoding).toLowerCase();
                                    loweredCase = true;
                            }
                        }
                    };
                    Buffer.prototype.toJSON = function toJSON() {
                        return {
                            type: 'Buffer',
                            data: Array.prototype.slice.call(this._arr || this, 0)
                        };
                    };
                    function base64Slice(buf, start, end) {
                        if (start === 0 && end === buf.length) {
                            return base64.fromByteArray(buf);
                        }
                        else {
                            return base64.fromByteArray(buf.slice(start, end));
                        }
                    }
                    function utf8Slice(buf, start, end) {
                        end = Math.min(buf.length, end);
                        var res = [];
                        var i = start;
                        while (i < end) {
                            var firstByte = buf[i];
                            var codePoint = null;
                            var bytesPerSequence = (firstByte > 0xEF) ? 4
                                : (firstByte > 0xDF) ? 3
                                    : (firstByte > 0xBF) ? 2
                                        : 1;
                            if (i + bytesPerSequence <= end) {
                                var secondByte, thirdByte, fourthByte, tempCodePoint;
                                switch (bytesPerSequence) {
                                    case 1:
                                        if (firstByte < 0x80) {
                                            codePoint = firstByte;
                                        }
                                        break;
                                    case 2:
                                        secondByte = buf[i + 1];
                                        if ((secondByte & 0xC0) === 0x80) {
                                            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F);
                                            if (tempCodePoint > 0x7F) {
                                                codePoint = tempCodePoint;
                                            }
                                        }
                                        break;
                                    case 3:
                                        secondByte = buf[i + 1];
                                        thirdByte = buf[i + 2];
                                        if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
                                            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F);
                                            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
                                                codePoint = tempCodePoint;
                                            }
                                        }
                                        break;
                                    case 4:
                                        secondByte = buf[i + 1];
                                        thirdByte = buf[i + 2];
                                        fourthByte = buf[i + 3];
                                        if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
                                            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F);
                                            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
                                                codePoint = tempCodePoint;
                                            }
                                        }
                                }
                            }
                            if (codePoint === null) {
                                codePoint = 0xFFFD;
                                bytesPerSequence = 1;
                            }
                            else if (codePoint > 0xFFFF) {
                                codePoint -= 0x10000;
                                res.push(codePoint >>> 10 & 0x3FF | 0xD800);
                                codePoint = 0xDC00 | codePoint & 0x3FF;
                            }
                            res.push(codePoint);
                            i += bytesPerSequence;
                        }
                        return decodeCodePointsArray(res);
                    }
                    var MAX_ARGUMENTS_LENGTH = 0x1000;
                    function decodeCodePointsArray(codePoints) {
                        var len = codePoints.length;
                        if (len <= MAX_ARGUMENTS_LENGTH) {
                            return String.fromCharCode.apply(String, codePoints);
                        }
                        var res = '';
                        var i = 0;
                        while (i < len) {
                            res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
                        }
                        return res;
                    }
                    function asciiSlice(buf, start, end) {
                        var ret = '';
                        end = Math.min(buf.length, end);
                        for (var i = start; i < end; ++i) {
                            ret += String.fromCharCode(buf[i] & 0x7F);
                        }
                        return ret;
                    }
                    function latin1Slice(buf, start, end) {
                        var ret = '';
                        end = Math.min(buf.length, end);
                        for (var i = start; i < end; ++i) {
                            ret += String.fromCharCode(buf[i]);
                        }
                        return ret;
                    }
                    function hexSlice(buf, start, end) {
                        var len = buf.length;
                        if (!start || start < 0)
                            start = 0;
                        if (!end || end < 0 || end > len)
                            end = len;
                        var out = '';
                        for (var i = start; i < end; ++i) {
                            out += toHex(buf[i]);
                        }
                        return out;
                    }
                    function utf16leSlice(buf, start, end) {
                        var bytes = buf.slice(start, end);
                        var res = '';
                        for (var i = 0; i < bytes.length; i += 2) {
                            res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
                        }
                        return res;
                    }
                    Buffer.prototype.slice = function slice(start, end) {
                        var len = this.length;
                        start = ~~start;
                        end = end === undefined ? len : ~~end;
                        if (start < 0) {
                            start += len;
                            if (start < 0)
                                start = 0;
                        }
                        else if (start > len) {
                            start = len;
                        }
                        if (end < 0) {
                            end += len;
                            if (end < 0)
                                end = 0;
                        }
                        else if (end > len) {
                            end = len;
                        }
                        if (end < start)
                            end = start;
                        var newBuf;
                        if (Buffer.TYPED_ARRAY_SUPPORT) {
                            newBuf = this.subarray(start, end);
                            newBuf.__proto__ = Buffer.prototype;
                        }
                        else {
                            var sliceLen = end - start;
                            newBuf = new Buffer(sliceLen, undefined);
                            for (var i = 0; i < sliceLen; ++i) {
                                newBuf[i] = this[i + start];
                            }
                        }
                        return newBuf;
                    };
                    function checkOffset(offset, ext, length) {
                        if ((offset % 1) !== 0 || offset < 0)
                            throw new RangeError('offset is not uint');
                        if (offset + ext > length)
                            throw new RangeError('Trying to access beyond buffer length');
                    }
                    Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
                        offset = offset | 0;
                        byteLength = byteLength | 0;
                        if (!noAssert)
                            checkOffset(offset, byteLength, this.length);
                        var val = this[offset];
                        var mul = 1;
                        var i = 0;
                        while (++i < byteLength && (mul *= 0x100)) {
                            val += this[offset + i] * mul;
                        }
                        return val;
                    };
                    Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
                        offset = offset | 0;
                        byteLength = byteLength | 0;
                        if (!noAssert) {
                            checkOffset(offset, byteLength, this.length);
                        }
                        var val = this[offset + --byteLength];
                        var mul = 1;
                        while (byteLength > 0 && (mul *= 0x100)) {
                            val += this[offset + --byteLength] * mul;
                        }
                        return val;
                    };
                    Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
                        if (!noAssert)
                            checkOffset(offset, 1, this.length);
                        return this[offset];
                    };
                    Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
                        if (!noAssert)
                            checkOffset(offset, 2, this.length);
                        return this[offset] | (this[offset + 1] << 8);
                    };
                    Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
                        if (!noAssert)
                            checkOffset(offset, 2, this.length);
                        return (this[offset] << 8) | this[offset + 1];
                    };
                    Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
                        if (!noAssert)
                            checkOffset(offset, 4, this.length);
                        return ((this[offset]) |
                            (this[offset + 1] << 8) |
                            (this[offset + 2] << 16)) +
                            (this[offset + 3] * 0x1000000);
                    };
                    Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
                        if (!noAssert)
                            checkOffset(offset, 4, this.length);
                        return (this[offset] * 0x1000000) +
                            ((this[offset + 1] << 16) |
                                (this[offset + 2] << 8) |
                                this[offset + 3]);
                    };
                    Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
                        offset = offset | 0;
                        byteLength = byteLength | 0;
                        if (!noAssert)
                            checkOffset(offset, byteLength, this.length);
                        var val = this[offset];
                        var mul = 1;
                        var i = 0;
                        while (++i < byteLength && (mul *= 0x100)) {
                            val += this[offset + i] * mul;
                        }
                        mul *= 0x80;
                        if (val >= mul)
                            val -= Math.pow(2, 8 * byteLength);
                        return val;
                    };
                    Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
                        offset = offset | 0;
                        byteLength = byteLength | 0;
                        if (!noAssert)
                            checkOffset(offset, byteLength, this.length);
                        var i = byteLength;
                        var mul = 1;
                        var val = this[offset + --i];
                        while (i > 0 && (mul *= 0x100)) {
                            val += this[offset + --i] * mul;
                        }
                        mul *= 0x80;
                        if (val >= mul)
                            val -= Math.pow(2, 8 * byteLength);
                        return val;
                    };
                    Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
                        if (!noAssert)
                            checkOffset(offset, 1, this.length);
                        if (!(this[offset] & 0x80))
                            return (this[offset]);
                        return ((0xff - this[offset] + 1) * -1);
                    };
                    Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
                        if (!noAssert)
                            checkOffset(offset, 2, this.length);
                        var val = this[offset] | (this[offset + 1] << 8);
                        return (val & 0x8000) ? val | 0xFFFF0000 : val;
                    };
                    Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
                        if (!noAssert)
                            checkOffset(offset, 2, this.length);
                        var val = this[offset + 1] | (this[offset] << 8);
                        return (val & 0x8000) ? val | 0xFFFF0000 : val;
                    };
                    Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
                        if (!noAssert)
                            checkOffset(offset, 4, this.length);
                        return (this[offset]) |
                            (this[offset + 1] << 8) |
                            (this[offset + 2] << 16) |
                            (this[offset + 3] << 24);
                    };
                    Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
                        if (!noAssert)
                            checkOffset(offset, 4, this.length);
                        return (this[offset] << 24) |
                            (this[offset + 1] << 16) |
                            (this[offset + 2] << 8) |
                            (this[offset + 3]);
                    };
                    Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
                        if (!noAssert)
                            checkOffset(offset, 4, this.length);
                        return ieee754.read(this, offset, true, 23, 4);
                    };
                    Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
                        if (!noAssert)
                            checkOffset(offset, 4, this.length);
                        return ieee754.read(this, offset, false, 23, 4);
                    };
                    Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
                        if (!noAssert)
                            checkOffset(offset, 8, this.length);
                        return ieee754.read(this, offset, true, 52, 8);
                    };
                    Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
                        if (!noAssert)
                            checkOffset(offset, 8, this.length);
                        return ieee754.read(this, offset, false, 52, 8);
                    };
                    function checkInt(buf, value, offset, ext, max, min) {
                        if (!Buffer.isBuffer(buf))
                            throw new TypeError('"buffer" argument must be a Buffer instance');
                        if (value > max || value < min)
                            throw new RangeError('"value" argument is out of bounds');
                        if (offset + ext > buf.length)
                            throw new RangeError('Index out of range');
                    }
                    Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
                        value = +value;
                        offset = offset | 0;
                        byteLength = byteLength | 0;
                        if (!noAssert) {
                            var maxBytes = Math.pow(2, 8 * byteLength) - 1;
                            checkInt(this, value, offset, byteLength, maxBytes, 0);
                        }
                        var mul = 1;
                        var i = 0;
                        this[offset] = value & 0xFF;
                        while (++i < byteLength && (mul *= 0x100)) {
                            this[offset + i] = (value / mul) & 0xFF;
                        }
                        return offset + byteLength;
                    };
                    Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
                        value = +value;
                        offset = offset | 0;
                        byteLength = byteLength | 0;
                        if (!noAssert) {
                            var maxBytes = Math.pow(2, 8 * byteLength) - 1;
                            checkInt(this, value, offset, byteLength, maxBytes, 0);
                        }
                        var i = byteLength - 1;
                        var mul = 1;
                        this[offset + i] = value & 0xFF;
                        while (--i >= 0 && (mul *= 0x100)) {
                            this[offset + i] = (value / mul) & 0xFF;
                        }
                        return offset + byteLength;
                    };
                    Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
                        value = +value;
                        offset = offset | 0;
                        if (!noAssert)
                            checkInt(this, value, offset, 1, 0xff, 0);
                        if (!Buffer.TYPED_ARRAY_SUPPORT)
                            value = Math.floor(value);
                        this[offset] = (value & 0xff);
                        return offset + 1;
                    };
                    function objectWriteUInt16(buf, value, offset, littleEndian) {
                        if (value < 0)
                            value = 0xffff + value + 1;
                        for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
                            buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
                                (littleEndian ? i : 1 - i) * 8;
                        }
                    }
                    Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
                        value = +value;
                        offset = offset | 0;
                        if (!noAssert)
                            checkInt(this, value, offset, 2, 0xffff, 0);
                        if (Buffer.TYPED_ARRAY_SUPPORT) {
                            this[offset] = (value & 0xff);
                            this[offset + 1] = (value >>> 8);
                        }
                        else {
                            objectWriteUInt16(this, value, offset, true);
                        }
                        return offset + 2;
                    };
                    Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
                        value = +value;
                        offset = offset | 0;
                        if (!noAssert)
                            checkInt(this, value, offset, 2, 0xffff, 0);
                        if (Buffer.TYPED_ARRAY_SUPPORT) {
                            this[offset] = (value >>> 8);
                            this[offset + 1] = (value & 0xff);
                        }
                        else {
                            objectWriteUInt16(this, value, offset, false);
                        }
                        return offset + 2;
                    };
                    function objectWriteUInt32(buf, value, offset, littleEndian) {
                        if (value < 0)
                            value = 0xffffffff + value + 1;
                        for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
                            buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff;
                        }
                    }
                    Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
                        value = +value;
                        offset = offset | 0;
                        if (!noAssert)
                            checkInt(this, value, offset, 4, 0xffffffff, 0);
                        if (Buffer.TYPED_ARRAY_SUPPORT) {
                            this[offset + 3] = (value >>> 24);
                            this[offset + 2] = (value >>> 16);
                            this[offset + 1] = (value >>> 8);
                            this[offset] = (value & 0xff);
                        }
                        else {
                            objectWriteUInt32(this, value, offset, true);
                        }
                        return offset + 4;
                    };
                    Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
                        value = +value;
                        offset = offset | 0;
                        if (!noAssert)
                            checkInt(this, value, offset, 4, 0xffffffff, 0);
                        if (Buffer.TYPED_ARRAY_SUPPORT) {
                            this[offset] = (value >>> 24);
                            this[offset + 1] = (value >>> 16);
                            this[offset + 2] = (value >>> 8);
                            this[offset + 3] = (value & 0xff);
                        }
                        else {
                            objectWriteUInt32(this, value, offset, false);
                        }
                        return offset + 4;
                    };
                    Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
                        value = +value;
                        offset = offset | 0;
                        if (!noAssert) {
                            var limit = Math.pow(2, 8 * byteLength - 1);
                            checkInt(this, value, offset, byteLength, limit - 1, -limit);
                        }
                        var i = 0;
                        var mul = 1;
                        var sub = 0;
                        this[offset] = value & 0xFF;
                        while (++i < byteLength && (mul *= 0x100)) {
                            if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
                                sub = 1;
                            }
                            this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
                        }
                        return offset + byteLength;
                    };
                    Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
                        value = +value;
                        offset = offset | 0;
                        if (!noAssert) {
                            var limit = Math.pow(2, 8 * byteLength - 1);
                            checkInt(this, value, offset, byteLength, limit - 1, -limit);
                        }
                        var i = byteLength - 1;
                        var mul = 1;
                        var sub = 0;
                        this[offset + i] = value & 0xFF;
                        while (--i >= 0 && (mul *= 0x100)) {
                            if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
                                sub = 1;
                            }
                            this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
                        }
                        return offset + byteLength;
                    };
                    Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
                        value = +value;
                        offset = offset | 0;
                        if (!noAssert)
                            checkInt(this, value, offset, 1, 0x7f, -0x80);
                        if (!Buffer.TYPED_ARRAY_SUPPORT)
                            value = Math.floor(value);
                        if (value < 0)
                            value = 0xff + value + 1;
                        this[offset] = (value & 0xff);
                        return offset + 1;
                    };
                    Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
                        value = +value;
                        offset = offset | 0;
                        if (!noAssert)
                            checkInt(this, value, offset, 2, 0x7fff, -0x8000);
                        if (Buffer.TYPED_ARRAY_SUPPORT) {
                            this[offset] = (value & 0xff);
                            this[offset + 1] = (value >>> 8);
                        }
                        else {
                            objectWriteUInt16(this, value, offset, true);
                        }
                        return offset + 2;
                    };
                    Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
                        value = +value;
                        offset = offset | 0;
                        if (!noAssert)
                            checkInt(this, value, offset, 2, 0x7fff, -0x8000);
                        if (Buffer.TYPED_ARRAY_SUPPORT) {
                            this[offset] = (value >>> 8);
                            this[offset + 1] = (value & 0xff);
                        }
                        else {
                            objectWriteUInt16(this, value, offset, false);
                        }
                        return offset + 2;
                    };
                    Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
                        value = +value;
                        offset = offset | 0;
                        if (!noAssert)
                            checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
                        if (Buffer.TYPED_ARRAY_SUPPORT) {
                            this[offset] = (value & 0xff);
                            this[offset + 1] = (value >>> 8);
                            this[offset + 2] = (value >>> 16);
                            this[offset + 3] = (value >>> 24);
                        }
                        else {
                            objectWriteUInt32(this, value, offset, true);
                        }
                        return offset + 4;
                    };
                    Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
                        value = +value;
                        offset = offset | 0;
                        if (!noAssert)
                            checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
                        if (value < 0)
                            value = 0xffffffff + value + 1;
                        if (Buffer.TYPED_ARRAY_SUPPORT) {
                            this[offset] = (value >>> 24);
                            this[offset + 1] = (value >>> 16);
                            this[offset + 2] = (value >>> 8);
                            this[offset + 3] = (value & 0xff);
                        }
                        else {
                            objectWriteUInt32(this, value, offset, false);
                        }
                        return offset + 4;
                    };
                    function checkIEEE754(buf, value, offset, ext, max, min) {
                        if (offset + ext > buf.length)
                            throw new RangeError('Index out of range');
                        if (offset < 0)
                            throw new RangeError('Index out of range');
                    }
                    function writeFloat(buf, value, offset, littleEndian, noAssert) {
                        if (!noAssert) {
                            checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);
                        }
                        ieee754.write(buf, value, offset, littleEndian, 23, 4);
                        return offset + 4;
                    }
                    Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
                        return writeFloat(this, value, offset, true, noAssert);
                    };
                    Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
                        return writeFloat(this, value, offset, false, noAssert);
                    };
                    function writeDouble(buf, value, offset, littleEndian, noAssert) {
                        if (!noAssert) {
                            checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308);
                        }
                        ieee754.write(buf, value, offset, littleEndian, 52, 8);
                        return offset + 8;
                    }
                    Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
                        return writeDouble(this, value, offset, true, noAssert);
                    };
                    Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
                        return writeDouble(this, value, offset, false, noAssert);
                    };
                    Buffer.prototype.copy = function copy(target, targetStart, start, end) {
                        if (!start)
                            start = 0;
                        if (!end && end !== 0)
                            end = this.length;
                        if (targetStart >= target.length)
                            targetStart = target.length;
                        if (!targetStart)
                            targetStart = 0;
                        if (end > 0 && end < start)
                            end = start;
                        if (end === start)
                            return 0;
                        if (target.length === 0 || this.length === 0)
                            return 0;
                        if (targetStart < 0) {
                            throw new RangeError('targetStart out of bounds');
                        }
                        if (start < 0 || start >= this.length)
                            throw new RangeError('sourceStart out of bounds');
                        if (end < 0)
                            throw new RangeError('sourceEnd out of bounds');
                        if (end > this.length)
                            end = this.length;
                        if (target.length - targetStart < end - start) {
                            end = target.length - targetStart + start;
                        }
                        var len = end - start;
                        var i;
                        if (this === target && start < targetStart && targetStart < end) {
                            for (i = len - 1; i >= 0; --i) {
                                target[i + targetStart] = this[i + start];
                            }
                        }
                        else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
                            for (i = 0; i < len; ++i) {
                                target[i + targetStart] = this[i + start];
                            }
                        }
                        else {
                            Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart);
                        }
                        return len;
                    };
                    Buffer.prototype.fill = function fill(val, start, end, encoding) {
                        if (typeof val === 'string') {
                            if (typeof start === 'string') {
                                encoding = start;
                                start = 0;
                                end = this.length;
                            }
                            else if (typeof end === 'string') {
                                encoding = end;
                                end = this.length;
                            }
                            if (val.length === 1) {
                                var code = val.charCodeAt(0);
                                if (code < 256) {
                                    val = code;
                                }
                            }
                            if (encoding !== undefined && typeof encoding !== 'string') {
                                throw new TypeError('encoding must be a string');
                            }
                            if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
                                throw new TypeError('Unknown encoding: ' + encoding);
                            }
                        }
                        else if (typeof val === 'number') {
                            val = val & 255;
                        }
                        if (start < 0 || this.length < start || this.length < end) {
                            throw new RangeError('Out of range index');
                        }
                        if (end <= start) {
                            return this;
                        }
                        start = start >>> 0;
                        end = end === undefined ? this.length : end >>> 0;
                        if (!val)
                            val = 0;
                        var i;
                        if (typeof val === 'number') {
                            for (i = start; i < end; ++i) {
                                this[i] = val;
                            }
                        }
                        else {
                            var bytes = Buffer.isBuffer(val)
                                ? val
                                : utf8ToBytes(new Buffer(val, encoding).toString());
                            var len = bytes.length;
                            for (i = 0; i < end - start; ++i) {
                                this[i + start] = bytes[i % len];
                            }
                        }
                        return this;
                    };
                    var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;
                    function base64clean(str) {
                        str = stringtrim(str).replace(INVALID_BASE64_RE, '');
                        if (str.length < 2)
                            return '';
                        while (str.length % 4 !== 0) {
                            str = str + '=';
                        }
                        return str;
                    }
                    function stringtrim(str) {
                        if (str.trim)
                            return str.trim();
                        return str.replace(/^\s+|\s+$/g, '');
                    }
                    function toHex(n) {
                        if (n < 16)
                            return '0' + n.toString(16);
                        return n.toString(16);
                    }
                    function utf8ToBytes(string, units) {
                        units = units || Infinity;
                        var codePoint;
                        var length = string.length;
                        var leadSurrogate = null;
                        var bytes = [];
                        for (var i = 0; i < length; ++i) {
                            codePoint = string.charCodeAt(i);
                            if (codePoint > 0xD7FF && codePoint < 0xE000) {
                                if (!leadSurrogate) {
                                    if (codePoint > 0xDBFF) {
                                        if ((units -= 3) > -1)
                                            bytes.push(0xEF, 0xBF, 0xBD);
                                        continue;
                                    }
                                    else if (i + 1 === length) {
                                        if ((units -= 3) > -1)
                                            bytes.push(0xEF, 0xBF, 0xBD);
                                        continue;
                                    }
                                    leadSurrogate = codePoint;
                                    continue;
                                }
                                if (codePoint < 0xDC00) {
                                    if ((units -= 3) > -1)
                                        bytes.push(0xEF, 0xBF, 0xBD);
                                    leadSurrogate = codePoint;
                                    continue;
                                }
                                codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
                            }
                            else if (leadSurrogate) {
                                if ((units -= 3) > -1)
                                    bytes.push(0xEF, 0xBF, 0xBD);
                            }
                            leadSurrogate = null;
                            if (codePoint < 0x80) {
                                if ((units -= 1) < 0)
                                    break;
                                bytes.push(codePoint);
                            }
                            else if (codePoint < 0x800) {
                                if ((units -= 2) < 0)
                                    break;
                                bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
                            }
                            else if (codePoint < 0x10000) {
                                if ((units -= 3) < 0)
                                    break;
                                bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
                            }
                            else if (codePoint < 0x110000) {
                                if ((units -= 4) < 0)
                                    break;
                                bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
                            }
                            else {
                                throw new Error('Invalid code point');
                            }
                        }
                        return bytes;
                    }
                    function asciiToBytes(str) {
                        var byteArray = [];
                        for (var i = 0; i < str.length; ++i) {
                            byteArray.push(str.charCodeAt(i) & 0xFF);
                        }
                        return byteArray;
                    }
                    function utf16leToBytes(str, units) {
                        var c, hi, lo;
                        var byteArray = [];
                        for (var i = 0; i < str.length; ++i) {
                            if ((units -= 2) < 0)
                                break;
                            c = str.charCodeAt(i);
                            hi = c >> 8;
                            lo = c % 256;
                            byteArray.push(lo);
                            byteArray.push(hi);
                        }
                        return byteArray;
                    }
                    function base64ToBytes(str) {
                        return base64.toByteArray(base64clean(str));
                    }
                    function blitBuffer(src, dst, offset, length) {
                        for (var i = 0; i < length; ++i) {
                            if ((i + offset >= dst.length) || (i >= src.length))
                                break;
                            dst[i + offset] = src[i];
                        }
                        return i;
                    }
                    function isnan(val) {
                        return val !== val;
                    }
                }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
            }, { "base64-js": 45, "ieee754": 166, "isarray": 169 }], 61: [function (localRequire, localModule, localExports) {
                (function (Buffer) {
                    var clone = (function () {
                        'use strict';
                        function clone(parent, circular, depth, prototype) {
                            var filter;
                            if (typeof circular === 'object') {
                                depth = circular.depth;
                                prototype = circular.prototype;
                                filter = circular.filter;
                                circular = circular.circular;
                            }
                            var allParents = [];
                            var allChildren = [];
                            var useBuffer = typeof Buffer != 'undefined';
                            if (typeof circular == 'undefined')
                                circular = true;
                            if (typeof depth == 'undefined')
                                depth = Infinity;
                            function _clone(parent, depth) {
                                if (parent === null)
                                    return null;
                                if (depth == 0)
                                    return parent;
                                var child;
                                var proto;
                                if (typeof parent != 'object') {
                                    return parent;
                                }
                                if (clone.__isArray(parent)) {
                                    child = [];
                                }
                                else if (clone.__isRegExp(parent)) {
                                    child = new RegExp(parent.source, __getRegExpFlags(parent));
                                    if (parent.lastIndex)
                                        child.lastIndex = parent.lastIndex;
                                }
                                else if (clone.__isDate(parent)) {
                                    child = new Date(parent.getTime());
                                }
                                else if (useBuffer && Buffer.isBuffer(parent)) {
                                    child = new Buffer(parent.length);
                                    parent.copy(child);
                                    return child;
                                }
                                else {
                                    if (typeof prototype == 'undefined') {
                                        proto = Object.getPrototypeOf(parent);
                                        child = Object.create(proto);
                                    }
                                    else {
                                        child = Object.create(prototype);
                                        proto = prototype;
                                    }
                                }
                                if (circular) {
                                    var index = allParents.indexOf(parent);
                                    if (index != -1) {
                                        return allChildren[index];
                                    }
                                    allParents.push(parent);
                                    allChildren.push(child);
                                }
                                for (var i in parent) {
                                    var attrs;
                                    if (proto) {
                                        attrs = Object.getOwnPropertyDescriptor(proto, i);
                                    }
                                    if (attrs && attrs.set == null) {
                                        continue;
                                    }
                                    child[i] = _clone(parent[i], depth - 1);
                                }
                                return child;
                            }
                            return _clone(parent, depth);
                        }
                        clone.clonePrototype = function clonePrototype(parent) {
                            if (parent === null)
                                return null;
                            var c = function () { };
                            c.prototype = parent;
                            return new c();
                        };
                        function __objToStr(o) {
                            return Object.prototype.toString.call(o);
                        }
                        ;
                        clone.__objToStr = __objToStr;
                        function __isDate(o) {
                            return typeof o === 'object' && __objToStr(o) === '[object Date]';
                        }
                        ;
                        clone.__isDate = __isDate;
                        function __isArray(o) {
                            return typeof o === 'object' && __objToStr(o) === '[object Array]';
                        }
                        ;
                        clone.__isArray = __isArray;
                        function __isRegExp(o) {
                            return typeof o === 'object' && __objToStr(o) === '[object RegExp]';
                        }
                        ;
                        clone.__isRegExp = __isRegExp;
                        function __getRegExpFlags(re) {
                            var flags = '';
                            if (re.global)
                                flags += 'g';
                            if (re.ignoreCase)
                                flags += 'i';
                            if (re.multiline)
                                flags += 'm';
                            return flags;
                        }
                        ;
                        clone.__getRegExpFlags = __getRegExpFlags;
                        return clone;
                    })();
                    if (typeof localModule === 'object' && localModule.localExports) {
                        localModule.localExports = clone;
                    }
                }).call(this, localRequire("buffer").Buffer);
            }, { "buffer": 60 }], 62: [function (localRequire, localModule, localExports) {
                localRequire('../../modules/es6.string.iterator');
                localRequire('../../modules/es6.array.from');
                localModule.localExports = localRequire('../../modules/_core').Array.from;
            }, { "../../modules/_core": 82, "../../modules/es6.array.from": 143, "../../modules/es6.string.iterator": 155 }], 63: [function (localRequire, localModule, localExports) {
                localRequire('../modules/web.dom.iterable');
                localRequire('../modules/es6.string.iterator');
                localModule.localExports = localRequire('../modules/core.get-iterator');
            }, { "../modules/core.get-iterator": 141, "../modules/es6.string.iterator": 155, "../modules/web.dom.iterable": 159 }], 64: [function (localRequire, localModule, localExports) {
                localRequire('../modules/web.dom.iterable');
                localRequire('../modules/es6.string.iterator');
                localModule.localExports = localRequire('../modules/core.is-iterable');
            }, { "../modules/core.is-iterable": 142, "../modules/es6.string.iterator": 155, "../modules/web.dom.iterable": 159 }], 65: [function (localRequire, localModule, localExports) {
                localRequire('../../modules/es6.object.assign');
                localModule.localExports = localRequire('../../modules/_core').Object.assign;
            }, { "../../modules/_core": 82, "../../modules/es6.object.assign": 145 }], 66: [function (localRequire, localModule, localExports) {
                localRequire('../../modules/es6.object.create');
                var $Object = localRequire('../../modules/_core').Object;
                localModule.localExports = function create(P, D) {
                    return $Object.create(P, D);
                };
            }, { "../../modules/_core": 82, "../../modules/es6.object.create": 146 }], 67: [function (localRequire, localModule, localExports) {
                localRequire('../../modules/es6.object.define-properties');
                var $Object = localRequire('../../modules/_core').Object;
                localModule.localExports = function defineProperties(T, D) {
                    return $Object.defineProperties(T, D);
                };
            }, { "../../modules/_core": 82, "../../modules/es6.object.define-properties": 147 }], 68: [function (localRequire, localModule, localExports) {
                localRequire('../../modules/es6.object.define-property');
                var $Object = localRequire('../../modules/_core').Object;
                localModule.localExports = function defineProperty(it, key, desc) {
                    return $Object.defineProperty(it, key, desc);
                };
            }, { "../../modules/_core": 82, "../../modules/es6.object.define-property": 148 }], 69: [function (localRequire, localModule, localExports) {
                localRequire('../../modules/es6.object.freeze');
                localModule.localExports = localRequire('../../modules/_core').Object.freeze;
            }, { "../../modules/_core": 82, "../../modules/es6.object.freeze": 149 }], 70: [function (localRequire, localModule, localExports) {
                localRequire('../../modules/es6.object.get-own-property-descriptor');
                var $Object = localRequire('../../modules/_core').Object;
                localModule.localExports = function getOwnPropertyDescriptor(it, key) {
                    return $Object.getOwnPropertyDescriptor(it, key);
                };
            }, { "../../modules/_core": 82, "../../modules/es6.object.get-own-property-descriptor": 150 }], 71: [function (localRequire, localModule, localExports) {
                localRequire('../../modules/es6.object.get-prototype-of');
                localModule.localExports = localRequire('../../modules/_core').Object.getPrototypeOf;
            }, { "../../modules/_core": 82, "../../modules/es6.object.get-prototype-of": 151 }], 72: [function (localRequire, localModule, localExports) {
                localRequire('../../modules/es6.object.keys');
                localModule.localExports = localRequire('../../modules/_core').Object.keys;
            }, { "../../modules/_core": 82, "../../modules/es6.object.keys": 152 }], 73: [function (localRequire, localModule, localExports) {
                localRequire('../../modules/es6.object.set-prototype-of');
                localModule.localExports = localRequire('../../modules/_core').Object.setPrototypeOf;
            }, { "../../modules/_core": 82, "../../modules/es6.object.set-prototype-of": 153 }], 74: [function (localRequire, localModule, localExports) {
                localRequire('../../modules/es6.symbol');
                localRequire('../../modules/es6.object.to-string');
                localRequire('../../modules/es7.symbol.async-iterator');
                localRequire('../../modules/es7.symbol.observable');
                localModule.localExports = localRequire('../../modules/_core').Symbol;
            }, { "../../modules/_core": 82, "../../modules/es6.object.to-string": 154, "../../modules/es6.symbol": 156, "../../modules/es7.symbol.async-iterator": 157, "../../modules/es7.symbol.observable": 158 }], 75: [function (localRequire, localModule, localExports) {
                localRequire('../../modules/es6.string.iterator');
                localRequire('../../modules/web.dom.iterable');
                localModule.localExports = localRequire('../../modules/_wks-ext').f('iterator');
            }, { "../../modules/_wks-ext": 138, "../../modules/es6.string.iterator": 155, "../../modules/web.dom.iterable": 159 }], 76: [function (localRequire, localModule, localExports) {
                localModule.localExports = function (it) {
                    if (typeof it != 'function')
                        throw TypeError(it + ' is not a function!');
                    return it;
                };
            }, {}], 77: [function (localRequire, localModule, localExports) {
                localModule.localExports = function () { };
            }, {}], 78: [function (localRequire, localModule, localExports) {
                var isObject = localRequire('./_is-object');
                localModule.localExports = function (it) {
                    if (!isObject(it))
                        throw TypeError(it + ' is not an object!');
                    return it;
                };
            }, { "./_is-object": 100 }], 79: [function (localRequire, localModule, localExports) {
                var toIObject = localRequire('./_to-iobject'), toLength = localRequire('./_to-length'), toIndex = localRequire('./_to-index');
                localModule.localExports = function (IS_INCLUDES) {
                    return function ($this, el, fromIndex) {
                        var O = toIObject($this), length = toLength(O.length), index = toIndex(fromIndex, length), value;
                        if (IS_INCLUDES && el != el)
                            while (length > index) {
                                value = O[index++];
                                if (value != value)
                                    return true;
                            }
                        else
                            for (; length > index; index++)
                                if (IS_INCLUDES || index in O) {
                                    if (O[index] === el)
                                        return IS_INCLUDES || index || 0;
                                }
                        return !IS_INCLUDES && -1;
                    };
                };
            }, { "./_to-index": 130, "./_to-iobject": 132, "./_to-length": 133 }], 80: [function (localRequire, localModule, localExports) {
                var cof = localRequire('./_cof'), TAG = localRequire('./_wks')('toStringTag'), ARG = cof(function () { return arguments; }()) == 'Arguments';
                var tryGet = function (it, key) {
                    try {
                        return it[key];
                    }
                    catch (e) { }
                };
                localModule.localExports = function (it) {
                    var O, T, B;
                    return it === undefined ? 'Undefined' : it === null ? 'Null'
                        : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
                            : ARG ? cof(O)
                                : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
                };
            }, { "./_cof": 81, "./_wks": 139 }], 81: [function (localRequire, localModule, localExports) {
                var toString = {}.toString;
                localModule.localExports = function (it) {
                    return toString.call(it).slice(8, -1);
                };
            }, {}], 82: [function (localRequire, localModule, localExports) {
                var core = localModule.localExports = { version: '2.4.0' };
                var __e;
                if (typeof __e == 'number')
                    __e = core;
            }, {}], 83: [function (localRequire, localModule, localExports) {
                'use strict';
                var $defineProperty = localRequire('./_object-dp'), createDesc = localRequire('./_property-desc');
                localModule.localExports = function (object, index, value) {
                    if (index in object)
                        $defineProperty.f(object, index, createDesc(0, value));
                    else
                        object[index] = value;
                };
            }, { "./_object-dp": 112, "./_property-desc": 123 }], 84: [function (localRequire, localModule, localExports) {
                var aFunction = localRequire('./_a-function');
                localModule.localExports = function (fn, that, length) {
                    aFunction(fn);
                    if (that === undefined)
                        return fn;
                    switch (length) {
                        case 1: return function (a) {
                            return fn.call(that, a);
                        };
                        case 2: return function (a, b) {
                            return fn.call(that, a, b);
                        };
                        case 3: return function (a, b, c) {
                            return fn.call(that, a, b, c);
                        };
                    }
                    return function () {
                        return fn.apply(that, arguments);
                    };
                };
            }, { "./_a-function": 76 }], 85: [function (localRequire, localModule, localExports) {
                localModule.localExports = function (it) {
                    if (it == undefined)
                        throw TypeError("Can't call method on  " + it);
                    return it;
                };
            }, {}], 86: [function (localRequire, localModule, localExports) {
                localModule.localExports = !localRequire('./_fails')(function () {
                    return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
                });
            }, { "./_fails": 91 }], 87: [function (localRequire, localModule, localExports) {
                var isObject = localRequire('./_is-object'), document = localRequire('./_global').document, is = isObject(document) && isObject(document.createElement);
                localModule.localExports = function (it) {
                    return is ? document.createElement(it) : {};
                };
            }, { "./_global": 92, "./_is-object": 100 }], 88: [function (localRequire, localModule, localExports) {
                localModule.localExports = ('constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf').split(',');
            }, {}], 89: [function (localRequire, localModule, localExports) {
                var getKeys = localRequire('./_object-keys'), gOPS = localRequire('./_object-gops'), pIE = localRequire('./_object-pie');
                localModule.localExports = function (it) {
                    var result = getKeys(it), getSymbols = gOPS.f;
                    if (getSymbols) {
                        var symbols = getSymbols(it), isEnum = pIE.f, i = 0, key;
                        while (symbols.length > i)
                            if (isEnum.call(it, key = symbols[i++]))
                                result.push(key);
                    }
                    return result;
                };
            }, { "./_object-gops": 117, "./_object-keys": 120, "./_object-pie": 121 }], 90: [function (localRequire, localModule, localExports) {
                var global = localRequire('./_global'), core = localRequire('./_core'), ctx = localRequire('./_ctx'), hide = localRequire('./_hide'), PROTOTYPE = 'prototype';
                var $export = function (type, name, source) {
                    var IS_FORCED = type & $export.F, IS_GLOBAL = type & $export.G, IS_STATIC = type & $export.S, IS_PROTO = type & $export.P, IS_BIND = type & $export.B, IS_WRAP = type & $export.W, localExports = IS_GLOBAL ? core : core[name] || (core[name] = {}), expProto = localExports[PROTOTYPE], target = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE], key, own, out;
                    if (IS_GLOBAL)
                        source = name;
                    for (key in source) {
                        own = !IS_FORCED && target && target[key] !== undefined;
                        if (own && key in localExports)
                            continue;
                        out = own ? target[key] : source[key];
                        localExports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
                            : IS_BIND && own ? ctx(out, global)
                                : IS_WRAP && target[key] == out ? (function (C) {
                                    var F = function (a, b, c) {
                                        if (this instanceof C) {
                                            switch (arguments.length) {
                                                case 0: return new C;
                                                case 1: return new C(a);
                                                case 2: return new C(a, b);
                                            }
                                            return new C(a, b, c);
                                        }
                                        return C.apply(this, arguments);
                                    };
                                    F[PROTOTYPE] = C[PROTOTYPE];
                                    return F;
                                })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
                        if (IS_PROTO) {
                            (localExports.virtual || (localExports.virtual = {}))[key] = out;
                            if (type & $export.R && expProto && !expProto[key])
                                hide(expProto, key, out);
                        }
                    }
                };
                $export.F = 1;
                $export.G = 2;
                $export.S = 4;
                $export.P = 8;
                $export.B = 16;
                $export.W = 32;
                $export.U = 64;
                $export.R = 128;
                localModule.localExports = $export;
            }, { "./_core": 82, "./_ctx": 84, "./_global": 92, "./_hide": 94 }], 91: [function (localRequire, localModule, localExports) {
                localModule.localExports = function (exec) {
                    try {
                        return !!exec();
                    }
                    catch (e) {
                        return true;
                    }
                };
            }, {}], 92: [function (localRequire, localModule, localExports) {
                var global = localModule.localExports = typeof window != 'undefined' && window.Math == Math
                    ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
                var __g;
                if (typeof __g == 'number')
                    __g = global;
            }, {}], 93: [function (localRequire, localModule, localExports) {
                var hasOwnProperty = {}.hasOwnProperty;
                localModule.localExports = function (it, key) {
                    return hasOwnProperty.call(it, key);
                };
            }, {}], 94: [function (localRequire, localModule, localExports) {
                var dP = localRequire('./_object-dp'), createDesc = localRequire('./_property-desc');
                localModule.localExports = localRequire('./_descriptors') ? function (object, key, value) {
                    return dP.f(object, key, createDesc(1, value));
                } : function (object, key, value) {
                    object[key] = value;
                    return object;
                };
            }, { "./_descriptors": 86, "./_object-dp": 112, "./_property-desc": 123 }], 95: [function (localRequire, localModule, localExports) {
                localModule.localExports = localRequire('./_global').document && document.documentElement;
            }, { "./_global": 92 }], 96: [function (localRequire, localModule, localExports) {
                localModule.localExports = !localRequire('./_descriptors') && !localRequire('./_fails')(function () {
                    return Object.defineProperty(localRequire('./_dom-create')('div'), 'a', { get: function () { return 7; } }).a != 7;
                });
            }, { "./_descriptors": 86, "./_dom-create": 87, "./_fails": 91 }], 97: [function (localRequire, localModule, localExports) {
                var cof = localRequire('./_cof');
                localModule.localExports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
                    return cof(it) == 'String' ? it.split('') : Object(it);
                };
            }, { "./_cof": 81 }], 98: [function (localRequire, localModule, localExports) {
                var Iterators = localRequire('./_iterators'), ITERATOR = localRequire('./_wks')('iterator'), ArrayProto = Array.prototype;
                localModule.localExports = function (it) {
                    return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
                };
            }, { "./_iterators": 106, "./_wks": 139 }], 99: [function (localRequire, localModule, localExports) {
                var cof = localRequire('./_cof');
                localModule.localExports = Array.isArray || function isArray(arg) {
                    return cof(arg) == 'Array';
                };
            }, { "./_cof": 81 }], 100: [function (localRequire, localModule, localExports) {
                localModule.localExports = function (it) {
                    return typeof it === 'object' ? it !== null : typeof it === 'function';
                };
            }, {}], 101: [function (localRequire, localModule, localExports) {
                var anObject = localRequire('./_an-object');
                localModule.localExports = function (iterator, fn, value, entries) {
                    try {
                        return entries ? fn(anObject(value)[0], value[1]) : fn(value);
                    }
                    catch (e) {
                        var ret = iterator['return'];
                        if (ret !== undefined)
                            anObject(ret.call(iterator));
                        throw e;
                    }
                };
            }, { "./_an-object": 78 }], 102: [function (localRequire, localModule, localExports) {
                'use strict';
                var create = localRequire('./_object-create'), descriptor = localRequire('./_property-desc'), setToStringTag = localRequire('./_set-to-string-tag'), IteratorPrototype = {};
                localRequire('./_hide')(IteratorPrototype, localRequire('./_wks')('iterator'), function () { return this; });
                localModule.localExports = function (Constructor, NAME, next) {
                    Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });
                    setToStringTag(Constructor, NAME + ' Iterator');
                };
            }, { "./_hide": 94, "./_object-create": 111, "./_property-desc": 123, "./_set-to-string-tag": 126, "./_wks": 139 }], 103: [function (localRequire, localModule, localExports) {
                'use strict';
                var LIBRARY = localRequire('./_library'), $export = localRequire('./_export'), redefine = localRequire('./_redefine'), hide = localRequire('./_hide'), has = localRequire('./_has'), Iterators = localRequire('./_iterators'), $iterCreate = localRequire('./_iter-create'), setToStringTag = localRequire('./_set-to-string-tag'), getPrototypeOf = localRequire('./_object-gpo'), ITERATOR = localRequire('./_wks')('iterator'), BUGGY = !([].keys && 'next' in [].keys()), FF_ITERATOR = '@@iterator', KEYS = 'keys', VALUES = 'values';
                var returnThis = function () { return this; };
                localModule.localExports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
                    $iterCreate(Constructor, NAME, next);
                    var getMethod = function (kind) {
                        if (!BUGGY && kind in proto)
                            return proto[kind];
                        switch (kind) {
                            case KEYS: return function keys() { return new Constructor(this, kind); };
                            case VALUES: return function values() { return new Constructor(this, kind); };
                        }
                        return function entries() { return new Constructor(this, kind); };
                    };
                    var TAG = NAME + ' Iterator', DEF_VALUES = DEFAULT == VALUES, VALUES_BUG = false, proto = Base.prototype, $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT], $default = $native || getMethod(DEFAULT), $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined, $anyNative = NAME == 'Array' ? proto.entries || $native : $native, methods, key, IteratorPrototype;
                    if ($anyNative) {
                        IteratorPrototype = getPrototypeOf($anyNative.call(new Base));
                        if (IteratorPrototype !== Object.prototype) {
                            setToStringTag(IteratorPrototype, TAG, true);
                            if (!LIBRARY && !has(IteratorPrototype, ITERATOR))
                                hide(IteratorPrototype, ITERATOR, returnThis);
                        }
                    }
                    if (DEF_VALUES && $native && $native.name !== VALUES) {
                        VALUES_BUG = true;
                        $default = function values() { return $native.call(this); };
                    }
                    if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
                        hide(proto, ITERATOR, $default);
                    }
                    Iterators[NAME] = $default;
                    Iterators[TAG] = returnThis;
                    if (DEFAULT) {
                        methods = {
                            values: DEF_VALUES ? $default : getMethod(VALUES),
                            keys: IS_SET ? $default : getMethod(KEYS),
                            entries: $entries
                        };
                        if (FORCED)
                            for (key in methods) {
                                if (!(key in proto))
                                    redefine(proto, key, methods[key]);
                            }
                        else
                            $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
                    }
                    return methods;
                };
            }, { "./_export": 90, "./_has": 93, "./_hide": 94, "./_iter-create": 102, "./_iterators": 106, "./_library": 108, "./_object-gpo": 118, "./_redefine": 124, "./_set-to-string-tag": 126, "./_wks": 139 }], 104: [function (localRequire, localModule, localExports) {
                var ITERATOR = localRequire('./_wks')('iterator'), SAFE_CLOSING = false;
                try {
                    var riter = [7][ITERATOR]();
                    riter['return'] = function () { SAFE_CLOSING = true; };
                    Array.from(riter, function () { throw 2; });
                }
                catch (e) { }
                localModule.localExports = function (exec, skipClosing) {
                    if (!skipClosing && !SAFE_CLOSING)
                        return false;
                    var safe = false;
                    try {
                        var arr = [7], iter = arr[ITERATOR]();
                        iter.next = function () { return { done: safe = true }; };
                        arr[ITERATOR] = function () { return iter; };
                        exec(arr);
                    }
                    catch (e) { }
                    return safe;
                };
            }, { "./_wks": 139 }], 105: [function (localRequire, localModule, localExports) {
                localModule.localExports = function (done, value) {
                    return { value: value, done: !!done };
                };
            }, {}], 106: [function (localRequire, localModule, localExports) {
                localModule.localExports = {};
            }, {}], 107: [function (localRequire, localModule, localExports) {
                var getKeys = localRequire('./_object-keys'), toIObject = localRequire('./_to-iobject');
                localModule.localExports = function (object, el) {
                    var O = toIObject(object), keys = getKeys(O), length = keys.length, index = 0, key;
                    while (length > index)
                        if (O[key = keys[index++]] === el)
                            return key;
                };
            }, { "./_object-keys": 120, "./_to-iobject": 132 }], 108: [function (localRequire, localModule, localExports) {
                localModule.localExports = true;
            }, {}], 109: [function (localRequire, localModule, localExports) {
                var META = localRequire('./_uid')('meta'), isObject = localRequire('./_is-object'), has = localRequire('./_has'), setDesc = localRequire('./_object-dp').f, id = 0;
                var isExtensible = Object.isExtensible || function () {
                    return true;
                };
                var FREEZE = !localRequire('./_fails')(function () {
                    return isExtensible(Object.preventExtensions({}));
                });
                var setMeta = function (it) {
                    setDesc(it, META, {
                        value: {
                            i: 'O' + ++id,
                            w: {}
                        }
                    });
                };
                var fastKey = function (it, create) {
                    if (!isObject(it))
                        return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
                    if (!has(it, META)) {
                        if (!isExtensible(it))
                            return 'F';
                        if (!create)
                            return 'E';
                        setMeta(it);
                    }
                    return it[META].i;
                };
                var getWeak = function (it, create) {
                    if (!has(it, META)) {
                        if (!isExtensible(it))
                            return true;
                        if (!create)
                            return false;
                        setMeta(it);
                    }
                    return it[META].w;
                };
                var onFreeze = function (it) {
                    if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META))
                        setMeta(it);
                    return it;
                };
                var meta = localModule.localExports = {
                    KEY: META,
                    NEED: false,
                    fastKey: fastKey,
                    getWeak: getWeak,
                    onFreeze: onFreeze
                };
            }, { "./_fails": 91, "./_has": 93, "./_is-object": 100, "./_object-dp": 112, "./_uid": 136 }], 110: [function (localRequire, localModule, localExports) {
                'use strict';
                var getKeys = localRequire('./_object-keys'), gOPS = localRequire('./_object-gops'), pIE = localRequire('./_object-pie'), toObject = localRequire('./_to-object'), IObject = localRequire('./_iobject'), $assign = Object.assign;
                localModule.localExports = !$assign || localRequire('./_fails')(function () {
                    var A = {}, B = {}, S = Symbol(), K = 'abcdefghijklmnopqrst';
                    A[S] = 7;
                    K.split('').forEach(function (k) { B[k] = k; });
                    return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
                }) ? function assign(target, source) {
                    var T = toObject(target), aLen = arguments.length, index = 1, getSymbols = gOPS.f, isEnum = pIE.f;
                    while (aLen > index) {
                        var S = IObject(arguments[index++]), keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S), length = keys.length, j = 0, key;
                        while (length > j)
                            if (isEnum.call(S, key = keys[j++]))
                                T[key] = S[key];
                    }
                    return T;
                } : $assign;
            }, { "./_fails": 91, "./_iobject": 97, "./_object-gops": 117, "./_object-keys": 120, "./_object-pie": 121, "./_to-object": 134 }], 111: [function (localRequire, localModule, localExports) {
                var anObject = localRequire('./_an-object'), dPs = localRequire('./_object-dps'), enumBugKeys = localRequire('./_enum-bug-keys'), IE_PROTO = localRequire('./_shared-key')('IE_PROTO'), Empty = function () { }, PROTOTYPE = 'prototype';
                var createDict = function () {
                    var iframe = localRequire('./_dom-create')('iframe'), i = enumBugKeys.length, lt = '<', gt = '>', iframeDocument;
                    iframe.style.display = 'none';
                    localRequire('./_html').appendChild(iframe);
                    iframe.src = 'javascript:';
                    iframeDocument = iframe.contentWindow.document;
                    iframeDocument.open();
                    iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
                    iframeDocument.close();
                    createDict = iframeDocument.F;
                    while (i--)
                        delete createDict[PROTOTYPE][enumBugKeys[i]];
                    return createDict();
                };
                localModule.localExports = Object.create || function create(O, Properties) {
                    var result;
                    if (O !== null) {
                        Empty[PROTOTYPE] = anObject(O);
                        result = new Empty;
                        Empty[PROTOTYPE] = null;
                        result[IE_PROTO] = O;
                    }
                    else
                        result = createDict();
                    return Properties === undefined ? result : dPs(result, Properties);
                };
            }, { "./_an-object": 78, "./_dom-create": 87, "./_enum-bug-keys": 88, "./_html": 95, "./_object-dps": 113, "./_shared-key": 127 }], 112: [function (localRequire, localModule, localExports) {
                var anObject = localRequire('./_an-object'), IE8_DOM_DEFINE = localRequire('./_ie8-dom-define'), toPrimitive = localRequire('./_to-primitive'), dP = Object.defineProperty;
                localExports.f = localRequire('./_descriptors') ? Object.defineProperty : function defineProperty(O, P, Attributes) {
                    anObject(O);
                    P = toPrimitive(P, true);
                    anObject(Attributes);
                    if (IE8_DOM_DEFINE)
                        try {
                            return dP(O, P, Attributes);
                        }
                        catch (e) { }
                    if ('get' in Attributes || 'set' in Attributes)
                        throw TypeError('Accessors not supported!');
                    if ('value' in Attributes)
                        O[P] = Attributes.value;
                    return O;
                };
            }, { "./_an-object": 78, "./_descriptors": 86, "./_ie8-dom-define": 96, "./_to-primitive": 135 }], 113: [function (localRequire, localModule, localExports) {
                var dP = localRequire('./_object-dp'), anObject = localRequire('./_an-object'), getKeys = localRequire('./_object-keys');
                localModule.localExports = localRequire('./_descriptors') ? Object.defineProperties : function defineProperties(O, Properties) {
                    anObject(O);
                    var keys = getKeys(Properties), length = keys.length, i = 0, P;
                    while (length > i)
                        dP.f(O, P = keys[i++], Properties[P]);
                    return O;
                };
            }, { "./_an-object": 78, "./_descriptors": 86, "./_object-dp": 112, "./_object-keys": 120 }], 114: [function (localRequire, localModule, localExports) {
                var pIE = localRequire('./_object-pie'), createDesc = localRequire('./_property-desc'), toIObject = localRequire('./_to-iobject'), toPrimitive = localRequire('./_to-primitive'), has = localRequire('./_has'), IE8_DOM_DEFINE = localRequire('./_ie8-dom-define'), gOPD = Object.getOwnPropertyDescriptor;
                localExports.f = localRequire('./_descriptors') ? gOPD : function getOwnPropertyDescriptor(O, P) {
                    O = toIObject(O);
                    P = toPrimitive(P, true);
                    if (IE8_DOM_DEFINE)
                        try {
                            return gOPD(O, P);
                        }
                        catch (e) { }
                    if (has(O, P))
                        return createDesc(!pIE.f.call(O, P), O[P]);
                };
            }, { "./_descriptors": 86, "./_has": 93, "./_ie8-dom-define": 96, "./_object-pie": 121, "./_property-desc": 123, "./_to-iobject": 132, "./_to-primitive": 135 }], 115: [function (localRequire, localModule, localExports) {
                var toIObject = localRequire('./_to-iobject'), gOPN = localRequire('./_object-gopn').f, toString = {}.toString;
                var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
                    ? Object.getOwnPropertyNames(window) : [];
                var getWindowNames = function (it) {
                    try {
                        return gOPN(it);
                    }
                    catch (e) {
                        return windowNames.slice();
                    }
                };
                localModule.localExports.f = function getOwnPropertyNames(it) {
                    return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
                };
            }, { "./_object-gopn": 116, "./_to-iobject": 132 }], 116: [function (localRequire, localModule, localExports) {
                var $keys = localRequire('./_object-keys-internal'), hiddenKeys = localRequire('./_enum-bug-keys').concat('length', 'prototype');
                localExports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
                    return $keys(O, hiddenKeys);
                };
            }, { "./_enum-bug-keys": 88, "./_object-keys-internal": 119 }], 117: [function (localRequire, localModule, localExports) {
                localExports.f = Object.getOwnPropertySymbols;
            }, {}], 118: [function (localRequire, localModule, localExports) {
                var has = localRequire('./_has'), toObject = localRequire('./_to-object'), IE_PROTO = localRequire('./_shared-key')('IE_PROTO'), ObjectProto = Object.prototype;
                localModule.localExports = Object.getPrototypeOf || function (O) {
                    O = toObject(O);
                    if (has(O, IE_PROTO))
                        return O[IE_PROTO];
                    if (typeof O.constructor == 'function' && O instanceof O.constructor) {
                        return O.constructor.prototype;
                    }
                    return O instanceof Object ? ObjectProto : null;
                };
            }, { "./_has": 93, "./_shared-key": 127, "./_to-object": 134 }], 119: [function (localRequire, localModule, localExports) {
                var has = localRequire('./_has'), toIObject = localRequire('./_to-iobject'), arrayIndexOf = localRequire('./_array-includes')(false), IE_PROTO = localRequire('./_shared-key')('IE_PROTO');
                localModule.localExports = function (object, names) {
                    var O = toIObject(object), i = 0, result = [], key;
                    for (key in O)
                        if (key != IE_PROTO)
                            has(O, key) && result.push(key);
                    while (names.length > i)
                        if (has(O, key = names[i++])) {
                            ~arrayIndexOf(result, key) || result.push(key);
                        }
                    return result;
                };
            }, { "./_array-includes": 79, "./_has": 93, "./_shared-key": 127, "./_to-iobject": 132 }], 120: [function (localRequire, localModule, localExports) {
                var $keys = localRequire('./_object-keys-internal'), enumBugKeys = localRequire('./_enum-bug-keys');
                localModule.localExports = Object.keys || function keys(O) {
                    return $keys(O, enumBugKeys);
                };
            }, { "./_enum-bug-keys": 88, "./_object-keys-internal": 119 }], 121: [function (localRequire, localModule, localExports) {
                localExports.f = {}.propertyIsEnumerable;
            }, {}], 122: [function (localRequire, localModule, localExports) {
                var $export = localRequire('./_export'), core = localRequire('./_core'), fails = localRequire('./_fails');
                localModule.localExports = function (KEY, exec) {
                    var fn = (core.Object || {})[KEY] || Object[KEY], exp = {};
                    exp[KEY] = exec(fn);
                    $export($export.S + $export.F * fails(function () { fn(1); }), 'Object', exp);
                };
            }, { "./_core": 82, "./_export": 90, "./_fails": 91 }], 123: [function (localRequire, localModule, localExports) {
                localModule.localExports = function (bitmap, value) {
                    return {
                        enumerable: !(bitmap & 1),
                        configurable: !(bitmap & 2),
                        writable: !(bitmap & 4),
                        value: value
                    };
                };
            }, {}], 124: [function (localRequire, localModule, localExports) {
                localModule.localExports = localRequire('./_hide');
            }, { "./_hide": 94 }], 125: [function (localRequire, localModule, localExports) {
                var isObject = localRequire('./_is-object'), anObject = localRequire('./_an-object');
                var check = function (O, proto) {
                    anObject(O);
                    if (!isObject(proto) && proto !== null)
                        throw TypeError(proto + ": can't set as prototype!");
                };
                localModule.localExports = {
                    set: Object.setPrototypeOf || ('__proto__' in {} ?
                        function (test, buggy, set) {
                            try {
                                set = localRequire('./_ctx')(Function.call, localRequire('./_object-gopd').f(Object.prototype, '__proto__').set, 2);
                                set(test, []);
                                buggy = !(test instanceof Array);
                            }
                            catch (e) {
                                buggy = true;
                            }
                            return function setPrototypeOf(O, proto) {
                                check(O, proto);
                                if (buggy)
                                    O.__proto__ = proto;
                                else
                                    set(O, proto);
                                return O;
                            };
                        }({}, false) : undefined),
                    check: check
                };
            }, { "./_an-object": 78, "./_ctx": 84, "./_is-object": 100, "./_object-gopd": 114 }], 126: [function (localRequire, localModule, localExports) {
                var def = localRequire('./_object-dp').f, has = localRequire('./_has'), TAG = localRequire('./_wks')('toStringTag');
                localModule.localExports = function (it, tag, stat) {
                    if (it && !has(it = stat ? it : it.prototype, TAG))
                        def(it, TAG, { configurable: true, value: tag });
                };
            }, { "./_has": 93, "./_object-dp": 112, "./_wks": 139 }], 127: [function (localRequire, localModule, localExports) {
                var shared = localRequire('./_shared')('keys'), uid = localRequire('./_uid');
                localModule.localExports = function (key) {
                    return shared[key] || (shared[key] = uid(key));
                };
            }, { "./_shared": 128, "./_uid": 136 }], 128: [function (localRequire, localModule, localExports) {
                var global = localRequire('./_global'), SHARED = '__core-js_shared__', store = global[SHARED] || (global[SHARED] = {});
                localModule.localExports = function (key) {
                    return store[key] || (store[key] = {});
                };
            }, { "./_global": 92 }], 129: [function (localRequire, localModule, localExports) {
                var toInteger = localRequire('./_to-integer'), defined = localRequire('./_defined');
                localModule.localExports = function (TO_STRING) {
                    return function (that, pos) {
                        var s = String(defined(that)), i = toInteger(pos), l = s.length, a, b;
                        if (i < 0 || i >= l)
                            return TO_STRING ? '' : undefined;
                        a = s.charCodeAt(i);
                        return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
                            ? TO_STRING ? s.charAt(i) : a
                            : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
                    };
                };
            }, { "./_defined": 85, "./_to-integer": 131 }], 130: [function (localRequire, localModule, localExports) {
                var toInteger = localRequire('./_to-integer'), max = Math.max, min = Math.min;
                localModule.localExports = function (index, length) {
                    index = toInteger(index);
                    return index < 0 ? max(index + length, 0) : min(index, length);
                };
            }, { "./_to-integer": 131 }], 131: [function (localRequire, localModule, localExports) {
                var ceil = Math.ceil, floor = Math.floor;
                localModule.localExports = function (it) {
                    return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
                };
            }, {}], 132: [function (localRequire, localModule, localExports) {
                var IObject = localRequire('./_iobject'), defined = localRequire('./_defined');
                localModule.localExports = function (it) {
                    return IObject(defined(it));
                };
            }, { "./_defined": 85, "./_iobject": 97 }], 133: [function (localRequire, localModule, localExports) {
                var toInteger = localRequire('./_to-integer'), min = Math.min;
                localModule.localExports = function (it) {
                    return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0;
                };
            }, { "./_to-integer": 131 }], 134: [function (localRequire, localModule, localExports) {
                var defined = localRequire('./_defined');
                localModule.localExports = function (it) {
                    return Object(defined(it));
                };
            }, { "./_defined": 85 }], 135: [function (localRequire, localModule, localExports) {
                var isObject = localRequire('./_is-object');
                localModule.localExports = function (it, S) {
                    if (!isObject(it))
                        return it;
                    var fn, val;
                    if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))
                        return val;
                    if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it)))
                        return val;
                    if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))
                        return val;
                    throw TypeError("Can't convert object to primitive value");
                };
            }, { "./_is-object": 100 }], 136: [function (localRequire, localModule, localExports) {
                var id = 0, px = Math.random();
                localModule.localExports = function (key) {
                    return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
                };
            }, {}], 137: [function (localRequire, localModule, localExports) {
                var global = localRequire('./_global'), core = localRequire('./_core'), LIBRARY = localRequire('./_library'), wksExt = localRequire('./_wks-ext'), defineProperty = localRequire('./_object-dp').f;
                localModule.localExports = function (name) {
                    var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
                    if (name.charAt(0) != '_' && !(name in $Symbol))
                        defineProperty($Symbol, name, { value: wksExt.f(name) });
                };
            }, { "./_core": 82, "./_global": 92, "./_library": 108, "./_object-dp": 112, "./_wks-ext": 138 }], 138: [function (localRequire, localModule, localExports) {
                localExports.f = localRequire('./_wks');
            }, { "./_wks": 139 }], 139: [function (localRequire, localModule, localExports) {
                var store = localRequire('./_shared')('wks'), uid = localRequire('./_uid'), Symbol = localRequire('./_global').Symbol, USE_SYMBOL = typeof Symbol == 'function';
                var $exports = localModule.localExports = function (name) {
                    return store[name] || (store[name] =
                        USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
                };
                $exports.store = store;
            }, { "./_global": 92, "./_shared": 128, "./_uid": 136 }], 140: [function (localRequire, localModule, localExports) {
                var classof = localRequire('./_classof'), ITERATOR = localRequire('./_wks')('iterator'), Iterators = localRequire('./_iterators');
                localModule.localExports = localRequire('./_core').getIteratorMethod = function (it) {
                    if (it != undefined)
                        return it[ITERATOR]
                            || it['@@iterator']
                            || Iterators[classof(it)];
                };
            }, { "./_classof": 80, "./_core": 82, "./_iterators": 106, "./_wks": 139 }], 141: [function (localRequire, localModule, localExports) {
                var anObject = localRequire('./_an-object'), get = localRequire('./core.get-iterator-method');
                localModule.localExports = localRequire('./_core').getIterator = function (it) {
                    var iterFn = get(it);
                    if (typeof iterFn != 'function')
                        throw TypeError(it + ' is not iterable!');
                    return anObject(iterFn.call(it));
                };
            }, { "./_an-object": 78, "./_core": 82, "./core.get-iterator-method": 140 }], 142: [function (localRequire, localModule, localExports) {
                var classof = localRequire('./_classof'), ITERATOR = localRequire('./_wks')('iterator'), Iterators = localRequire('./_iterators');
                localModule.localExports = localRequire('./_core').isIterable = function (it) {
                    var O = Object(it);
                    return O[ITERATOR] !== undefined
                        || '@@iterator' in O
                        || Iterators.hasOwnProperty(classof(O));
                };
            }, { "./_classof": 80, "./_core": 82, "./_iterators": 106, "./_wks": 139 }], 143: [function (localRequire, localModule, localExports) {
                'use strict';
                var ctx = localRequire('./_ctx'), $export = localRequire('./_export'), toObject = localRequire('./_to-object'), call = localRequire('./_iter-call'), isArrayIter = localRequire('./_is-array-iter'), toLength = localRequire('./_to-length'), createProperty = localRequire('./_create-property'), getIterFn = localRequire('./core.get-iterator-method');
                $export($export.S + $export.F * !localRequire('./_iter-detect')(function (iter) { Array.from(iter); }), 'Array', {
                    from: function from(arrayLike) {
                        var O = toObject(arrayLike), C = typeof this == 'function' ? this : Array, aLen = arguments.length, mapfn = aLen > 1 ? arguments[1] : undefined, mapping = mapfn !== undefined, index = 0, iterFn = getIterFn(O), length, result, step, iterator;
                        if (mapping)
                            mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
                        if (iterFn != undefined && !(C == Array && isArrayIter(iterFn))) {
                            for (iterator = iterFn.call(O), result = new C; !(step = iterator.next()).done; index++) {
                                createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
                            }
                        }
                        else {
                            length = toLength(O.length);
                            for (result = new C(length); length > index; index++) {
                                createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
                            }
                        }
                        result.length = index;
                        return result;
                    }
                });
            }, { "./_create-property": 83, "./_ctx": 84, "./_export": 90, "./_is-array-iter": 98, "./_iter-call": 101, "./_iter-detect": 104, "./_to-length": 133, "./_to-object": 134, "./core.get-iterator-method": 140 }], 144: [function (localRequire, localModule, localExports) {
                'use strict';
                var addToUnscopables = localRequire('./_add-to-unscopables'), step = localRequire('./_iter-step'), Iterators = localRequire('./_iterators'), toIObject = localRequire('./_to-iobject');
                localModule.localExports = localRequire('./_iter-define')(Array, 'Array', function (iterated, kind) {
                    this._t = toIObject(iterated);
                    this._i = 0;
                    this._k = kind;
                }, function () {
                    var O = this._t, kind = this._k, index = this._i++;
                    if (!O || index >= O.length) {
                        this._t = undefined;
                        return step(1);
                    }
                    if (kind == 'keys')
                        return step(0, index);
                    if (kind == 'values')
                        return step(0, O[index]);
                    return step(0, [index, O[index]]);
                }, 'values');
                Iterators.Arguments = Iterators.Array;
                addToUnscopables('keys');
                addToUnscopables('values');
                addToUnscopables('entries');
            }, { "./_add-to-unscopables": 77, "./_iter-define": 103, "./_iter-step": 105, "./_iterators": 106, "./_to-iobject": 132 }], 145: [function (localRequire, localModule, localExports) {
                var $export = localRequire('./_export');
                $export($export.S + $export.F, 'Object', { assign: localRequire('./_object-assign') });
            }, { "./_export": 90, "./_object-assign": 110 }], 146: [function (localRequire, localModule, localExports) {
                var $export = localRequire('./_export');
                $export($export.S, 'Object', { create: localRequire('./_object-create') });
            }, { "./_export": 90, "./_object-create": 111 }], 147: [function (localRequire, localModule, localExports) {
                var $export = localRequire('./_export');
                $export($export.S + $export.F * !localRequire('./_descriptors'), 'Object', { defineProperties: localRequire('./_object-dps') });
            }, { "./_descriptors": 86, "./_export": 90, "./_object-dps": 113 }], 148: [function (localRequire, localModule, localExports) {
                var $export = localRequire('./_export');
                $export($export.S + $export.F * !localRequire('./_descriptors'), 'Object', { defineProperty: localRequire('./_object-dp').f });
            }, { "./_descriptors": 86, "./_export": 90, "./_object-dp": 112 }], 149: [function (localRequire, localModule, localExports) {
                var isObject = localRequire('./_is-object'), meta = localRequire('./_meta').onFreeze;
                localRequire('./_object-sap')('freeze', function ($freeze) {
                    return function freeze(it) {
                        return $freeze && isObject(it) ? $freeze(meta(it)) : it;
                    };
                });
            }, { "./_is-object": 100, "./_meta": 109, "./_object-sap": 122 }], 150: [function (localRequire, localModule, localExports) {
                var toIObject = localRequire('./_to-iobject'), $getOwnPropertyDescriptor = localRequire('./_object-gopd').f;
                localRequire('./_object-sap')('getOwnPropertyDescriptor', function () {
                    return function getOwnPropertyDescriptor(it, key) {
                        return $getOwnPropertyDescriptor(toIObject(it), key);
                    };
                });
            }, { "./_object-gopd": 114, "./_object-sap": 122, "./_to-iobject": 132 }], 151: [function (localRequire, localModule, localExports) {
                var toObject = localRequire('./_to-object'), $getPrototypeOf = localRequire('./_object-gpo');
                localRequire('./_object-sap')('getPrototypeOf', function () {
                    return function getPrototypeOf(it) {
                        return $getPrototypeOf(toObject(it));
                    };
                });
            }, { "./_object-gpo": 118, "./_object-sap": 122, "./_to-object": 134 }], 152: [function (localRequire, localModule, localExports) {
                var toObject = localRequire('./_to-object'), $keys = localRequire('./_object-keys');
                localRequire('./_object-sap')('keys', function () {
                    return function keys(it) {
                        return $keys(toObject(it));
                    };
                });
            }, { "./_object-keys": 120, "./_object-sap": 122, "./_to-object": 134 }], 153: [function (localRequire, localModule, localExports) {
                var $export = localRequire('./_export');
                $export($export.S, 'Object', { setPrototypeOf: localRequire('./_set-proto').set });
            }, { "./_export": 90, "./_set-proto": 125 }], 154: [function (localRequire, localModule, localExports) {
                arguments[4][56][0].apply(localExports, arguments);
            }, { "dup": 56 }], 155: [function (localRequire, localModule, localExports) {
                'use strict';
                var $at = localRequire('./_string-at')(true);
                localRequire('./_iter-define')(String, 'String', function (iterated) {
                    this._t = String(iterated);
                    this._i = 0;
                }, function () {
                    var O = this._t, index = this._i, point;
                    if (index >= O.length)
                        return { value: undefined, done: true };
                    point = $at(O, index);
                    this._i += point.length;
                    return { value: point, done: false };
                });
            }, { "./_iter-define": 103, "./_string-at": 129 }], 156: [function (localRequire, localModule, localExports) {
                'use strict';
                var global = localRequire('./_global'), has = localRequire('./_has'), DESCRIPTORS = localRequire('./_descriptors'), $export = localRequire('./_export'), redefine = localRequire('./_redefine'), META = localRequire('./_meta').KEY, $fails = localRequire('./_fails'), shared = localRequire('./_shared'), setToStringTag = localRequire('./_set-to-string-tag'), uid = localRequire('./_uid'), wks = localRequire('./_wks'), wksExt = localRequire('./_wks-ext'), wksDefine = localRequire('./_wks-define'), keyOf = localRequire('./_keyof'), enumKeys = localRequire('./_enum-keys'), isArray = localRequire('./_is-array'), anObject = localRequire('./_an-object'), toIObject = localRequire('./_to-iobject'), toPrimitive = localRequire('./_to-primitive'), createDesc = localRequire('./_property-desc'), _create = localRequire('./_object-create'), gOPNExt = localRequire('./_object-gopn-ext'), $GOPD = localRequire('./_object-gopd'), $DP = localRequire('./_object-dp'), $keys = localRequire('./_object-keys'), gOPD = $GOPD.f, dP = $DP.f, gOPN = gOPNExt.f, $Symbol = global.Symbol, $JSON = global.JSON, _stringify = $JSON && $JSON.stringify, PROTOTYPE = 'prototype', HIDDEN = wks('_hidden'), TO_PRIMITIVE = wks('toPrimitive'), isEnum = {}.propertyIsEnumerable, SymbolRegistry = shared('symbol-registry'), AllSymbols = shared('symbols'), OPSymbols = shared('op-symbols'), ObjectProto = Object[PROTOTYPE], USE_NATIVE = typeof $Symbol == 'function', QObject = global.QObject;
                var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;
                var setSymbolDesc = DESCRIPTORS && $fails(function () {
                    return _create(dP({}, 'a', {
                        get: function () { return dP(this, 'a', { value: 7 }).a; }
                    })).a != 7;
                }) ? function (it, key, D) {
                    var protoDesc = gOPD(ObjectProto, key);
                    if (protoDesc)
                        delete ObjectProto[key];
                    dP(it, key, D);
                    if (protoDesc && it !== ObjectProto)
                        dP(ObjectProto, key, protoDesc);
                } : dP;
                var wrap = function (tag) {
                    var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
                    sym._k = tag;
                    return sym;
                };
                var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function (it) {
                    return typeof it == 'symbol';
                } : function (it) {
                    return it instanceof $Symbol;
                };
                var $defineProperty = function defineProperty(it, key, D) {
                    if (it === ObjectProto)
                        $defineProperty(OPSymbols, key, D);
                    anObject(it);
                    key = toPrimitive(key, true);
                    anObject(D);
                    if (has(AllSymbols, key)) {
                        if (!D.enumerable) {
                            if (!has(it, HIDDEN))
                                dP(it, HIDDEN, createDesc(1, {}));
                            it[HIDDEN][key] = true;
                        }
                        else {
                            if (has(it, HIDDEN) && it[HIDDEN][key])
                                it[HIDDEN][key] = false;
                            D = _create(D, { enumerable: createDesc(0, false) });
                        }
                        return setSymbolDesc(it, key, D);
                    }
                    return dP(it, key, D);
                };
                var $defineProperties = function defineProperties(it, P) {
                    anObject(it);
                    var keys = enumKeys(P = toIObject(P)), i = 0, l = keys.length, key;
                    while (l > i)
                        $defineProperty(it, key = keys[i++], P[key]);
                    return it;
                };
                var $create = function create(it, P) {
                    return P === undefined ? _create(it) : $defineProperties(_create(it), P);
                };
                var $propertyIsEnumerable = function propertyIsEnumerable(key) {
                    var E = isEnum.call(this, key = toPrimitive(key, true));
                    if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))
                        return false;
                    return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
                };
                var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
                    it = toIObject(it);
                    key = toPrimitive(key, true);
                    if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))
                        return;
                    var D = gOPD(it, key);
                    if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key]))
                        D.enumerable = true;
                    return D;
                };
                var $getOwnPropertyNames = function getOwnPropertyNames(it) {
                    var names = gOPN(toIObject(it)), result = [], i = 0, key;
                    while (names.length > i) {
                        if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META)
                            result.push(key);
                    }
                    return result;
                };
                var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
                    var IS_OP = it === ObjectProto, names = gOPN(IS_OP ? OPSymbols : toIObject(it)), result = [], i = 0, key;
                    while (names.length > i) {
                        if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true))
                            result.push(AllSymbols[key]);
                    }
                    return result;
                };
                if (!USE_NATIVE) {
                    $Symbol = function Symbol() {
                        if (this instanceof $Symbol)
                            throw TypeError('Symbol is not a constructor!');
                        var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
                        var $set = function (value) {
                            if (this === ObjectProto)
                                $set.call(OPSymbols, value);
                            if (has(this, HIDDEN) && has(this[HIDDEN], tag))
                                this[HIDDEN][tag] = false;
                            setSymbolDesc(this, tag, createDesc(1, value));
                        };
                        if (DESCRIPTORS && setter)
                            setSymbolDesc(ObjectProto, tag, { configurable: true, set: $set });
                        return wrap(tag);
                    };
                    redefine($Symbol[PROTOTYPE], 'toString', function toString() {
                        return this._k;
                    });
                    $GOPD.f = $getOwnPropertyDescriptor;
                    $DP.f = $defineProperty;
                    localRequire('./_object-gopn').f = gOPNExt.f = $getOwnPropertyNames;
                    localRequire('./_object-pie').f = $propertyIsEnumerable;
                    localRequire('./_object-gops').f = $getOwnPropertySymbols;
                    if (DESCRIPTORS && !localRequire('./_library')) {
                        redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
                    }
                    wksExt.f = function (name) {
                        return wrap(wks(name));
                    };
                }
                $export($export.G + $export.W + $export.F * !USE_NATIVE, { Symbol: $Symbol });
                for (var symbols = ('hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables').split(','), i = 0; symbols.length > i;)
                    wks(symbols[i++]);
                for (var symbols = $keys(wks.store), i = 0; symbols.length > i;)
                    wksDefine(symbols[i++]);
                $export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
                    'for': function (key) {
                        return has(SymbolRegistry, key += '')
                            ? SymbolRegistry[key]
                            : SymbolRegistry[key] = $Symbol(key);
                    },
                    keyFor: function keyFor(key) {
                        if (isSymbol(key))
                            return keyOf(SymbolRegistry, key);
                        throw TypeError(key + ' is not a symbol!');
                    },
                    useSetter: function () { setter = true; },
                    useSimple: function () { setter = false; }
                });
                $export($export.S + $export.F * !USE_NATIVE, 'Object', {
                    create: $create,
                    defineProperty: $defineProperty,
                    defineProperties: $defineProperties,
                    getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
                    getOwnPropertyNames: $getOwnPropertyNames,
                    getOwnPropertySymbols: $getOwnPropertySymbols
                });
                $JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function () {
                    var S = $Symbol();
                    return _stringify([S]) != '[null]' || _stringify({ a: S }) != '{}' || _stringify(Object(S)) != '{}';
                })), 'JSON', {
                    stringify: function stringify(it) {
                        if (it === undefined || isSymbol(it))
                            return;
                        var args = [it], i = 1, replacer, $replacer;
                        while (arguments.length > i)
                            args.push(arguments[i++]);
                        replacer = args[1];
                        if (typeof replacer == 'function')
                            $replacer = replacer;
                        if ($replacer || !isArray(replacer))
                            replacer = function (key, value) {
                                if ($replacer)
                                    value = $replacer.call(this, key, value);
                                if (!isSymbol(value))
                                    return value;
                            };
                        args[1] = replacer;
                        return _stringify.apply($JSON, args);
                    }
                });
                $Symbol[PROTOTYPE][TO_PRIMITIVE] || localRequire('./_hide')($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
                setToStringTag($Symbol, 'Symbol');
                setToStringTag(Math, 'Math', true);
                setToStringTag(global.JSON, 'JSON', true);
            }, { "./_an-object": 78, "./_descriptors": 86, "./_enum-keys": 89, "./_export": 90, "./_fails": 91, "./_global": 92, "./_has": 93, "./_hide": 94, "./_is-array": 99, "./_keyof": 107, "./_library": 108, "./_meta": 109, "./_object-create": 111, "./_object-dp": 112, "./_object-gopd": 114, "./_object-gopn": 116, "./_object-gopn-ext": 115, "./_object-gops": 117, "./_object-keys": 120, "./_object-pie": 121, "./_property-desc": 123, "./_redefine": 124, "./_set-to-string-tag": 126, "./_shared": 128, "./_to-iobject": 132, "./_to-primitive": 135, "./_uid": 136, "./_wks": 139, "./_wks-define": 137, "./_wks-ext": 138 }], 157: [function (localRequire, localModule, localExports) {
                localRequire('./_wks-define')('asyncIterator');
            }, { "./_wks-define": 137 }], 158: [function (localRequire, localModule, localExports) {
                localRequire('./_wks-define')('observable');
            }, { "./_wks-define": 137 }], 159: [function (localRequire, localModule, localExports) {
                localRequire('./es6.array.iterator');
                var global = localRequire('./_global'), hide = localRequire('./_hide'), Iterators = localRequire('./_iterators'), TO_STRING_TAG = localRequire('./_wks')('toStringTag');
                for (var collections = ['NodeList', 'DOMTokenList', 'MediaList', 'StyleSheetList', 'CSSRuleList'], i = 0; i < 5; i++) {
                    var NAME = collections[i], Collection = global[NAME], proto = Collection && Collection.prototype;
                    if (proto && !proto[TO_STRING_TAG])
                        hide(proto, TO_STRING_TAG, NAME);
                    Iterators[NAME] = Iterators.Array;
                }
            }, { "./_global": 92, "./_hide": 94, "./_iterators": 106, "./_wks": 139, "./es6.array.iterator": 144 }], 160: [function (localRequire, localModule, localExports) {
                (function (Buffer) {
                    function isArray(arg) {
                        if (Array.isArray) {
                            return Array.isArray(arg);
                        }
                        return objectToString(arg) === '[object Array]';
                    }
                    localExports.isArray = isArray;
                    function isBoolean(arg) {
                        return typeof arg === 'boolean';
                    }
                    localExports.isBoolean = isBoolean;
                    function isNull(arg) {
                        return arg === null;
                    }
                    localExports.isNull = isNull;
                    function isNullOrUndefined(arg) {
                        return arg == null;
                    }
                    localExports.isNullOrUndefined = isNullOrUndefined;
                    function isNumber(arg) {
                        return typeof arg === 'number';
                    }
                    localExports.isNumber = isNumber;
                    function isString(arg) {
                        return typeof arg === 'string';
                    }
                    localExports.isString = isString;
                    function isSymbol(arg) {
                        return typeof arg === 'symbol';
                    }
                    localExports.isSymbol = isSymbol;
                    function isUndefined(arg) {
                        return arg === void 0;
                    }
                    localExports.isUndefined = isUndefined;
                    function isRegExp(re) {
                        return objectToString(re) === '[object RegExp]';
                    }
                    localExports.isRegExp = isRegExp;
                    function isObject(arg) {
                        return typeof arg === 'object' && arg !== null;
                    }
                    localExports.isObject = isObject;
                    function isDate(d) {
                        return objectToString(d) === '[object Date]';
                    }
                    localExports.isDate = isDate;
                    function isError(e) {
                        return (objectToString(e) === '[object Error]' || e instanceof Error);
                    }
                    localExports.isError = isError;
                    function isFunction(arg) {
                        return typeof arg === 'function';
                    }
                    localExports.isFunction = isFunction;
                    function isPrimitive(arg) {
                        return arg === null ||
                            typeof arg === 'boolean' ||
                            typeof arg === 'number' ||
                            typeof arg === 'string' ||
                            typeof arg === 'symbol' ||
                            typeof arg === 'undefined';
                    }
                    localExports.isPrimitive = isPrimitive;
                    localExports.isBuffer = Buffer.isBuffer;
                    function objectToString(o) {
                        return Object.prototype.toString.call(o);
                    }
                }).call(this, { "isBuffer": localRequire("../../is-buffer/index.js") });
            }, { "../../is-buffer/index.js": 168 }],
        164: [function (localRequire, localModule, localExports) {
                function EventEmitter() {
                    this._events = this._events || {};
                    this._maxListeners = this._maxListeners || undefined;
                }
                localModule.localExports = EventEmitter;
                EventEmitter.EventEmitter = EventEmitter;
                EventEmitter.prototype._events = undefined;
                EventEmitter.prototype._maxListeners = undefined;
                EventEmitter.defaultMaxListeners = 10;
                EventEmitter.prototype.setMaxListeners = function (n) {
                    if (!isNumber(n) || n < 0 || isNaN(n))
                        throw TypeError('n must be a positive number');
                    this._maxListeners = n;
                    return this;
                };
                EventEmitter.prototype.emit = function (type) {
                    var er, handler, len, args, i, listeners;
                    if (!this._events)
                        this._events = {};
                    if (type === 'error') {
                        if (!this._events.error ||
                            (isObject(this._events.error) && !this._events.error.length)) {
                            er = arguments[1];
                            if (er instanceof Error) {
                                throw er;
                            }
                            else {
                                var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
                                err.context = er;
                                throw err;
                            }
                        }
                    }
                    handler = this._events[type];
                    if (isUndefined(handler))
                        return false;
                    if (isFunction(handler)) {
                        switch (arguments.length) {
                            case 1:
                                handler.call(this);
                                break;
                            case 2:
                                handler.call(this, arguments[1]);
                                break;
                            case 3:
                                handler.call(this, arguments[1], arguments[2]);
                                break;
                            default:
                                args = Array.prototype.slice.call(arguments, 1);
                                handler.apply(this, args);
                        }
                    }
                    else if (isObject(handler)) {
                        args = Array.prototype.slice.call(arguments, 1);
                        listeners = handler.slice();
                        len = listeners.length;
                        for (i = 0; i < len; i++)
                            listeners[i].apply(this, args);
                    }
                    return true;
                };
                EventEmitter.prototype.addListener = function (type, listener) {
                    var m;
                    if (!isFunction(listener))
                        throw TypeError('listener must be a function');
                    if (!this._events)
                        this._events = {};
                    if (this._events.newListener)
                        this.emit('newListener', type, isFunction(listener.listener) ?
                            listener.listener : listener);
                    if (!this._events[type])
                        this._events[type] = listener;
                    else if (isObject(this._events[type]))
                        this._events[type].push(listener);
                    else
                        this._events[type] = [this._events[type], listener];
                    if (isObject(this._events[type]) && !this._events[type].warned) {
                        if (!isUndefined(this._maxListeners)) {
                            m = this._maxListeners;
                        }
                        else {
                            m = EventEmitter.defaultMaxListeners;
                        }
                        if (m && m > 0 && this._events[type].length > m) {
                            this._events[type].warned = true;
                            console.error('(node) warning: possible EventEmitter memory ' +
                                'leak detected. %d listeners added. ' +
                                'Use emitter.setMaxListeners() to increase limit.', this._events[type].length);
                            if (typeof console.trace === 'function') {
                                console.trace();
                            }
                        }
                    }
                    return this;
                };
                EventEmitter.prototype.on = EventEmitter.prototype.addListener;
                EventEmitter.prototype.once = function (type, listener) {
                    if (!isFunction(listener))
                        throw TypeError('listener must be a function');
                    var fired = false;
                    function g() {
                        this.removeListener(type, g);
                        if (!fired) {
                            fired = true;
                            listener.apply(this, arguments);
                        }
                    }
                    g.listener = listener;
                    this.on(type, g);
                    return this;
                };
                EventEmitter.prototype.removeListener = function (type, listener) {
                    var list, position, length, i;
                    if (!isFunction(listener))
                        throw TypeError('listener must be a function');
                    if (!this._events || !this._events[type])
                        return this;
                    list = this._events[type];
                    length = list.length;
                    position = -1;
                    if (list === listener ||
                        (isFunction(list.listener) && list.listener === listener)) {
                        delete this._events[type];
                        if (this._events.removeListener)
                            this.emit('removeListener', type, listener);
                    }
                    else if (isObject(list)) {
                        for (i = length; i-- > 0;) {
                            if (list[i] === listener ||
                                (list[i].listener && list[i].listener === listener)) {
                                position = i;
                                break;
                            }
                        }
                        if (position < 0)
                            return this;
                        if (list.length === 1) {
                            list.length = 0;
                            delete this._events[type];
                        }
                        else {
                            list.splice(position, 1);
                        }
                        if (this._events.removeListener)
                            this.emit('removeListener', type, listener);
                    }
                    return this;
                };
                EventEmitter.prototype.removeAllListeners = function (type) {
                    var key, listeners;
                    if (!this._events)
                        return this;
                    if (!this._events.removeListener) {
                        if (arguments.length === 0)
                            this._events = {};
                        else if (this._events[type])
                            delete this._events[type];
                        return this;
                    }
                    if (arguments.length === 0) {
                        for (key in this._events) {
                            if (key === 'removeListener')
                                continue;
                            this.removeAllListeners(key);
                        }
                        this.removeAllListeners('removeListener');
                        this._events = {};
                        return this;
                    }
                    listeners = this._events[type];
                    if (isFunction(listeners)) {
                        this.removeListener(type, listeners);
                    }
                    else if (listeners) {
                        while (listeners.length)
                            this.removeListener(type, listeners[listeners.length - 1]);
                    }
                    delete this._events[type];
                    return this;
                };
                EventEmitter.prototype.listeners = function (type) {
                    var ret;
                    if (!this._events || !this._events[type])
                        ret = [];
                    else if (isFunction(this._events[type]))
                        ret = [this._events[type]];
                    else
                        ret = this._events[type].slice();
                    return ret;
                };
                EventEmitter.prototype.listenerCount = function (type) {
                    if (this._events) {
                        var evlistener = this._events[type];
                        if (isFunction(evlistener))
                            return 1;
                        else if (evlistener)
                            return evlistener.length;
                    }
                    return 0;
                };
                EventEmitter.listenerCount = function (emitter, type) {
                    return emitter.listenerCount(type);
                };
                function isFunction(arg) {
                    return typeof arg === 'function';
                }
                function isNumber(arg) {
                    return typeof arg === 'number';
                }
                function isObject(arg) {
                    return typeof arg === 'object' && arg !== null;
                }
                function isUndefined(arg) {
                    return arg === void 0;
                }
            }, {}], 165: [function (localRequire, localModule, localExports) {
                (function (process, Buffer) {
                    'use strict';
                    function _interopDefault(ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }
                    var r = _interopDefault(localRequire('restructure'));
                    var fs;
                    var _Object$getOwnPropertyDescriptor = _interopDefault(localRequire('babel-runtime/core-js/object/get-own-property-descriptor'));
                    var _Object$freeze = _interopDefault(localRequire('babel-runtime/core-js/object/freeze'));
                    var _Object$keys = _interopDefault(localRequire('babel-runtime/core-js/object/keys'));
                    var _typeof = _interopDefault(localRequire('babel-runtime/helpers/typeof'));
                    var _Object$defineProperty = _interopDefault(localRequire('babel-runtime/core-js/object/define-property'));
                    var _classCallCheck = _interopDefault(localRequire('babel-runtime/helpers/classCallCheck'));
                    var _createClass = _interopDefault(localRequire('babel-runtime/helpers/createClass'));
                    var _Object$getPrototypeOf = _interopDefault(localRequire('babel-runtime/core-js/object/get-prototype-of'));
                    var _possibleConstructorReturn = _interopDefault(localRequire('babel-runtime/helpers/possibleConstructorReturn'));
                    var _inherits = _interopDefault(localRequire('babel-runtime/helpers/inherits'));
                    var _Object$defineProperties = _interopDefault(localRequire('babel-runtime/core-js/object/define-properties'));
                    var _get = _interopDefault(localRequire('babel-runtime/helpers/get'));
                    var _Object$assign = _interopDefault(localRequire('babel-runtime/core-js/object/assign'));
                    var _toConsumableArray = _interopDefault(localRequire('babel-runtime/helpers/toConsumableArray'));
                    var unicode = _interopDefault(localRequire('unicode-properties'));
                    var _slicedToArray = _interopDefault(localRequire('babel-runtime/helpers/slicedToArray'));
                    var cloneDeep = _interopDefault(localRequire('clone'));
                    var fontkit = {};
                    fontkit.logErrors = false;
                    var formats = [];
                    fontkit.registerFormat = function (format) {
                        formats.push(format);
                    };
                    fontkit.create = function (buffer, postscriptName) {
                        for (var i = 0; i < formats.length; i++) {
                            var format = formats[i];
                            if (format.probe(buffer)) {
                                var font = new format(new r.DecodeStream(buffer));
                                if (postscriptName) {
                                    return font.getFont(postscriptName);
                                }
                                return font;
                            }
                        }
                        throw new Error('Unknown font format');
                    };
                    function cache(target, key, descriptor) {
                        var get = descriptor.get;
                        descriptor.get = function () {
                            var value = get.call(this);
                            _Object$defineProperty(this, key, { value: value });
                            return value;
                        };
                    }
                    var SubHeader = new r.Struct({
                        firstCode: r.uint16,
                        entryCount: r.uint16,
                        idDelta: r.int16,
                        idRangeOffset: r.uint16
                    });
                    var CmapGroup = new r.Struct({
                        startCharCode: r.uint32,
                        endCharCode: r.uint32,
                        glyphID: r.uint32
                    });
                    var UnicodeValueRange = new r.Struct({
                        startUnicodeValue: r.uint24,
                        additionalCount: r.uint8
                    });
                    var UVSMapping = new r.Struct({
                        unicodeValue: r.uint24,
                        glyphID: r.uint16
                    });
                    var CmapSubtable = new r.VersionedStruct(r.uint16, {
                        0: {
                            length: r.uint16,
                            language: r.uint16,
                            codeMap: new r.LazyArray(r.uint8, 256)
                        },
                        2: {
                            length: r.uint16,
                            language: r.uint16,
                            subHeaderKeys: new r.Array(r.uint16, 256),
                            subHeaderCount: function subHeaderCount(t) {
                                return Math.max.apply(Math, t.subHeaderKeys);
                            },
                            subHeaders: new r.LazyArray(SubHeader, 'subHeaderCount'),
                            glyphIndexArray: new r.LazyArray(r.uint16, 'subHeaderCount')
                        },
                        4: {
                            length: r.uint16,
                            language: r.uint16,
                            segCountX2: r.uint16,
                            segCount: function segCount(t) {
                                return t.segCountX2 >> 1;
                            },
                            searchRange: r.uint16,
                            entrySelector: r.uint16,
                            rangeShift: r.uint16,
                            endCode: new r.LazyArray(r.uint16, 'segCount'),
                            reservedPad: new r.Reserved(r.uint16),
                            startCode: new r.LazyArray(r.uint16, 'segCount'),
                            idDelta: new r.LazyArray(r.int16, 'segCount'),
                            idRangeOffset: new r.LazyArray(r.uint16, 'segCount'),
                            glyphIndexArray: new r.LazyArray(r.uint16, function (t) {
                                return (t.length - t._currentOffset) / 2;
                            })
                        },
                        6: {
                            length: r.uint16,
                            language: r.uint16,
                            firstCode: r.uint16,
                            entryCount: r.uint16,
                            glyphIndices: new r.LazyArray(r.uint16, 'entryCount')
                        },
                        8: {
                            reserved: new r.Reserved(r.uint16),
                            length: r.uint32,
                            language: r.uint16,
                            is32: new r.LazyArray(r.uint8, 8192),
                            nGroups: r.uint32,
                            groups: new r.LazyArray(CmapGroup, 'nGroups')
                        },
                        10: {
                            reserved: new r.Reserved(r.uint16),
                            length: r.uint32,
                            language: r.uint32,
                            firstCode: r.uint32,
                            entryCount: r.uint32,
                            glyphIndices: new r.LazyArray(r.uint16, 'numChars')
                        },
                        12: {
                            reserved: new r.Reserved(r.uint16),
                            length: r.uint32,
                            language: r.uint32,
                            nGroups: r.uint32,
                            groups: new r.LazyArray(CmapGroup, 'nGroups')
                        },
                        13: {
                            reserved: new r.Reserved(r.uint16),
                            length: r.uint32,
                            language: r.uint32,
                            nGroups: r.uint32,
                            groups: new r.LazyArray(CmapGroup, 'nGroups')
                        }
                    });
                    var CmapEntry = new r.Struct({
                        platformID: r.uint16,
                        encodingID: r.uint16,
                        table: new r.Pointer(r.uint32, CmapSubtable, { type: 'parent', lazy: true })
                    });
                    var cmap = new r.Struct({
                        version: r.uint16,
                        numSubtables: r.uint16,
                        tables: new r.Array(CmapEntry, 'numSubtables')
                    });
                    var head = new r.Struct({
                        version: r.int32,
                        revision: r.int32,
                        checkSumAdjustment: r.uint32,
                        magicNumber: r.uint32,
                        flags: r.uint16,
                        unitsPerEm: r.uint16,
                        created: new r.Array(r.int32, 2),
                        modified: new r.Array(r.int32, 2),
                        xMin: r.int16,
                        yMin: r.int16,
                        xMax: r.int16,
                        yMax: r.int16,
                        macStyle: new r.Bitfield(r.uint16, ['bold', 'italic', 'underline', 'outline', 'shadow', 'condensed', 'extended']),
                        lowestRecPPEM: r.uint16,
                        fontDirectionHint: r.int16,
                        indexToLocFormat: r.int16,
                        glyphDataFormat: r.int16
                    });
                    var hhea = new r.Struct({
                        version: r.int32,
                        ascent: r.int16,
                        descent: r.int16,
                        lineGap: r.int16,
                        advanceWidthMax: r.uint16,
                        minLeftSideBearing: r.int16,
                        minRightSideBearing: r.int16,
                        xMaxExtent: r.int16,
                        caretSlopeRise: r.int16,
                        caretSlopeRun: r.int16,
                        caretOffset: r.int16,
                        reserved: new r.Reserved(r.int16, 4),
                        metricDataFormat: r.int16,
                        numberOfMetrics: r.uint16
                    });
                    var HmtxEntry = new r.Struct({
                        advance: r.uint16,
                        bearing: r.int16
                    });
                    var hmtx = new r.Struct({
                        metrics: new r.LazyArray(HmtxEntry, function (t) {
                            return t.parent.hhea.numberOfMetrics;
                        }),
                        bearings: new r.LazyArray(r.int16, function (t) {
                            return t.parent.maxp.numGlyphs - t.parent.hhea.numberOfMetrics;
                        })
                    });
                    var maxp = new r.Struct({
                        version: r.int32,
                        numGlyphs: r.uint16,
                        maxPoints: r.uint16,
                        maxContours: r.uint16,
                        maxComponentPoints: r.uint16,
                        maxComponentContours: r.uint16,
                        maxZones: r.uint16,
                        maxTwilightPoints: r.uint16,
                        maxStorage: r.uint16,
                        maxFunctionDefs: r.uint16,
                        maxInstructionDefs: r.uint16,
                        maxStackElements: r.uint16,
                        maxSizeOfInstructions: r.uint16,
                        maxComponentElements: r.uint16,
                        maxComponentDepth: r.uint16
                    });
                    var NameRecord = new r.Struct({
                        platformID: r.uint16,
                        encodingID: r.uint16,
                        languageID: r.uint16,
                        nameID: r.uint16,
                        length: r.uint16,
                        string: new r.Pointer(r.uint16, new r.String('length', function (t) {
                            return ENCODINGS[t.platformID][t.encodingID];
                        }), { type: 'parent', relativeTo: 'parent.stringOffset', allowNull: false })
                    });
                    var LangTagRecord = new r.Struct({
                        length: r.uint16,
                        tag: new r.Pointer(r.uint16, new r.String('length', 'utf16be'), { type: 'parent', relativeTo: 'stringOffset' })
                    });
                    var NameTable = new r.VersionedStruct(r.uint16, {
                        0: {
                            count: r.uint16,
                            stringOffset: r.uint16,
                            records: new r.Array(NameRecord, 'count')
                        },
                        1: {
                            count: r.uint16,
                            stringOffset: r.uint16,
                            records: new r.Array(NameRecord, 'count'),
                            langTagCount: r.uint16,
                            langTags: new r.Array(LangTagRecord, 'langTagCount')
                        }
                    });
                    var NAMES = ['copyright', 'fontFamily', 'fontSubfamily', 'uniqueSubfamily', 'fullName', 'version', 'postscriptName',
                        'trademark', 'manufacturer', 'designer', 'description', 'vendorURL', 'designerURL', 'license', 'licenseURL', null,
                        'preferredFamily', 'preferredSubfamily', 'compatibleFull', 'sampleText', 'postscriptCIDFontName', 'wwsFamilyName', 'wwsSubfamilyName'];
                    var ENCODINGS = [
                        ['utf16be', 'utf16be', 'utf16be', 'utf16be', 'utf16be', 'utf16be'],
                        ['macroman', 'shift-jis', 'big5', 'euc-kr', 'iso-8859-6', 'iso-8859-8', 'macgreek', 'maccyrillic', 'symbol', 'Devanagari', 'Gurmukhi', 'Gujarati', 'Oriya', 'Bengali', 'Tamil', 'Telugu', 'Kannada', 'Malayalam', 'Sinhalese', 'Burmese', 'Khmer', 'macthai', 'Laotian', 'Georgian', 'Armenian', 'gb-2312-80', 'Tibetan', 'Mongolian', 'Geez', 'maccyrillic', 'Vietnamese', 'Sindhi'],
                        ['ascii'],
                        ['symbol', 'utf16be', 'shift-jis', 'gb18030', 'big5', 'wansung', 'johab', null, null, null, 'ucs-4']
                    ];
                    var LANGUAGES = [
                        [], {
                            0: "English", 59: "Pashto",
                            1: "French", 60: "Kurdish",
                            2: "German", 61: "Kashmiri",
                            3: "Italian", 62: "Sindhi",
                            4: "Dutch", 63: "Tibetan",
                            5: "Swedish", 64: "Nepali",
                            6: "Spanish", 65: "Sanskrit",
                            7: "Danish", 66: "Marathi",
                            8: "Portuguese", 67: "Bengali",
                            9: "Norwegian", 68: "Assamese",
                            10: "Hebrew", 69: "Gujarati",
                            11: "Japanese", 70: "Punjabi",
                            12: "Arabic", 71: "Oriya",
                            13: "Finnish", 72: "Malayalam",
                            14: "Greek", 73: "Kannada",
                            15: "Icelandic", 74: "Tamil",
                            16: "Maltese", 75: "Telugu",
                            17: "Turkish", 76: "Sinhalese",
                            18: "Croatian", 77: "Burmese",
                            19: "Chinese (Traditional)", 78: "Khmer",
                            20: "Urdu", 79: "Lao",
                            21: "Hindi", 80: "Vietnamese",
                            22: "Thai", 81: "Indonesian",
                            23: "Korean", 82: "Tagalong",
                            24: "Lithuanian", 83: "Malay (Roman script)",
                            25: "Polish", 84: "Malay (Arabic script)",
                            26: "Hungarian", 85: "Amharic",
                            27: "Estonian", 86: "Tigrinya",
                            28: "Latvian", 87: "Galla",
                            29: "Sami", 88: "Somali",
                            30: "Faroese", 89: "Swahili",
                            31: "Farsi/Persian", 90: "Kinyarwanda/Ruanda",
                            32: "Russian", 91: "Rundi",
                            33: "Chinese (Simplified)", 92: "Nyanja/Chewa",
                            34: "Flemish", 93: "Malagasy",
                            35: "Irish Gaelic", 94: "Esperanto",
                            36: "Albanian", 128: "Welsh",
                            37: "Romanian", 129: "Basque",
                            38: "Czech", 130: "Catalan",
                            39: "Slovak", 131: "Latin",
                            40: "Slovenian", 132: "Quenchua",
                            41: "Yiddish", 133: "Guarani",
                            42: "Serbian", 134: "Aymara",
                            43: "Macedonian", 135: "Tatar",
                            44: "Bulgarian", 136: "Uighur",
                            45: "Ukrainian", 137: "Dzongkha",
                            46: "Byelorussian", 138: "Javanese (Roman script)",
                            47: "Uzbek", 139: "Sundanese (Roman script)",
                            48: "Kazakh", 140: "Galician",
                            49: "Azerbaijani (Cyrillic script)", 141: "Afrikaans",
                            50: "Azerbaijani (Arabic script)", 142: "Breton",
                            51: "Armenian", 143: "Inuktitut",
                            52: "Georgian", 144: "Scottish Gaelic",
                            53: "Moldavian", 145: "Manx Gaelic",
                            54: "Kirghiz", 146: "Irish Gaelic (with dot above)",
                            55: "Tajiki", 147: "Tongan",
                            56: "Turkmen", 148: "Greek (polytonic)",
                            57: "Mongolian (Mongolian script)", 149: "Greenlandic",
                            58: "Mongolian (Cyrillic script)", 150: "Azerbaijani (Roman script)"
                        },
                        [], {
                            0x0436: "Afrikaans", 0x0453: "Khmer",
                            0x041C: "Albanian", 0x0486: "K'iche",
                            0x0484: "Alsatian", 0x0487: "Kinyarwanda",
                            0x045E: "Amharic", 0x0441: "Kiswahili",
                            0x1401: "Arabic", 0x0457: "Konkani",
                            0x3C01: "Arabic", 0x0412: "Korean",
                            0x0C01: "Arabic", 0x0440: "Kyrgyz",
                            0x0801: "Arabic", 0x0454: "Lao",
                            0x2C01: "Arabic", 0x0426: "Latvian",
                            0x3401: "Arabic", 0x0427: "Lithuanian",
                            0x3001: "Arabic", 0x082E: "Lower Sorbian",
                            0x1001: "Arabic", 0x046E: "Luxembourgish",
                            0x1801: "Arabic", 0x042F: "Macedonian (FYROM)",
                            0x2001: "Arabic", 0x083E: "Malay",
                            0x4001: "Arabic", 0x043E: "Malay",
                            0x0401: "Arabic", 0x044C: "Malayalam",
                            0x2801: "Arabic", 0x043A: "Maltese",
                            0x1C01: "Arabic", 0x0481: "Maori",
                            0x3801: "Arabic", 0x047A: "Mapudungun",
                            0x2401: "Arabic", 0x044E: "Marathi",
                            0x042B: "Armenian", 0x047C: "Mohawk",
                            0x044D: "Assamese", 0x0450: "Mongolian (Cyrillic)",
                            0x082C: "Azeri (Cyrillic)", 0x0850: "Mongolian (Traditional)",
                            0x042C: "Azeri (Latin)", 0x0461: "Nepali",
                            0x046D: "Bashkir", 0x0414: "Norwegian (Bokmal)",
                            0x042D: "Basque", 0x0814: "Norwegian (Nynorsk)",
                            0x0423: "Belarusian", 0x0482: "Occitan",
                            0x0845: "Bengali", 0x0448: "Odia (formerly Oriya)",
                            0x0445: "Bengali", 0x0463: "Pashto",
                            0x201A: "Bosnian (Cyrillic)", 0x0415: "Polish",
                            0x141A: "Bosnian (Latin)", 0x0416: "Portuguese",
                            0x047E: "Breton", 0x0816: "Portuguese",
                            0x0402: "Bulgarian", 0x0446: "Punjabi",
                            0x0403: "Catalan", 0x046B: "Quechua",
                            0x0C04: "Chinese", 0x086B: "Quechua",
                            0x1404: "Chinese", 0x0C6B: "Quechua",
                            0x0804: "Chinese", 0x0418: "Romanian",
                            0x1004: "Chinese", 0x0417: "Romansh",
                            0x0404: "Chinese", 0x0419: "Russian",
                            0x0483: "Corsican", 0x243B: "Sami (Inari)",
                            0x041A: "Croatian", 0x103B: "Sami (Lule)",
                            0x101A: "Croatian (Latin)", 0x143B: "Sami (Lule)",
                            0x0405: "Czech", 0x0C3B: "Sami (Northern)",
                            0x0406: "Danish", 0x043B: "Sami (Northern)",
                            0x048C: "Dari", 0x083B: "Sami (Northern)",
                            0x0465: "Divehi", 0x203B: "Sami (Skolt)",
                            0x0813: "Dutch", 0x183B: "Sami (Southern)",
                            0x0413: "Dutch", 0x1C3B: "Sami (Southern)",
                            0x0C09: "English", 0x044F: "Sanskrit",
                            0x2809: "English", 0x1C1A: "Serbian (Cyrillic)",
                            0x1009: "English", 0x0C1A: "Serbian (Cyrillic)",
                            0x2409: "English", 0x181A: "Serbian (Latin)",
                            0x4009: "English", 0x081A: "Serbian (Latin)",
                            0x1809: "English", 0x046C: "Sesotho sa Leboa",
                            0x2009: "English", 0x0432: "Setswana",
                            0x4409: "English", 0x045B: "Sinhala",
                            0x1409: "English", 0x041B: "Slovak",
                            0x3409: "English", 0x0424: "Slovenian",
                            0x4809: "English", 0x2C0A: "Spanish",
                            0x1C09: "English", 0x400A: "Spanish",
                            0x2C09: "English", 0x340A: "Spanish",
                            0x0809: "English", 0x240A: "Spanish",
                            0x0409: "English", 0x140A: "Spanish",
                            0x3009: "English", 0x1C0A: "Spanish",
                            0x0425: "Estonian", 0x300A: "Spanish",
                            0x0438: "Faroese", 0x440A: "Spanish",
                            0x0464: "Filipino", 0x100A: "Spanish",
                            0x040B: "Finnish", 0x480A: "Spanish",
                            0x080C: "French", 0x080A: "Spanish",
                            0x0C0C: "French", 0x4C0A: "Spanish",
                            0x040C: "French", 0x180A: "Spanish",
                            0x140c: "French", 0x3C0A: "Spanish",
                            0x180C: "French", 0x280A: "Spanish",
                            0x100C: "French", 0x500A: "Spanish",
                            0x0462: "Frisian", 0x0C0A: "Spanish (Modern Sort)",
                            0x0456: "Galician", 0x040A: "Spanish (Traditional Sort)",
                            0x0437: "Georgian", 0x540A: "Spanish",
                            0x0C07: "German", 0x380A: "Spanish",
                            0x0407: "German", 0x200A: "Spanish",
                            0x1407: "German", 0x081D: "Sweden",
                            0x1007: "German", 0x041D: "Swedish",
                            0x0807: "German", 0x045A: "Syriac",
                            0x0408: "Greek", 0x0428: "Tajik (Cyrillic)",
                            0x046F: "Greenlandic", 0x085F: "Tamazight (Latin)",
                            0x0447: "Gujarati", 0x0449: "Tamil",
                            0x0468: "Hausa (Latin)", 0x0444: "Tatar",
                            0x040D: "Hebrew", 0x044A: "Telugu",
                            0x0439: "Hindi", 0x041E: "Thai",
                            0x040E: "Hungarian", 0x0451: "Tibetan",
                            0x040F: "Icelandic", 0x041F: "Turkish",
                            0x0470: "Igbo", 0x0442: "Turkmen",
                            0x0421: "Indonesian", 0x0480: "Uighur",
                            0x045D: "Inuktitut", 0x0422: "Ukrainian",
                            0x085D: "Inuktitut (Latin)", 0x042E: "Upper Sorbian",
                            0x083C: "Irish", 0x0420: "Urdu",
                            0x0434: "isiXhosa", 0x0843: "Uzbek (Cyrillic)",
                            0x0435: "isiZulu", 0x0443: "Uzbek (Latin)",
                            0x0410: "Italian", 0x042A: "Vietnamese",
                            0x0810: "Italian", 0x0452: "Welsh",
                            0x0411: "Japanese", 0x0488: "Wolof",
                            0x044B: "Kannada", 0x0485: "Yakut",
                            0x043F: "Kazakh", 0x0478: "Yi",
                            0x046A: "Yoruba"
                        }
                    ];
                    NameTable.process = function (stream) {
                        var records = {};
                        for (var i = 0, keys = Object.keys(this.records); i < keys.length; i++) {
                            var record = this.records[keys[i]];
                            var language = LANGUAGES[record.platformID][record.languageID];
                            if (language == null && this.langTags != null && record.languageID >= 0x8000) {
                                language = this.langTags[record.languageID - 0x8000].tag;
                            }
                            if (language == null) {
                                language = record.platformID + '-' + record.languageID;
                            }
                            if (record.nameID >= 256) {
                                if (records.fontFeatures == null) {
                                    records.fontFeatures = {};
                                }
                                var feature = records.fontFeatures[language] != null ? records.fontFeatures[language] : (records.fontFeatures[language] = {});
                                feature[record.nameID] = record.string;
                            }
                            else {
                                var key = NAMES[record.nameID] || record.nameID;
                                if (records[key] == null) {
                                    records[key] = {};
                                }
                                records[key][language] = record.string;
                            }
                        }
                        this.records = records;
                    };
                    NameTable.preEncode = function () {
                        if (Array.isArray(this.records))
                            return;
                        this.version = 0;
                        var records = [];
                        for (var key in this.records) {
                            var val = this.records[key];
                            if (key === 'fontFeatures')
                                continue;
                            records.push({
                                platformID: 3,
                                encodingID: 1,
                                languageID: 0x409,
                                nameID: NAMES.indexOf(key),
                                length: Buffer.byteLength(val.English, 'utf16le'),
                                string: val.English
                            });
                            if (key === 'postscriptName') {
                                records.push({
                                    platformID: 1,
                                    encodingID: 0,
                                    languageID: 0,
                                    nameID: NAMES.indexOf(key),
                                    length: val.English.length,
                                    string: val.English
                                });
                            }
                        }
                        this.records = records;
                        this.count = records.length;
                        this.stringOffset = localModule.localExports.size(this, null, false);
                    };
                    var OS2 = new r.VersionedStruct(r.uint16, {
                        header: {
                            xAvgCharWidth: r.int16,
                            usWeightClass: r.uint16,
                            usWidthClass: r.uint16,
                            fsType: new r.Bitfield(r.uint16, [
                                null, 'noEmbedding', 'viewOnly', 'editable', null, null, null, null, 'noSubsetting', 'bitmapOnly'
                            ]),
                            ySubscriptXSize: r.int16,
                            ySubscriptYSize: r.int16,
                            ySubscriptXOffset: r.int16,
                            ySubscriptYOffset: r.int16,
                            ySuperscriptXSize: r.int16,
                            ySuperscriptYSize: r.int16,
                            ySuperscriptXOffset: r.int16,
                            ySuperscriptYOffset: r.int16,
                            yStrikeoutSize: r.int16,
                            yStrikeoutPosition: r.int16,
                            sFamilyClass: r.int16,
                            panose: new r.Array(r.uint8, 10),
                            ulCharRange: new r.Array(r.uint32, 4),
                            vendorID: new r.String(4),
                            fsSelection: new r.Bitfield(r.uint16, [
                                'italic', 'underscore', 'negative', 'outlined', 'strikeout', 'bold', 'regular', 'useTypoMetrics', 'wws', 'oblique'
                            ]),
                            usFirstCharIndex: r.uint16,
                            usLastCharIndex: r.uint16
                        },
                        0: {},
                        1: {
                            typoAscender: r.int16,
                            typoDescender: r.int16,
                            typoLineGap: r.int16,
                            winAscent: r.uint16,
                            winDescent: r.uint16,
                            codePageRange: new r.Array(r.uint32, 2)
                        },
                        2: {
                            typoAscender: r.int16,
                            typoDescender: r.int16,
                            typoLineGap: r.int16,
                            winAscent: r.uint16,
                            winDescent: r.uint16,
                            codePageRange: new r.Array(r.uint32, 2),
                            xHeight: r.int16,
                            capHeight: r.int16,
                            defaultChar: r.uint16,
                            breakChar: r.uint16,
                            maxContent: r.uint16
                        },
                        5: {
                            typoAscender: r.int16,
                            typoDescender: r.int16,
                            typoLineGap: r.int16,
                            winAscent: r.uint16,
                            winDescent: r.uint16,
                            codePageRange: new r.Array(r.uint32, 2),
                            xHeight: r.int16,
                            capHeight: r.int16,
                            defaultChar: r.uint16,
                            breakChar: r.uint16,
                            maxContent: r.uint16,
                            usLowerOpticalPointSize: r.uint16,
                            usUpperOpticalPointSize: r.uint16
                        }
                    });
                    var versions = OS2.versions;
                    versions[3] = versions[4] = versions[2];
                    var post = new r.VersionedStruct(r.fixed32, {
                        header: {
                            italicAngle: r.fixed32,
                            underlinePosition: r.int16,
                            underlineThickness: r.int16,
                            isFixedPitch: r.uint32,
                            minMemType42: r.uint32,
                            maxMemType42: r.uint32,
                            minMemType1: r.uint32,
                            maxMemType1: r.uint32
                        },
                        1: {},
                        2: {
                            numberOfGlyphs: r.uint16,
                            glyphNameIndex: new r.Array(r.uint16, 'numberOfGlyphs'),
                            names: new r.Array(new r.String(r.uint8))
                        },
                        2.5: {
                            numberOfGlyphs: r.uint16,
                            offsets: new r.Array(r.uint8, 'numberOfGlyphs')
                        },
                        3: {},
                        4: {
                            map: new r.Array(r.uint32, function (t) {
                                return t.parent.maxp.numGlyphs;
                            })
                        }
                    });
                    var loca = new r.VersionedStruct('head.indexToLocFormat', {
                        0: {
                            offsets: new r.Array(r.uint16)
                        },
                        1: {
                            offsets: new r.Array(r.uint32)
                        }
                    });
                    loca.process = function () {
                        if (this.version === 0) {
                            for (var i = 0; i < this.offsets.length; i++) {
                                this.offsets[i] <<= 1;
                            }
                        }
                    };
                    loca.preEncode = function () {
                        if (this.version != null)
                            return;
                        this.version = this.offsets[this.offsets.length - 1] > 0xffff ? 1 : 0;
                        if (this.version === 0) {
                            for (var i = 0; i < this.offsets.length; i++) {
                                this.offsets[i] >>>= 1;
                            }
                        }
                    };
                    var glyf = new r.Array(new r.Buffer());
                    var tables = {};
                    tables.cmap = cmap;
                    tables.head = head;
                    tables.hhea = hhea;
                    tables.hmtx = hmtx;
                    tables.maxp = maxp;
                    tables.name = NameTable;
                    tables['OS/2'] = OS2;
                    tables.post = post;
                    tables.loca = loca;
                    tables.glyf = glyf;
                    var TableEntry = new r.Struct({
                        tag: new r.String(4),
                        checkSum: r.uint32,
                        offset: new r.Pointer(r.uint32, 'void', { type: 'global' }),
                        length: r.uint32
                    });
                    var Directory = new r.Struct({
                        tag: new r.String(4),
                        numTables: r.uint16,
                        searchRange: r.uint16,
                        entrySelector: r.uint16,
                        rangeShift: r.uint16,
                        tables: new r.Array(TableEntry, 'numTables')
                    });
                    Directory.process = function () {
                        var _this = this;
                        var tables = {};
                        Object.keys(this.tables).forEach(function (okey) {
                            var table = _this.tables[okey];
                            tables[table.tag] = table;
                        });
                        this.tables = tables;
                    };
                    Directory.preEncode = function (stream) {
                        var tables$$ = [];
                        for (var tag in this.tables) {
                            var table = this.tables[tag];
                            if (table) {
                                tables$$.push({
                                    tag: tag,
                                    checkSum: 0,
                                    offset: new r.VoidPointer(tables[tag], table),
                                    length: tables[tag].size(table)
                                });
                            }
                        }
                        this.tag = 'true';
                        this.numTables = tables$$.length;
                        this.tables = tables$$;
                        this.searchRange = Math.floor(Math.log(this.numTables) / Math.LN2) * 16;
                        this.entrySelector = Math.floor(this.searchRange / Math.LN2);
                        this.rangeShift = this.numTables * 16 - this.searchRange;
                    };
                    var CmapProcessor = function () {
                        function CmapProcessor(cmapTable) {
                            _classCallCheck(this, CmapProcessor);
                            this._characterSet = null;
                            var keys = Object.keys(cmapTable.tables);
                            for (var i = 0; i < keys.length; i++) {
                                cmap = cmapTable.tables[keys[i]];
                                if ((cmap.platformID === 0 && (cmap.encodingID === 4 || cmap.encodingID === 6)) || (cmap.platformID === 3 && cmap.encodingID === 10)) {
                                    this.cmap = cmap.table;
                                    return;
                                }
                            }
                            for (var i = 0; i < keys.length; i++) {
                                cmap = cmapTable.tables[keys[i]];
                                if (cmap.platformID === 0 || (cmap.platformID === 3 && cmap.encodingID === 1)) {
                                    this.cmap = cmap.table;
                                    return;
                                }
                            }
                            throw new Error("Could not find a unicode cmap");
                        }
                        _createClass(CmapProcessor, [{
                                key: 'lookup',
                                value: function lookup(codepoint) {
                                    var cmap = this.cmap;
                                    switch (cmap.version) {
                                        case 0:
                                            return cmap.codeMap.get(codepoint) || 0;
                                        case 4:
                                            {
                                                var min = 0;
                                                var max = cmap.segCount - 1;
                                                while (min <= max) {
                                                    var mid = min + max >> 1;
                                                    if (codepoint < cmap.startCode.get(mid)) {
                                                        max = mid - 1;
                                                    }
                                                    else if (codepoint > cmap.endCode.get(mid)) {
                                                        min = mid + 1;
                                                    }
                                                    else {
                                                        var rangeOffset = cmap.idRangeOffset.get(mid);
                                                        var gid = void 0;
                                                        if (rangeOffset === 0) {
                                                            gid = codepoint + cmap.idDelta.get(mid);
                                                        }
                                                        else {
                                                            var index = rangeOffset / 2 + (codepoint - cmap.startCode.get(mid)) - (cmap.segCount - mid);
                                                            gid = cmap.glyphIndexArray.get(index) || 0;
                                                            if (gid !== 0) {
                                                                gid += cmap.idDelta.get(mid);
                                                            }
                                                        }
                                                        return gid & 0xffff;
                                                    }
                                                }
                                                return 0;
                                            }
                                        case 8:
                                            throw new Error('TODO: cmap format 8');
                                        case 6:
                                        case 10:
                                            return cmap.glyphIndices.get(codepoint - cmap.firstCode) || 0;
                                        case 12:
                                        case 13:
                                            {
                                                var _min = 0;
                                                var _max = cmap.nGroups - 1;
                                                while (_min <= _max) {
                                                    var _mid = _min + _max >> 1;
                                                    var group = cmap.groups.get(_mid);
                                                    if (codepoint < group.startCharCode) {
                                                        _max = _mid - 1;
                                                    }
                                                    else if (codepoint > group.endCharCode) {
                                                        _min = _mid + 1;
                                                    }
                                                    else {
                                                        if (cmap.version === 12) {
                                                            return group.glyphID + (codepoint - group.startCharCode);
                                                        }
                                                        else {
                                                            return group.glyphID;
                                                        }
                                                    }
                                                }
                                                return 0;
                                            }
                                        case 14:
                                            throw new Error('TODO: cmap format 14');
                                        default:
                                            throw new Error('Unknown cmap format ' + cmap.version);
                                    }
                                }
                            }, {
                                key: 'getCharacterSet',
                                value: function getCharacterSet() {
                                    if (this._characterSet) {
                                        return this._characterSet;
                                    }
                                    var cmap = this.cmap;
                                    switch (cmap.version) {
                                        case 0:
                                            return this._characterSet = range(0, cmap.codeMap.length);
                                        case 4:
                                            {
                                                var res = [];
                                                var endCodes = cmap.endCode.toArray();
                                                for (var i = 0; i < endCodes.length; i++) {
                                                    var tail = endCodes[i] + 1;
                                                    var start = cmap.startCode.get(i);
                                                    res.push.apply(res, _toConsumableArray(range(start, tail)));
                                                }
                                                return this._characterSet = res;
                                            }
                                        case 8:
                                            throw new Error('TODO: cmap format 8');
                                        case 6:
                                        case 10:
                                            return this._characterSet = range(cmap.firstCode, cmap.firstCode + cmap.glyphIndices.length);
                                        case 12:
                                        case 13:
                                            {
                                                var res_1 = [];
                                                var ga = cmap.groups.toArray();
                                                for (var i = 0; i < ga.length; i++) {
                                                    var group = ga[i];
                                                    res_1.push.apply(res_1, _toConsumableArray(range(group.startCharCode, group.endCharCode + 1)));
                                                }
                                                return this._characterSet = res_1;
                                            }
                                        case 14:
                                            throw new Error('TODO: cmap format 14');
                                        default:
                                            throw new Error('Unknown cmap format ' + cmap.version);
                                    }
                                }
                            }]);
                        return CmapProcessor;
                    }();
                    function range(index, end) {
                        var range = [];
                        while (index < end) {
                            range.push(index++);
                        }
                        return range;
                    }
                    var UnicodeLayoutEngine = function () {
                        function UnicodeLayoutEngine(font) {
                            _classCallCheck(this, UnicodeLayoutEngine);
                            this.font = font;
                        }
                        _createClass(UnicodeLayoutEngine, [{
                                key: 'positionGlyphs',
                                value: function positionGlyphs(glyphs, positions) {
                                    var clusterStart = 0;
                                    var clusterEnd = 0;
                                    for (var index = 0; index < glyphs.length; index++) {
                                        var glyph = glyphs[index];
                                        if (glyph.isMark) {
                                            clusterEnd = index;
                                        }
                                        else {
                                            if (clusterStart !== clusterEnd) {
                                                this.positionCluster(glyphs, positions, clusterStart, clusterEnd);
                                            }
                                            clusterStart = clusterEnd = index;
                                        }
                                    }
                                    if (clusterStart !== clusterEnd) {
                                        this.positionCluster(glyphs, positions, clusterStart, clusterEnd);
                                    }
                                    return positions;
                                }
                            }, {
                                key: 'positionCluster',
                                value: function positionCluster(glyphs, positions, clusterStart, clusterEnd) {
                                    var base = glyphs[clusterStart];
                                    var baseBox = base.cbox.copy();
                                    if (base.codePoints.length > 1) {
                                        baseBox.minX += (base.codePoints.length - 1) * baseBox.width / base.codePoints.length;
                                    }
                                    var xOffset = -positions[clusterStart].xAdvance;
                                    var yOffset = 0;
                                    var yGap = this.font.unitsPerEm / 16;
                                    for (var index = clusterStart + 1; index <= clusterEnd; index++) {
                                        var mark = glyphs[index];
                                        var markBox = mark.cbox;
                                        var position = positions[index];
                                        var combiningClass = this.getCombiningClass(mark.codePoints[0]);
                                        if (combiningClass !== 'Not_Reordered') {
                                            position.xOffset = position.yOffset = 0;
                                            switch (combiningClass) {
                                                case 'Double_Above':
                                                case 'Double_Below':
                                                    position.xOffset += baseBox.minX - markBox.width / 2 - markBox.minX;
                                                    break;
                                                case 'Attached_Below_Left':
                                                case 'Below_Left':
                                                case 'Above_Left':
                                                    position.xOffset += baseBox.minX - markBox.minX;
                                                    break;
                                                case 'Attached_Above_Right':
                                                case 'Below_Right':
                                                case 'Above_Right':
                                                    position.xOffset += baseBox.maxX - markBox.width - markBox.minX;
                                                    break;
                                                default:
                                                    position.xOffset += baseBox.minX + (baseBox.width - markBox.width) / 2 - markBox.minX;
                                            }
                                            switch (combiningClass) {
                                                case 'Double_Below':
                                                case 'Below_Left':
                                                case 'Below':
                                                case 'Below_Right':
                                                case 'Attached_Below_Left':
                                                case 'Attached_Below':
                                                    if (combiningClass === 'Attached_Below_Left' || combiningClass === 'Attached_Below') {
                                                        baseBox.minY += yGap;
                                                    }
                                                    position.yOffset = -baseBox.minY - markBox.maxY;
                                                    baseBox.minY += markBox.height;
                                                    break;
                                                case 'Double_Above':
                                                case 'Above_Left':
                                                case 'Above':
                                                case 'Above_Right':
                                                case 'Attached_Above':
                                                case 'Attached_Above_Right':
                                                    if (combiningClass === 'Attached_Above' || combiningClass === 'Attached_Above_Right') {
                                                        baseBox.maxY += yGap;
                                                    }
                                                    position.yOffset = baseBox.maxY - markBox.minY;
                                                    baseBox.maxY += markBox.height;
                                                    break;
                                            }
                                            position.xAdvance = position.yAdvance = 0;
                                            position.xOffset += xOffset;
                                            position.yOffset += yOffset;
                                        }
                                        else {
                                            xOffset -= position.xAdvance;
                                            yOffset -= position.yAdvance;
                                        }
                                    }
                                    return;
                                }
                            }, {
                                key: 'getCombiningClass',
                                value: function getCombiningClass(codePoint) {
                                    var combiningClass = unicode.getCombiningClass(codePoint);
                                    if ((codePoint & ~0xff) === 0x0e00) {
                                        if (combiningClass === 'Not_Reordered') {
                                            switch (codePoint) {
                                                case 0x0e31:
                                                case 0x0e34:
                                                case 0x0e35:
                                                case 0x0e36:
                                                case 0x0e37:
                                                case 0x0e47:
                                                case 0x0e4c:
                                                case 0x0e3d:
                                                case 0x0e4e:
                                                    return 'Above_Right';
                                                case 0x0eb1:
                                                case 0x0eb4:
                                                case 0x0eb5:
                                                case 0x0eb6:
                                                case 0x0eb7:
                                                case 0x0ebb:
                                                case 0x0ecc:
                                                case 0x0ecd:
                                                    return 'Above';
                                                case 0x0ebc:
                                                    return 'Below';
                                            }
                                        }
                                        else if (codePoint === 0x0e3a) {
                                            return 'Below_Right';
                                        }
                                    }
                                    switch (combiningClass) {
                                        case 'CCC10':
                                        case 'CCC11':
                                        case 'CCC12':
                                        case 'CCC13':
                                        case 'CCC14':
                                        case 'CCC15':
                                        case 'CCC16':
                                        case 'CCC17':
                                        case 'CCC18':
                                        case 'CCC20':
                                        case 'CCC22':
                                            return 'Below';
                                        case 'CCC23':
                                            return 'Attached_Above';
                                        case 'CCC24':
                                            return 'Above_Right';
                                        case 'CCC25':
                                        case 'CCC19':
                                            return 'Above_Left';
                                        case 'CCC26':
                                            return 'Above';
                                        case 'CCC21':
                                            break;
                                        case 'CCC27':
                                        case 'CCC28':
                                        case 'CCC30':
                                        case 'CCC31':
                                        case 'CCC33':
                                        case 'CCC34':
                                        case 'CCC35':
                                        case 'CCC36':
                                            return 'Above';
                                        case 'CCC29':
                                        case 'CCC32':
                                            return 'Below';
                                        case 'CCC103':
                                            return 'Below_Right';
                                        case 'CCC107':
                                            return 'Above_Right';
                                        case 'CCC118':
                                            return 'Below';
                                        case 'CCC122':
                                            return 'Above';
                                        case 'CCC129':
                                        case 'CCC132':
                                            return 'Below';
                                        case 'CCC130':
                                            return 'Above';
                                    }
                                    return combiningClass;
                                }
                            }]);
                        return UnicodeLayoutEngine;
                    }();
                    var BBox = function () {
                        function BBox(farg1, farg2, farg3, farg4) {
                            var minX = arguments.length <= 0 || arguments[0] === undefined ? Infinity : arguments[0];
                            var minY = arguments.length <= 1 || arguments[1] === undefined ? Infinity : arguments[1];
                            var maxX = arguments.length <= 2 || arguments[2] === undefined ? -Infinity : arguments[2];
                            var maxY = arguments.length <= 3 || arguments[3] === undefined ? -Infinity : arguments[3];
                            _classCallCheck(this, BBox);
                            this.minX = minX;
                            this.minY = minY;
                            this.maxX = maxX;
                            this.maxY = maxY;
                        }
                        _createClass(BBox, [{
                                key: "addPoint",
                                value: function addPoint(x, y) {
                                    if (x < this.minX) {
                                        this.minX = x;
                                    }
                                    if (y < this.minY) {
                                        this.minY = y;
                                    }
                                    if (x > this.maxX) {
                                        this.maxX = x;
                                    }
                                    if (y > this.maxY) {
                                        this.maxY = y;
                                    }
                                }
                            }, {
                                key: "copy",
                                value: function copy() {
                                    return new BBox(this.minX, this.minY, this.maxX, this.maxY);
                                }
                            }, {
                                key: "width",
                                get: function get() {
                                    return this.maxX - this.minX;
                                }
                            }, {
                                key: "height",
                                get: function get() {
                                    return this.maxY - this.minY;
                                }
                            }]);
                        return BBox;
                    }();
                    var GlyphRun = function () {
                        function GlyphRun(glyphs, positions) {
                            _classCallCheck(this, GlyphRun);
                            this.glyphs = glyphs;
                            this.positions = positions;
                        }
                        _createClass(GlyphRun, [{
                                key: 'advanceWidth',
                                get: function get() {
                                    var _this = this;
                                    var width = 0;
                                    Object.keys(this.positions).forEach(function (okey) {
                                        width += _this.positions[okey].xAdvance;
                                    });
                                    return width;
                                }
                            }, {
                                key: 'advanceHeight',
                                get: function get() {
                                    var _this = this;
                                    var height = 0;
                                    Object.keys(this.positions).forEach(function (okey) {
                                        height += _this.positions[okey].yAdvance;
                                    });
                                    return height;
                                }
                            }, {
                                key: 'bbox',
                                get: function get() {
                                    var bbox = new BBox();
                                    var x = 0;
                                    var y = 0;
                                    for (var index = 0; index < this.glyphs.length; index++) {
                                        var glyph = this.glyphs[index];
                                        var p = this.positions[index];
                                        var b = glyph.bbox;
                                        bbox.addPoint(b.minX + x + p.xOffset, b.minY + y + p.yOffset);
                                        bbox.addPoint(b.maxX + x + p.xOffset, b.maxY + y + p.yOffset);
                                        x += p.xAdvance;
                                        y += p.yAdvance;
                                    }
                                    return bbox;
                                }
                            }]);
                        return GlyphRun;
                    }();
                    var GlyphPosition = function GlyphPosition() {
                        var xAdvance = arguments.length <= 0 || arguments[0] === undefined ? 0 : arguments[0];
                        var yAdvance = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];
                        var xOffset = arguments.length <= 2 || arguments[2] === undefined ? 0 : arguments[2];
                        var yOffset = arguments.length <= 3 || arguments[3] === undefined ? 0 : arguments[3];
                        _classCallCheck(this, GlyphPosition);
                        this.xAdvance = xAdvance;
                        this.yAdvance = yAdvance;
                        this.xOffset = xOffset;
                        this.yOffset = yOffset;
                    };
                    var UNICODE_SCRIPTS = {
                        Caucasian_Albanian: 'aghb',
                        Arabic: 'arab',
                        Imperial_Aramaic: 'armi',
                        Armenian: 'armn',
                        Avestan: 'avst',
                        Balinese: 'bali',
                        Bamum: 'bamu',
                        Bassa_Vah: 'bass',
                        Batak: 'batk',
                        Bengali: ['bng2', 'beng'],
                        Bopomofo: 'bopo',
                        Brahmi: 'brah',
                        Braille: 'brai',
                        Buginese: 'bugi',
                        Buhid: 'buhd',
                        Chakma: 'cakm',
                        Canadian_Aboriginal: 'cans',
                        Carian: 'cari',
                        Cham: 'cham',
                        Cherokee: 'cher',
                        Coptic: 'copt',
                        Cypriot: 'cprt',
                        Cyrillic: 'cyrl',
                        Devanagari: ['dev2', 'deva'],
                        Deseret: 'dsrt',
                        Duployan: 'dupl',
                        Egyptian_Hieroglyphs: 'egyp',
                        Elbasan: 'elba',
                        Ethiopic: 'ethi',
                        Georgian: 'geor',
                        Glagolitic: 'glag',
                        Gothic: 'goth',
                        Grantha: 'gran',
                        Greek: 'grek',
                        Gujarati: ['gjr2', 'gujr'],
                        Gurmukhi: ['gur2', 'guru'],
                        Hangul: 'hang',
                        Han: 'hani',
                        Hanunoo: 'hano',
                        Hebrew: 'hebr',
                        Hiragana: 'hira',
                        Pahawh_Hmong: 'hmng',
                        Katakana_Or_Hiragana: 'hrkt',
                        Old_Italic: 'ital',
                        Javanese: 'java',
                        Kayah_Li: 'kali',
                        Katakana: 'kana',
                        Kharoshthi: 'khar',
                        Khmer: 'khmr',
                        Khojki: 'khoj',
                        Kannada: ['knd2', 'knda'],
                        Kaithi: 'kthi',
                        Tai_Tham: 'lana',
                        Lao: 'lao ',
                        Latin: 'latn',
                        Lepcha: 'lepc',
                        Limbu: 'limb',
                        Linear_A: 'lina',
                        Linear_B: 'linb',
                        Lisu: 'lisu',
                        Lycian: 'lyci',
                        Lydian: 'lydi',
                        Mahajani: 'mahj',
                        Mandaic: 'mand',
                        Manichaean: 'mani',
                        Mende_Kikakui: 'mend',
                        Meroitic_Cursive: 'merc',
                        Meroitic_Hieroglyphs: 'mero',
                        Malayalam: ['mlm2', 'mlym'],
                        Modi: 'modi',
                        Mongolian: 'mong',
                        Mro: 'mroo',
                        Meetei_Mayek: 'mtei',
                        Myanmar: ['mym2', 'mymr'],
                        Old_North_Arabian: 'narb',
                        Nabataean: 'nbat',
                        Nko: 'nko ',
                        Ogham: 'ogam',
                        Ol_Chiki: 'olck',
                        Old_Turkic: 'orkh',
                        Oriya: 'orya',
                        Osmanya: 'osma',
                        Palmyrene: 'palm',
                        Pau_Cin_Hau: 'pauc',
                        Old_Permic: 'perm',
                        Phags_Pa: 'phag',
                        Inscriptional_Pahlavi: 'phli',
                        Psalter_Pahlavi: 'phlp',
                        Phoenician: 'phnx',
                        Miao: 'plrd',
                        Inscriptional_Parthian: 'prti',
                        Rejang: 'rjng',
                        Runic: 'runr',
                        Samaritan: 'samr',
                        Old_South_Arabian: 'sarb',
                        Saurashtra: 'saur',
                        Shavian: 'shaw',
                        Sharada: 'shrd',
                        Siddham: 'sidd',
                        Khudawadi: 'sind',
                        Sinhala: 'sinh',
                        Sora_Sompeng: 'sora',
                        Sundanese: 'sund',
                        Syloti_Nagri: 'sylo',
                        Syriac: 'syrc',
                        Tagbanwa: 'tagb',
                        Takri: 'takr',
                        Tai_Le: 'tale',
                        New_Tai_Lue: 'talu',
                        Tamil: 'taml',
                        Tai_Viet: 'tavt',
                        Telugu: ['tel2', 'telu'],
                        Tifinagh: 'tfng',
                        Tagalog: 'tglg',
                        Thaana: 'thaa',
                        Thai: 'thai',
                        Tibetan: 'tibt',
                        Tirhuta: 'tirh',
                        Ugaritic: 'ugar',
                        Vai: 'vai ',
                        Warang_Citi: 'wara',
                        Old_Persian: 'xpeo',
                        Cuneiform: 'xsux',
                        Yi: 'yi  ',
                        Inherited: 'zinh',
                        Common: 'zyyy',
                        Unknown: 'zzzz'
                    };
                    function forString(string) {
                        var len = string.length;
                        var idx = 0;
                        while (idx < len) {
                            var code = string.charCodeAt(idx++);
                            if (0xd800 <= code && code <= 0xdbff && idx < len) {
                                var next = string.charCodeAt(idx);
                                if (0xdc00 <= next && next <= 0xdfff) {
                                    idx++;
                                    code = ((code & 0x3FF) << 10) + (next & 0x3FF) + 0x10000;
                                }
                            }
                            var script = unicode.getScript(code);
                            if (script !== 'Common' && script !== 'Inherited' && script !== 'Unknown') {
                                return UNICODE_SCRIPTS[script];
                            }
                        }
                        return UNICODE_SCRIPTS.Unknown;
                    }
                    function forCodePoints(codePoints) {
                        for (var i = 0; i < codePoints.length; i++) {
                            var codePoint = codePoints[i];
                            var script = unicode.getScript(codePoint);
                            if (script !== 'Common' && script !== 'Inherited' && script !== 'Unknown') {
                                return UNICODE_SCRIPTS[script];
                            }
                        }
                        return UNICODE_SCRIPTS.Unknown;
                    }
                    function direction(script) {
                        return 'ltr';
                    }
                    var ShapingPlan = function () {
                        function ShapingPlan(font, script, language) {
                            _classCallCheck(this, ShapingPlan);
                            this.font = font;
                            this.script = script;
                            this.language = language;
                            this.direction = direction(script);
                            this.stages = [];
                            this.globalFeatures = {};
                            this.allFeatures = {};
                        }
                        _createClass(ShapingPlan, [{
                                key: '_addFeatures',
                                value: function _addFeatures(features) {
                                    var _this = this;
                                    var stage = this.stages[this.stages.length - 1];
                                    Object.keys(features).forEach(function (okey) {
                                        var feature = features[okey];
                                        if (!_this.allFeatures[feature]) {
                                            stage.push(feature);
                                            _this.allFeatures[feature] = true;
                                        }
                                    });
                                }
                            }, {
                                key: '_addGlobal',
                                value: function _addGlobal(features) {
                                    var _this = this;
                                    Object.keys(features).forEach(function (okey) {
                                        var feature = features[okey];
                                        _this.globalFeatures[feature] = true;
                                    });
                                }
                            }, {
                                key: 'add',
                                value: function add(arg) {
                                    var global = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];
                                    if (this.stages.length === 0) {
                                        this.stages.push([]);
                                    }
                                    if (typeof arg === 'string') {
                                        arg = [arg];
                                    }
                                    if (Array.isArray(arg)) {
                                        this._addFeatures(arg);
                                        if (global) {
                                            this._addGlobal(arg);
                                        }
                                    }
                                    else if ((typeof arg === 'undefined' ? 'undefined' : _typeof(arg)) === 'object') {
                                        var features = (arg.global || []).concat(arg.local || []);
                                        this._addFeatures(features);
                                        if (arg.global) {
                                            this._addGlobal(arg.global);
                                        }
                                    }
                                    else {
                                        throw new Error("Unsupported argument to ShapingPlan#add");
                                    }
                                }
                            }, {
                                key: 'addStage',
                                value: function addStage(arg, global) {
                                    if (typeof arg === 'function') {
                                        this.stages.push(arg, []);
                                    }
                                    else {
                                        this.stages.push([]);
                                        this.add(arg, global);
                                    }
                                }
                            }, {
                                key: 'assignGlobalFeatures',
                                value: function assignGlobalFeatures(glyphs) {
                                    var _this = this;
                                    Object.keys(glyphs).forEach(function (okey) {
                                        var glyph = glyphs[okey];
                                        for (var feature in _this.globalFeatures) {
                                            glyph.features[feature] = true;
                                        }
                                    });
                                }
                            }, {
                                key: 'process',
                                value: function process(processor, glyphs, positions) {
                                    var _this = this;
                                    processor.selectScript(this.script, this.language);
                                    Object.keys(this.stages).forEach(function (okey) {
                                        var stage = _this.stages[okey];
                                        if (typeof stage === 'function') {
                                            stage(glyphs, positions);
                                        }
                                        else if (stage.length > 0) {
                                            processor.applyFeatures(stage, glyphs, positions);
                                        }
                                    });
                                }
                            }]);
                        return ShapingPlan;
                    }();
                    var COMMON_FEATURES = ['ccmp', 'locl', 'rlig', 'mark', 'mkmk'];
                    var FRACTIONAL_FEATURES = ['frac', 'numr', 'dnom'];
                    var HORIZONTAL_FEATURES = ['calt', 'clig', 'liga', 'rclt', 'curs', 'kern'];
                    var DIRECTIONAL_FEATURES = {
                        ltr: ['ltra', 'ltrm'],
                        rtl: ['rtla', 'rtlm']
                    };
                    var DefaultShaper = function () {
                        function DefaultShaper() {
                            _classCallCheck(this, DefaultShaper);
                        }
                        _createClass(DefaultShaper, null, [{
                                key: 'plan',
                                value: function plan(_plan, glyphs, features) {
                                    this.planPreprocessing(_plan);
                                    this.planFeatures(_plan);
                                    this.planPostprocessing(_plan, features);
                                    _plan.assignGlobalFeatures(glyphs);
                                    this.assignFeatures(_plan, glyphs);
                                }
                            }, {
                                key: 'planPreprocessing',
                                value: function planPreprocessing(plan) {
                                    plan.add({
                                        global: DIRECTIONAL_FEATURES[plan.direction],
                                        local: FRACTIONAL_FEATURES
                                    });
                                }
                            }, {
                                key: 'planFeatures',
                                value: function planFeatures(plan) {
                                }
                            }, {
                                key: 'planPostprocessing',
                                value: function planPostprocessing(plan, userFeatures) {
                                    plan.add([].concat(COMMON_FEATURES, HORIZONTAL_FEATURES, _toConsumableArray(userFeatures)));
                                }
                            }, {
                                key: 'assignFeatures',
                                value: function assignFeatures(plan, glyphs) {
                                    var i = 0;
                                    while (i < glyphs.length) {
                                        var glyph = glyphs[i];
                                        if (glyph.codePoints[0] === 0x2044) {
                                            var start = i - 1;
                                            var end = i + 1;
                                            while (start >= 0 && unicode.isDigit(glyphs[start].codePoints[0])) {
                                                glyphs[start].features.numr = true;
                                                glyphs[start].features.frac = true;
                                                start--;
                                            }
                                            while (end < glyphs.length && unicode.isDigit(glyphs[end].codePoints[0])) {
                                                glyphs[end].features.dnom = true;
                                                glyphs[end].features.frac = true;
                                                end++;
                                            }
                                            glyph.features.frac = true;
                                            i = end - 1;
                                        }
                                        else {
                                            i++;
                                        }
                                    }
                                }
                            }]);
                        return DefaultShaper;
                    }();
                    var GlyphInfo = function GlyphInfo(id) {
                        var codePoints = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];
                        var features = arguments.length <= 2 || arguments[2] === undefined ? [] : arguments[2];
                        _classCallCheck(this, GlyphInfo);
                        this.id = id;
                        this.codePoints = codePoints;
                        this.isMark = this.codePoints.every(unicode.isMark);
                        this.isLigature = this.codePoints.length > 1;
                        this.features = {};
                        if (Array.isArray(features)) {
                            for (var i = 0; i < features.length; i++) {
                                var feature = features[i];
                                this.features[feature] = true;
                            }
                        }
                        else if ((typeof features === 'undefined' ? 'undefined' : _typeof(features)) === 'object') {
                            _Object$assign(this.features, features);
                        }
                        this.ligatureID = null;
                        this.ligatureComponent = null;
                        this.cursiveAttachment = null;
                        this.markAttachment = null;
                    };
                    var SHAPERS = {
                        latn: DefaultShaper,
                        DFLT: DefaultShaper
                    };
                    function choose(script) {
                        var shaper = SHAPERS[script];
                        if (shaper) {
                            return shaper;
                        }
                        return DefaultShaper;
                    }
                    var GlyphIterator = function () {
                        function GlyphIterator(glyphs, flags) {
                            _classCallCheck(this, GlyphIterator);
                            this.glyphs = glyphs;
                            this.reset(flags);
                        }
                        _createClass(GlyphIterator, [{
                                key: "reset",
                                value: function reset() {
                                    var flags = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
                                    this.flags = flags;
                                    this.index = 0;
                                }
                            }, {
                                key: "shouldIgnore",
                                value: function shouldIgnore(glyph, flags) {
                                    return flags.ignoreMarks && glyph.isMark || flags.ignoreBaseGlyphs && !glyph.isMark || flags.ignoreLigatures && glyph.isLigature;
                                }
                            }, {
                                key: "move",
                                value: function move(dir) {
                                    this.index += dir;
                                    while (0 <= this.index && this.index < this.glyphs.length && this.shouldIgnore(this.glyphs[this.index], this.flags)) {
                                        this.index += dir;
                                    }
                                    if (0 > this.index || this.index >= this.glyphs.length) {
                                        return null;
                                    }
                                    return this.glyphs[this.index];
                                }
                            }, {
                                key: "next",
                                value: function next() {
                                    return this.move(+1);
                                }
                            }, {
                                key: "prev",
                                value: function prev() {
                                    return this.move(-1);
                                }
                            }, {
                                key: "peek",
                                value: function peek() {
                                    var count = arguments.length <= 0 || arguments[0] === undefined ? 1 : arguments[0];
                                    var idx = this.index;
                                    var res = this.increment(count);
                                    this.index = idx;
                                    return res;
                                }
                            }, {
                                key: "peekIndex",
                                value: function peekIndex() {
                                    var count = arguments.length <= 0 || arguments[0] === undefined ? 1 : arguments[0];
                                    var idx = this.index;
                                    this.increment(count);
                                    var res = this.index;
                                    this.index = idx;
                                    return res;
                                }
                            }, {
                                key: "increment",
                                value: function increment() {
                                    var count = arguments.length <= 0 || arguments[0] === undefined ? 1 : arguments[0];
                                    var dir = count < 0 ? -1 : 1;
                                    count = Math.abs(count);
                                    while (count--) {
                                        this.move(dir);
                                    }
                                    return this.glyphs[this.index];
                                }
                            }, {
                                key: "cur",
                                get: function get() {
                                    return this.glyphs[this.index] || null;
                                }
                            }]);
                        return GlyphIterator;
                    }();
                    var DEFAULT_SCRIPTS = ['DFLT', 'dflt', 'latn'];
                    var OTProcessor = function () {
                        function OTProcessor(font, table) {
                            _classCallCheck(this, OTProcessor);
                            this.font = font;
                            this.table = table;
                            this.script = null;
                            this.scriptTag = null;
                            this.language = null;
                            this.languageTag = null;
                            this.features = {};
                            this.lookups = {};
                            this.selectScript();
                            this.glyphs = [];
                            this.positions = [];
                            this.ligatureID = 1;
                        }
                        _createClass(OTProcessor, [{
                                key: 'findScript',
                                value: function findScript(script) {
                                    if (this.table.scriptList == null) {
                                        return null;
                                    }
                                    if (!Array.isArray(script)) {
                                        script = [script];
                                    }
                                    for (var i = 0, keys1 = Object.keys(this.table.scriptList); i < keys1.length; i++) {
                                        var entry = this.table.scriptList[keys1[i]];
                                        for (var j = 0, keys2 = Object.keys(script); j < keys2.length; j++) {
                                            var s = script[keys2[j]];
                                            if (entry.tag === s) {
                                                return entry;
                                            }
                                        }
                                    }
                                    return null;
                                }
                            }, {
                                key: 'selectScript',
                                value: function selectScript(script, language) {
                                    var _this = this;
                                    var changed = false;
                                    var entry = void 0;
                                    if (!this.script || script !== this.scriptTag) {
                                        entry = this.findScript(script);
                                        if (script) {
                                            entry = this.findScript(script);
                                        }
                                        if (!entry) {
                                            entry = this.findScript(DEFAULT_SCRIPTS);
                                        }
                                        if (!entry) {
                                            return;
                                        }
                                        this.scriptTag = entry.tag;
                                        this.script = entry.script;
                                        this.direction = direction(script);
                                        this.language = null;
                                        changed = true;
                                    }
                                    if (!language && language !== this.langugeTag) {
                                        for (var i = 0, keys = Object.keys(this.script.langSysRecords); i < keys.length; i++) {
                                            var lang = this.script.langSysRecords[keys[i]];
                                            if (lang.tag === language) {
                                                this.language = lang.langSys;
                                                this.langugeTag = lang.tag;
                                                changed = true;
                                                break;
                                            }
                                        }
                                    }
                                    if (!this.language) {
                                        this.language = this.script.defaultLangSys;
                                    }
                                    if (changed) {
                                        this.features = {};
                                        if (this.language) {
                                            Object.keys(this.language.featureIndexes).forEach(function (okey) {
                                                var featureIndex = _this.language.featureIndexes[okey];
                                                var record = _this.table.featureList[featureIndex];
                                                _this.features[record.tag] = record.feature;
                                            });
                                        }
                                    }
                                }
                            }, {
                                key: 'lookupsForFeatures',
                                value: function lookupsForFeatures() {
                                    var userFeatures = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];
                                    var exclude = arguments[1];
                                    var lookups = [];
                                    for (var i = 0, keys1 = Object.keys(userFeatures); i < keys1.length; i++) {
                                        var tag = userFeatures[keys1[i]];
                                        var feature = this.features[tag];
                                        if (!feature) {
                                            continue;
                                        }
                                        for (var j = 0, keys2 = Object.keys(feature.lookupListIndexes); j < keys2.length; j++) {
                                            var lookupIndex = feature.lookupListIndexes[keys2[j]];
                                            if (exclude && exclude.indexOf(lookupIndex) !== -1) {
                                                continue;
                                            }
                                            lookups.push({
                                                feature: tag,
                                                index: lookupIndex,
                                                lookup: this.table.lookupList.get(lookupIndex)
                                            });
                                        }
                                    }
                                    lookups.sort(function (a, b) { return a.index - b.index; });
                                    return lookups;
                                }
                            }, {
                                key: 'applyFeatures',
                                value: function applyFeatures(userFeatures, glyphs, advances) {
                                    var lookups = this.lookupsForFeatures(userFeatures);
                                    this.applyLookups(lookups, glyphs, advances);
                                }
                            }, {
                                key: 'applyLookups',
                                value: function applyLookups(lookups, glyphs, positions) {
                                    this.glyphs = glyphs;
                                    this.positions = positions;
                                    this.glyphIterator = new GlyphIterator(glyphs);
                                    for (var i = 0, keys1 = Object.keys(lookups); i < keys1.length; i++) {
                                        var lk = lookups[keys1[i]], feature = lk.feature, lookup = lk.lookup;
                                        this.glyphIterator.reset(lookup.flags);
                                        while (this.glyphIterator.index < glyphs.length) {
                                            if (!(feature in this.glyphIterator.cur.features)) {
                                                this.glyphIterator.index++;
                                                continue;
                                            }
                                            for (var j = 0, keys2 = Object.keys(lookup.subTables); j < keys2.length; j++) {
                                                var table = lookup.subTables[keys2[j]];
                                                var res = this.applyLookup(lookup.lookupType, table);
                                                if (res) {
                                                    break;
                                                }
                                            }
                                            this.glyphIterator.index++;
                                        }
                                    }
                                }
                            }, {
                                key: 'applyLookup',
                                value: function applyLookup(lookup, table) {
                                    throw new Error("applyLookup must be implemented by subclasses");
                                }
                            }, {
                                key: 'applyLookupList',
                                value: function applyLookupList(lookupRecords) {
                                    var _this = this;
                                    var glyphIndex = this.glyphIterator.index;
                                    Object.keys(lookupRecords).forEach(function (okey1) {
                                        var lookupRecord = lookupRecords[okey1];
                                        _this.glyphIterator.index = glyphIndex + lookupRecord.sequenceIndex;
                                        var lookup = _this.table.lookupList.get(lookupRecord.lookupListIndex);
                                        Object.keys(lookup.subTables).forEach(function (okey2) {
                                            var table = lookup.subTables[okey2];
                                            _this.applyLookup(lookup.lookupType, table);
                                        });
                                    });
                                    this.glyphIterator.index = glyphIndex;
                                }
                            }, {
                                key: 'coverageIndex',
                                value: function coverageIndex(coverage, glyph) {
                                    if (glyph == null) {
                                        glyph = this.glyphIterator.cur.id;
                                    }
                                    switch (coverage.version) {
                                        case 1:
                                            return coverage.glyphs.indexOf(glyph);
                                        case 2:
                                            for (var i = 0, keys = Object.keys(coverage.rangeRecords); i < keys.length; i++) {
                                                var range = coverage.rangeRecords[keys[i]];
                                                if (range.start <= glyph && glyph <= range.end) {
                                                    return range.startCoverageIndex + glyph - range.start;
                                                }
                                            }
                                            break;
                                    }
                                    return -1;
                                }
                            }, {
                                key: 'match',
                                value: function match(sequenceIndex, sequence, fn, matched) {
                                    var pos = this.glyphIterator.index;
                                    var glyph = this.glyphIterator.increment(sequenceIndex);
                                    var idx = 0;
                                    while (idx < sequence.length && glyph && fn(sequence[idx], glyph.id)) {
                                        if (matched) {
                                            matched.push(this.glyphIterator.index);
                                        }
                                        idx++;
                                        glyph = this.glyphIterator.next();
                                    }
                                    this.glyphIterator.index = pos;
                                    if (idx < sequence.length) {
                                        return false;
                                    }
                                    return matched || true;
                                }
                            }, {
                                key: 'sequenceMatches',
                                value: function sequenceMatches(sequenceIndex, sequence) {
                                    return this.match(sequenceIndex, sequence, function (component, glyph) {
                                        return component === glyph;
                                    });
                                }
                            }, {
                                key: 'sequenceMatchIndices',
                                value: function sequenceMatchIndices(sequenceIndex, sequence) {
                                    return this.match(sequenceIndex, sequence, function (component, glyph) {
                                        return component === glyph;
                                    }, []);
                                }
                            }, {
                                key: 'coverageSequenceMatches',
                                value: function coverageSequenceMatches(sequenceIndex, sequence) {
                                    var _this = this;
                                    return this.match(sequenceIndex, sequence, function (coverage, glyph) {
                                        return _this.coverageIndex(coverage, glyph) >= 0;
                                    });
                                }
                            }, {
                                key: 'getClassID',
                                value: function getClassID(glyph, classDef) {
                                    switch (classDef.version) {
                                        case 1:
                                            var glyphID = classDef.startGlyph;
                                            for (var i = 0, keys = Object.keys(classDef.classValueArray); i < keys.length; i++) {
                                                var classID = classDef.classValueArray[keys[i]];
                                                if (glyph === glyphID++) {
                                                    return classID;
                                                }
                                            }
                                            break;
                                        case 2:
                                            for (var i = 0, keys = Object.keys(classDef.classRangeRecord); i < keys.length; i++) {
                                                var range = classDef.classRangeRecord[keys[i]];
                                                if (range.start <= glyph && glyph <= range.end) {
                                                    return range.class;
                                                }
                                            }
                                            break;
                                    }
                                    return -1;
                                }
                            }, {
                                key: 'classSequenceMatches',
                                value: function classSequenceMatches(sequenceIndex, sequence, classDef) {
                                    var _this2 = this;
                                    return this.match(sequenceIndex, sequence, function (classID, glyph) {
                                        return classID === _this2.getClassID(glyph, classDef);
                                    });
                                }
                            }, {
                                key: 'applyContext',
                                value: function applyContext(table) {
                                    switch (table.version) {
                                        case 1:
                                            var index = this.coverageIndex(table.coverage);
                                            if (index === -1) {
                                                return;
                                            }
                                            var set = table.ruleSets[index];
                                            for (var i = 0, keys = Object.keys(set); i < keys.length; i++) {
                                                var rule = set[keys[i]];
                                                if (this.sequenceMatches(1, rule.input)) {
                                                    return this.applyLookupList(rule.lookupRecords);
                                                }
                                            }
                                            break;
                                        case 2:
                                            if (this.coverageIndex(table.coverage) === -1) {
                                                return;
                                            }
                                            index = this.getClassID(this.glyphIterator.cur.id, table.classDef);
                                            if (index === -1) {
                                                return;
                                            }
                                            set = table.classSet[index];
                                            for (var i = 0, keys = Object.keys(set); i < keys.length; i++) {
                                                var rule = set[keys[i]];
                                                if (this.classSequenceMatches(1, rule.classes, table.classDef)) {
                                                    return this.applyLookupList(rule.lookupRecords);
                                                }
                                            }
                                            break;
                                        case 3:
                                            if (this.coverageSequenceMatches(0, table.coverages)) {
                                                return this.applyLookupList(table.lookupRecords);
                                            }
                                            break;
                                    }
                                }
                            }, {
                                key: 'applyChainingContext',
                                value: function applyChainingContext(table) {
                                    switch (table.version) {
                                        case 1:
                                            var index = this.coverageIndex(table.coverage);
                                            if (index === -1) {
                                                return;
                                            }
                                            var set = table.chainRuleSets[index];
                                            for (var i = 0, keys = Object.keys(set); i < keys.length; i++) {
                                                var rule = set[keys[i]];
                                                if (this.sequenceMatches(-rule.backtrack.length, rule.backtrack)
                                                    && this.sequenceMatches(1, rule.input)
                                                    && this.sequenceMatches(1 + rule.input.length, rule.lookahead)) {
                                                    return this.applyLookupList(rule.lookupRecords);
                                                }
                                            }
                                            break;
                                        case 2:
                                            if (this.coverageIndex(table.coverage) === -1) {
                                                return;
                                            }
                                            index = this.getClassID(this.glyphIterator.cur.id, table.inputClassDef);
                                            if (index === -1) {
                                                return;
                                            }
                                            var rules = table.chainClassSet[index];
                                            for (var i = 0, keys = Object.keys(rules); i < keys.length; i++) {
                                                var rule = rules[keys[i]];
                                                if (this.classSequenceMatches(-rule.backtrack.length, rule.backtrack, table.backtrackClassDef) &&
                                                    this.classSequenceMatches(1, rule.input, table.inputClassDef) &&
                                                    this.classSequenceMatches(1 + rule.input.length, rule.lookahead, table.lookaheadClassDef)) {
                                                    return this.applyLookupList(rule.lookupRecords);
                                                }
                                            }
                                            break;
                                        case 3:
                                            if (this.coverageSequenceMatches(-table.backtrackGlyphCount, table.backtrackCoverage) && this.coverageSequenceMatches(0, table.inputCoverage) && this.coverageSequenceMatches(table.inputGlyphCount, table.lookaheadCoverage)) {
                                                return this.applyLookupList(table.lookupRecords);
                                            }
                                            break;
                                    }
                                }
                            }]);
                        return OTProcessor;
                    }();
                    var OTLayoutEngine = function () {
                        function OTLayoutEngine(font) {
                            _classCallCheck(this, OTLayoutEngine);
                            this.font = font;
                            this.glyphInfos = null;
                            this.plan = null;
                        }
                        _createClass(OTLayoutEngine, [{
                                key: 'setup',
                                value: function setup(glyphs, features, script, language) {
                                    this.glyphInfos = glyphs.map(function (glyph) {
                                        return new GlyphInfo(glyph.id, [].concat(_toConsumableArray(glyph.codePoints)));
                                    });
                                    var shaper = choose(script);
                                    this.plan = new ShapingPlan(this.font, script, language);
                                    return shaper.plan(this.plan, this.glyphInfos, features);
                                }
                            }, {
                                key: 'substitute',
                                value: function substitute(glyphs) {
                                    var _this = this;
                                    return glyphs;
                                }
                            }, {
                                key: 'position',
                                value: function position(glyphs, positions) {
                                    if (this.plan.direction === 'rtl') {
                                        glyphs.reverse();
                                        positions.reverse();
                                    }
                                    return this.GPOSProcessor && this.GPOSProcessor.features;
                                }
                            }, {
                                key: 'cleanup',
                                value: function cleanup() {
                                    this.glyphInfos = null;
                                    this.plan = null;
                                }
                            }, {
                                key: 'getAvailableFeatures',
                                value: function getAvailableFeatures(script, language) {
                                    var features = [];
                                    return features;
                                }
                            }]);
                        return OTLayoutEngine;
                    }();
                    var LayoutEngine = function () {
                        function LayoutEngine(font) {
                            _classCallCheck(this, LayoutEngine);
                            this.font = font;
                            this.unicodeLayoutEngine = null;
                        }
                        _createClass(LayoutEngine, [{
                                key: 'layout',
                                value: function layout(string) {
                                    var features = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];
                                    var script = arguments[2];
                                    var language = arguments[3];
                                    if (typeof features === 'string') {
                                        script = features;
                                        language = script;
                                        features = [];
                                    }
                                    if (typeof string === 'string') {
                                        if (script == null) {
                                            script = forString(string);
                                        }
                                        var glyphs = this.font.glyphsForString(string);
                                    }
                                    else {
                                        if (script == null) {
                                            var codePoints = [];
                                            for (var i = 0, keys = Object.keys(string); i < keys.length; i++) {
                                                var glyph = string[keys[i]];
                                                codePoints.push.apply(codePoints, _toConsumableArray(glyph.codePoints));
                                            }
                                            script = forCodePoints(codePoints);
                                        }
                                        var glyphs = string;
                                    }
                                    if (glyphs.length === 0) {
                                        return new GlyphRun(glyphs, []);
                                    }
                                    glyphs = this.substitute(glyphs, features, script, language);
                                    var positions = this.position(glyphs, features, script, language);
                                    return new GlyphRun(glyphs, positions);
                                }
                            }, {
                                key: 'substitute',
                                value: function substitute(glyphs, features, script, language) {
                                    return glyphs;
                                }
                            }, {
                                key: 'position',
                                value: function position(glyphs, features, script, language) {
                                    var positions = glyphs.map(function (glyph) {
                                        return new GlyphPosition(glyph.advanceWidth);
                                    });
                                    var positioned = null;
                                    if (!positioned) {
                                        if (!this.unicodeLayoutEngine) {
                                            this.unicodeLayoutEngine = new UnicodeLayoutEngine(this.font);
                                        }
                                        this.unicodeLayoutEngine.positionGlyphs(glyphs, positions);
                                    }
                                    return positions;
                                }
                            }, {
                                key: 'getAvailableFeatures',
                                value: function getAvailableFeatures(script, language) {
                                    var features = [];
                                    return features;
                                }
                            }]);
                        return LayoutEngine;
                    }();
                    var Path = function () {
                        function Path() {
                            _classCallCheck(this, Path);
                            this.commands = [];
                            this._bbox = null;
                            this._cbox = null;
                        }
                        _createClass(Path, [{
                                key: 'toFunction',
                                value: function toFunction() {
                                    var cmds = this.commands.map(function (c) {
                                        return '  ctx.' + c.command + '(' + c.args.join(', ') + ');';
                                    });
                                    return new Function('ctx', cmds.join('\n'));
                                }
                            },
                            {}, {
                                key: 'cbox',
                                get: function get() {
                                    if (!this._cbox) {
                                        var cbox = new BBox();
                                        for (var j = 0, keys = Object.keys(this.commands); j < keys.length; j++) {
                                            var command = this.commands[j];
                                            for (var i = 0; i < command.args.length; i += 2) {
                                                cbox.addPoint(command.args[i], command.args[i + 1]);
                                            }
                                        }
                                        this._cbox = _Object$freeze(cbox);
                                    }
                                    return this._cbox;
                                }
                            }, {
                                key: 'bbox',
                                get: function get() {
                                    if (this._bbox) {
                                        return this._bbox;
                                    }
                                    var bbox = new BBox();
                                    var cx = 0, cy = 0;
                                    var f = function f(t) {
                                        return Math.pow(1 - t, 3) * p0[i] + 3 * Math.pow(1 - t, 2) * t * p1[i] + 3 * (1 - t) * Math.pow(t, 2) * p2[i] + Math.pow(t, 3) * p3[i];
                                    };
                                    for (var i = 0, keys = Object.keys(this.commands); i < keys.length; i++) {
                                        var c = this.commands[keys[i]];
                                        switch (c.command) {
                                            case 'moveTo':
                                            case 'lineTo':
                                                var _c$args = _slicedToArray(c.args, 2);
                                                var x = _c$args[0];
                                                var y = _c$args[1];
                                                bbox.addPoint(x, y);
                                                cx = x;
                                                cy = y;
                                                break;
                                            case 'quadraticCurveTo':
                                            case 'bezierCurveTo':
                                                if (c.command === 'quadraticCurveTo') {
                                                    var _c$args2 = _slicedToArray(c.args, 4);
                                                    var qp1x = _c$args2[0];
                                                    var qp1y = _c$args2[1];
                                                    var p3x = _c$args2[2];
                                                    var p3y = _c$args2[3];
                                                    var cp1x = cx + 2 / 3 * (qp1x - cx);
                                                    var cp1y = cy + 2 / 3 * (qp1y - cy);
                                                    var cp2x = p3x + 2 / 3 * (qp1x - p3x);
                                                    var cp2y = p3y + 2 / 3 * (qp1y - p3y);
                                                }
                                                else {
                                                    var _c$args3 = _slicedToArray(c.args, 6);
                                                    var cp1x = _c$args3[0];
                                                    var cp1y = _c$args3[1];
                                                    var cp2x = _c$args3[2];
                                                    var cp2y = _c$args3[3];
                                                    var p3x = _c$args3[4];
                                                    var p3y = _c$args3[5];
                                                }
                                                bbox.addPoint(p3x, p3y);
                                                var p0 = [cx, cy];
                                                var p1 = [cp1x, cp1y];
                                                var p2 = [cp2x, cp2y];
                                                var p3 = [p3x, p3y];
                                                for (var j = 0; j <= 1; j++) {
                                                    var b = 6 * p0[j] - 12 * p1[j] + 6 * p2[j];
                                                    var a = -3 * p0[j] + 9 * p1[j] - 9 * p2[j] + 3 * p3[j];
                                                    var i = j;
                                                    c = 3 * p1[j] - 3 * p0[j];
                                                    if (a === 0) {
                                                        if (b === 0) {
                                                            continue;
                                                        }
                                                        var t = -c / b;
                                                        if (0 < t && t < 1) {
                                                            if (j === 0) {
                                                                bbox.addPoint(f(t), bbox.maxY);
                                                            }
                                                            else if (j === 1) {
                                                                bbox.addPoint(bbox.maxX, f(t));
                                                            }
                                                        }
                                                        continue;
                                                    }
                                                    var b2ac = Math.pow(b, 2) - 4 * c * a;
                                                    if (b2ac < 0) {
                                                        continue;
                                                    }
                                                    var t1 = (-b + Math.sqrt(b2ac)) / (2 * a);
                                                    if (0 < t1 && t1 < 1) {
                                                        if (j === 0) {
                                                            bbox.addPoint(f(t1), bbox.maxY);
                                                        }
                                                        else if (j === 1) {
                                                            bbox.addPoint(bbox.maxX, f(t1));
                                                        }
                                                    }
                                                    var t2 = (-b - Math.sqrt(b2ac)) / (2 * a);
                                                    if (0 < t2 && t2 < 1) {
                                                        if (j === 0) {
                                                            bbox.addPoint(f(t2), bbox.maxY);
                                                        }
                                                        else if (j === 1) {
                                                            bbox.addPoint(bbox.maxX, f(t2));
                                                        }
                                                    }
                                                }
                                                cx = p3x;
                                                cy = p3y;
                                                break;
                                        }
                                    }
                                    return this._bbox = _Object$freeze(bbox);
                                }
                            }]);
                        return Path;
                    }();
                    var _arr = ['moveTo', 'lineTo', 'quadraticCurveTo', 'bezierCurveTo', 'closePath'];
                    var _loop = function _loop() {
                        var command = _arr[_i3];
                        Path.prototype[command] = function () {
                            for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
                                args[_key] = arguments[_key];
                            }
                            this._bbox = this._cbox = null;
                            this.commands.push({
                                command: command,
                                args: args
                            });
                            return this;
                        };
                    };
                    for (var _i3 = 0; _i3 < _arr.length; _i3++) {
                        _loop();
                    }
                    var StandardNames = ['.notdef', '.null', 'nonmarkingreturn', 'space', 'exclam', 'quotedbl', 'numbersign', 'dollar', 'percent', 'ampersand', 'quotesingle', 'parenleft', 'parenright', 'asterisk', 'plus', 'comma', 'hyphen', 'period', 'slash', 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'colon', 'semicolon', 'less', 'equal', 'greater', 'question', 'at', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'bracketleft', 'backslash', 'bracketright', 'asciicircum', 'underscore', 'grave', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'braceleft', 'bar', 'braceright', 'asciitilde', 'Adieresis', 'Aring', 'Ccedilla', 'Eacute', 'Ntilde', 'Odieresis', 'Udieresis', 'aacute', 'agrave', 'acircumflex', 'adieresis', 'atilde', 'aring', 'ccedilla', 'eacute', 'egrave', 'ecircumflex', 'edieresis', 'iacute', 'igrave', 'icircumflex', 'idieresis', 'ntilde', 'oacute', 'ograve', 'ocircumflex', 'odieresis', 'otilde', 'uacute', 'ugrave', 'ucircumflex', 'udieresis', 'dagger', 'degree', 'cent', 'sterling', 'section', 'bullet', 'paragraph', 'germandbls', 'registered', 'copyright', 'trademark', 'acute', 'dieresis', 'notequal', 'AE', 'Oslash', 'infinity', 'plusminus', 'lessequal', 'greaterequal', 'yen', 'mu', 'partialdiff', 'summation', 'product', 'pi', 'integral', 'ordfeminine', 'ordmasculine', 'Omega', 'ae', 'oslash', 'questiondown', 'exclamdown', 'logicalnot', 'radical', 'florin', 'approxequal', 'Delta', 'guillemotleft', 'guillemotright', 'ellipsis', 'nonbreakingspace', 'Agrave', 'Atilde', 'Otilde', 'OE', 'oe', 'endash', 'emdash', 'quotedblleft', 'quotedblright', 'quoteleft', 'quoteright', 'divide', 'lozenge', 'ydieresis', 'Ydieresis', 'fraction', 'currency', 'guilsinglleft', 'guilsinglright', 'fi', 'fl', 'daggerdbl', 'periodcentered', 'quotesinglbase', 'quotedblbase', 'perthousand', 'Acircumflex', 'Ecircumflex', 'Aacute', 'Edieresis', 'Egrave', 'Iacute', 'Icircumflex', 'Idieresis', 'Igrave', 'Oacute', 'Ocircumflex', 'apple', 'Ograve', 'Uacute', 'Ucircumflex', 'Ugrave', 'dotlessi', 'circumflex', 'tilde', 'macron', 'breve', 'dotaccent', 'ring', 'cedilla', 'hungarumlaut', 'ogonek', 'caron', 'Lslash', 'lslash', 'Scaron', 'scaron', 'Zcaron', 'zcaron', 'brokenbar', 'Eth', 'eth', 'Yacute', 'yacute', 'Thorn', 'thorn', 'minus', 'multiply', 'onesuperior', 'twosuperior', 'threesuperior', 'onehalf', 'onequarter', 'threequarters', 'franc', 'Gbreve', 'gbreve', 'Idotaccent', 'Scedilla', 'scedilla', 'Cacute', 'cacute', 'Ccaron', 'ccaron', 'dcroat'];
                    var _class$1;
                    function _applyDecoratedDescriptor$1(target, property, decorators, descriptor, context) {
                        var desc = {};
                        Object['ke' + 'ys'](descriptor).forEach(function (key) {
                            desc[key] = descriptor[key];
                        });
                        desc.enumerable = !!desc.enumerable;
                        desc.configurable = !!desc.configurable;
                        if ('value' in desc || desc.initializer) {
                            desc.writable = true;
                        }
                        desc = decorators.slice().reverse().reduce(function (desc, decorator) {
                            return decorator(target, property, desc) || desc;
                        }, desc);
                        if (context && desc.initializer !== void 0) {
                            desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
                            desc.initializer = undefined;
                        }
                        if (desc.initializer === void 0) {
                            Object['define' + 'Property'](target, property, desc);
                            desc = null;
                        }
                        return desc;
                    }
                    var Glyph = (_class$1 = function () {
                        function Glyph(id, codePoints, font) {
                            _classCallCheck(this, Glyph);
                            this.id = id;
                            this.codePoints = codePoints;
                            this._font = font;
                            this.isMark = this.codePoints.every(unicode.isMark);
                            this.isLigature = this.codePoints.length > 1;
                        }
                        _createClass(Glyph, [
                            {
                                key: '_getPath',
                                value: function _getPath() {
                                    return new Path();
                                }
                            },
                            {
                                key: '_getCBox',
                                value: function _getCBox() {
                                    return this.path.cbox;
                                }
                            },
                            {
                                key: '_getBBox',
                                value: function _getBBox() {
                                    return this.path.bbox;
                                }
                            },
                            {
                                key: '_getTableMetrics',
                                value: function _getTableMetrics(table) {
                                    if (this.id < table.metrics.length) {
                                        return table.metrics.get(this.id);
                                    }
                                    var metric = table.metrics.get(table.metrics.length - 1);
                                    var res = {
                                        advance: metric ? metric.advance : 0,
                                        bearing: table.bearings.get(this.id - table.metrics.length) || 0
                                    };
                                    return res;
                                }
                            }, {
                                key: '_getMetrics',
                                value: function _getMetrics(cbox) {
                                    if (this._metrics) {
                                        return this._metrics;
                                    }
                                    var _getTableMetrics2 = this._getTableMetrics(this._font.hmtx);
                                    var advanceWidth = _getTableMetrics2.advance;
                                    var leftBearing = _getTableMetrics2.bearing;
                                    var os2 = void 0;
                                    if (typeof cbox === 'undefined' || cbox === null) {
                                        cbox = this.cbox;
                                    }
                                    if ((os2 = this._font['OS/2']) && os2.version > 0) {
                                        var advanceHeight = Math.abs(os2.typoAscender - os2.typoDescender);
                                        var topBearing = os2.typoAscender - cbox.maxY;
                                    }
                                    else {
                                        var hhea = this._font.hhea;
                                        var advanceHeight = Math.abs(hhea.ascent - hhea.descent);
                                        var topBearing = hhea.ascent - cbox.maxY;
                                    }
                                    return this._metrics = { advanceWidth: advanceWidth, advanceHeight: advanceHeight, leftBearing: leftBearing, topBearing: topBearing };
                                }
                            }, {
                                key: '_getName',
                                value: function _getName() {
                                    var post = this._font.post;
                                    if (!post) {
                                        return null;
                                    }
                                    switch (post.version) {
                                        case 1:
                                            return StandardNames[this.id];
                                        case 2:
                                            var id = post.glyphNameIndex[this.id];
                                            if (id < StandardNames.length) {
                                                return StandardNames[id];
                                            }
                                            return post.names[id - StandardNames.length];
                                        case 2.5:
                                            return StandardNames[this.id + post.offsets[this.id]];
                                        case 4:
                                            return String.fromCharCode(post.map[this.id]);
                                    }
                                }
                            },
                            {
                                key: 'cbox',
                                get: function get() {
                                    return this._getCBox();
                                }
                            }, {
                                key: 'bbox',
                                get: function get() {
                                    return this._getBBox();
                                }
                            }, {
                                key: 'path',
                                get: function get() {
                                    return this._getPath();
                                }
                            }, {
                                key: 'advanceWidth',
                                get: function get() {
                                    return this._getMetrics().advanceWidth;
                                }
                            }, {
                                key: 'advanceHeight',
                                get: function get() {
                                    return this._getMetrics().advanceHeight;
                                }
                            }, {
                                key: 'ligatureCaretPositions',
                                get: function get() { }
                            }, {
                                key: 'name',
                                get: function get() {
                                    return this._getName();
                                }
                            }
                        ]);
                        return Glyph;
                    }(), (_applyDecoratedDescriptor$1(_class$1.prototype, 'cbox', [cache], _Object$getOwnPropertyDescriptor(_class$1.prototype, 'cbox'), _class$1.prototype), _applyDecoratedDescriptor$1(_class$1.prototype, 'bbox', [cache], _Object$getOwnPropertyDescriptor(_class$1.prototype, 'bbox'), _class$1.prototype), _applyDecoratedDescriptor$1(_class$1.prototype, 'path', [cache], _Object$getOwnPropertyDescriptor(_class$1.prototype, 'path'), _class$1.prototype), _applyDecoratedDescriptor$1(_class$1.prototype, 'advanceWidth', [cache], _Object$getOwnPropertyDescriptor(_class$1.prototype, 'advanceWidth'), _class$1.prototype), _applyDecoratedDescriptor$1(_class$1.prototype, 'advanceHeight', [cache], _Object$getOwnPropertyDescriptor(_class$1.prototype, 'advanceHeight'), _class$1.prototype), _applyDecoratedDescriptor$1(_class$1.prototype, 'name', [cache], _Object$getOwnPropertyDescriptor(_class$1.prototype, 'name'), _class$1.prototype)), _class$1);
                    var GlyfHeader = new r.Struct({
                        numberOfContours: r.int16,
                        xMin: r.int16,
                        yMin: r.int16,
                        xMax: r.int16,
                        yMax: r.int16
                    });
                    var ON_CURVE = 1 << 0;
                    var X_SHORT_VECTOR = 1 << 1;
                    var Y_SHORT_VECTOR = 1 << 2;
                    var REPEAT = 1 << 3;
                    var SAME_X = 1 << 4;
                    var SAME_Y = 1 << 5;
                    var ARG_1_AND_2_ARE_WORDS = 1 << 0;
                    var WE_HAVE_A_SCALE = 1 << 3;
                    var MORE_COMPONENTS = 1 << 5;
                    var WE_HAVE_AN_X_AND_Y_SCALE = 1 << 6;
                    var WE_HAVE_A_TWO_BY_TWO = 1 << 7;
                    var WE_HAVE_INSTRUCTIONS = 1 << 8;
                    var Point = function () {
                        function Point(onCurve, endContour, farg1, farg2) {
                            var x = arguments.length <= 2 || arguments[2] === undefined ? 0 : arguments[2];
                            var y = arguments.length <= 3 || arguments[3] === undefined ? 0 : arguments[3];
                            _classCallCheck(this, Point);
                            this.onCurve = onCurve;
                            this.endContour = endContour;
                            this.x = x;
                            this.y = y;
                        }
                        _createClass(Point, [{
                                key: 'copy',
                                value: function copy() {
                                    return new Point(this.onCurve, this.endContour, this.x, this.y);
                                }
                            }]);
                        return Point;
                    }();
                    var Component = function Component(glyphID, dx, dy) {
                        _classCallCheck(this, Component);
                        this.glyphID = glyphID;
                        this.dx = dx;
                        this.dy = dy;
                        this.pos = 0;
                        this.scale = this.xScale = this.yScale = this.scale01 = this.scale10 = null;
                    };
                    var TTFGlyph = function (_Glyph) {
                        _inherits(TTFGlyph, _Glyph);
                        function TTFGlyph() {
                            _classCallCheck(this, TTFGlyph);
                            return _possibleConstructorReturn(this, (TTFGlyph.__proto__ || _Object$getPrototypeOf(TTFGlyph)).apply(this, arguments));
                        }
                        _createClass(TTFGlyph, [{
                                key: '_getCBox',
                                value: function _getCBox(internal) {
                                    var stream = this._font._getTableStream('glyf');
                                    stream.pos += this._font.loca.offsets[this.id];
                                    var glyph = GlyfHeader.decode(stream);
                                    var cbox = new BBox(glyph.xMin, glyph.yMin, glyph.xMax, glyph.yMax);
                                    return _Object$freeze(cbox);
                                }
                            }, {
                                key: '_parseGlyphCoord',
                                value: function _parseGlyphCoord(stream, prev, short, same) {
                                    if (short) {
                                        var val = stream.readUInt8();
                                        if (!same) {
                                            val = -val;
                                        }
                                        val += prev;
                                    }
                                    else {
                                        if (same) {
                                            var val = prev;
                                        }
                                        else {
                                            var val = prev + stream.readInt16BE();
                                        }
                                    }
                                    return val;
                                }
                            }, {
                                key: '_decode',
                                value: function _decode() {
                                    var glyfPos = this._font.loca.offsets[this.id];
                                    var nextPos = this._font.loca.offsets[this.id + 1];
                                    if (glyfPos === nextPos) {
                                        return null;
                                    }
                                    var stream = this._font._getTableStream('glyf');
                                    stream.pos += glyfPos;
                                    var startPos = stream.pos;
                                    var glyph = GlyfHeader.decode(stream);
                                    if (glyph.numberOfContours > 0) {
                                        this._decodeSimple(glyph, stream);
                                    }
                                    else if (glyph.numberOfContours < 0) {
                                        this._decodeComposite(glyph, stream, startPos);
                                    }
                                    return glyph;
                                }
                            }, {
                                key: '_decodeSimple',
                                value: function _decodeSimple(glyph, stream) {
                                    glyph.points = [];
                                    var endPtsOfContours = new r.Array(r.uint16, glyph.numberOfContours).decode(stream);
                                    var instructions = new r.Array(r.uint8, r.uint16).decode(stream);
                                    var flags = [];
                                    var numCoords = endPtsOfContours[endPtsOfContours.length - 1] + 1;
                                    while (flags.length < numCoords) {
                                        var flag = stream.readUInt8();
                                        flags.push(flag);
                                        if (flag & REPEAT) {
                                            var count = stream.readUInt8();
                                            for (var j = 0; j < count; j++) {
                                                flags.push(flag);
                                            }
                                        }
                                    }
                                    for (var i = 0; i < flags.length; i++) {
                                        var flag = flags[i];
                                        var point = new Point(!!(flag & ON_CURVE), endPtsOfContours.indexOf(i) >= 0, 0, 0);
                                        glyph.points.push(point);
                                    }
                                    var px = 0;
                                    for (var i = 0; i < flags.length; i++) {
                                        var flag = flags[i];
                                        glyph.points[i].x = px = this._parseGlyphCoord(stream, px, flag & X_SHORT_VECTOR, flag & SAME_X);
                                    }
                                    var py = 0;
                                    for (var i = 0; i < flags.length; i++) {
                                        var flag = flags[i];
                                        glyph.points[i].y = py = this._parseGlyphCoord(stream, py, flag & Y_SHORT_VECTOR, flag & SAME_Y);
                                    }
                                    return;
                                }
                            }, {
                                key: '_decodeComposite',
                                value: function _decodeComposite(glyph, stream) {
                                    var offset = arguments.length <= 2 || arguments[2] === undefined ? 0 : arguments[2];
                                    glyph.components = [];
                                    var haveInstructions = false;
                                    var flags = MORE_COMPONENTS;
                                    while (flags & MORE_COMPONENTS) {
                                        flags = stream.readUInt16BE();
                                        var gPos = stream.pos - offset;
                                        var glyphID = stream.readUInt16BE();
                                        if (!haveInstructions) {
                                            haveInstructions = (flags & WE_HAVE_INSTRUCTIONS) !== 0;
                                        }
                                        if (flags & ARG_1_AND_2_ARE_WORDS) {
                                            var dx = stream.readInt16BE();
                                            var dy = stream.readInt16BE();
                                        }
                                        else {
                                            var dx = stream.readInt8();
                                            var dy = stream.readInt8();
                                        }
                                        var component = new Component(glyphID, dx, dy);
                                        component.pos = gPos;
                                        component.scaleX = component.scaleY = 1;
                                        component.scale01 = component.scale10 = 0;
                                        if (flags & WE_HAVE_A_SCALE) {
                                            component.scaleX = component.scaleY = (stream.readUInt8() << 24 | stream.readUInt8() << 16) / 1073741824;
                                        }
                                        else if (flags & WE_HAVE_AN_X_AND_Y_SCALE) {
                                            component.scaleX = (stream.readUInt8() << 24 | stream.readUInt8() << 16) / 1073741824;
                                            component.scaleY = (stream.readUInt8() << 24 | stream.readUInt8() << 16) / 1073741824;
                                        }
                                        else if (flags & WE_HAVE_A_TWO_BY_TWO) {
                                            component.scaleX = (stream.readUInt8() << 24 | stream.readUInt8() << 16) / 1073741824;
                                            component.scale01 = (stream.readUInt8() << 24 | stream.readUInt8() << 16) / 1073741824;
                                            component.scale10 = (stream.readUInt8() << 24 | stream.readUInt8() << 16) / 1073741824;
                                            component.scaleY = (stream.readUInt8() << 24 | stream.readUInt8() << 16) / 1073741824;
                                        }
                                        glyph.components.push(component);
                                    }
                                    return haveInstructions;
                                }
                            }, {
                                key: '_getPhantomPoints',
                                value: function _getPhantomPoints(glyph) {
                                    var cbox = this._getCBox(true);
                                    if (this._metrics == null) {
                                        this._metrics = Glyph.prototype._getMetrics.call(this, cbox);
                                    }
                                    var _metrics = this._metrics;
                                    var advanceWidth = _metrics.advanceWidth;
                                    var advanceHeight = _metrics.advanceHeight;
                                    var leftBearing = _metrics.leftBearing;
                                    var topBearing = _metrics.topBearing;
                                    return [new Point(false, true, glyph.xMin - leftBearing, 0), new Point(false, true, glyph.xMin - leftBearing + advanceWidth, 0), new Point(false, true, 0, glyph.yMax + topBearing), new Point(false, true, 0, glyph.yMax + topBearing + advanceHeight)];
                                }
                            }, {
                                key: '_getContours',
                                value: function _getContours() {
                                    var glyph = this._decode();
                                    if (!glyph) {
                                        return [];
                                    }
                                    if (glyph.numberOfContours < 0) {
                                        var points = [];
                                        for (var i = 0, keys = Object.keys(glyph.components); i < keys.length; i++) {
                                            var component = glyph.components[keys[i]];
                                            for (var j = 0, keys2 = Object.keys(glyph.points); j < keys2.length; j++) {
                                                var point = glyph.points[keys[j]];
                                                points.push(new Point(point.onCurve, point.endContour, point.x + component.dx, point.y + component.dy));
                                            }
                                        }
                                    }
                                    else {
                                        var points = glyph.points;
                                    }
                                    var contours = [];
                                    var cur = [];
                                    for (var k = 0; k < points.length; k++) {
                                        var point = points[k];
                                        cur.push(point);
                                        if (point.endContour) {
                                            contours.push(cur);
                                            cur = [];
                                        }
                                    }
                                    return contours;
                                }
                            }, {
                                key: '_getMetrics',
                                value: function _getMetrics() {
                                    if (this._metrics) {
                                        return this._metrics;
                                    }
                                    var cbox = this._getCBox(true);
                                    _get(TTFGlyph.prototype.__proto__ || _Object$getPrototypeOf(TTFGlyph.prototype), '_getMetrics', this).call(this, cbox);
                                    return this._metrics;
                                }
                            }, {
                                key: '_getPath',
                                value: function _getPath() {
                                    var contours = this._getContours();
                                    var path = new Path();
                                    for (var i = 0; i < contours.length; i++) {
                                        var contour = contours[i];
                                        var firstPt = contour[0];
                                        var lastPt = contour[contour.length - 1];
                                        var start = 0;
                                        if (firstPt.onCurve) {
                                            var curvePt = null;
                                            start = 1;
                                        }
                                        else {
                                            if (lastPt.onCurve) {
                                                firstPt = lastPt;
                                            }
                                            else {
                                                firstPt = new Point(false, false, (firstPt.x + lastPt.x) / 2, (firstPt.y + lastPt.y) / 2);
                                            }
                                            var curvePt = firstPt;
                                        }
                                        path.moveTo(firstPt.x, firstPt.y);
                                        for (var j = start; j < contour.length; j++) {
                                            var pt = contour[j];
                                            var prevPt = j === 0 ? firstPt : contour[j - 1];
                                            if (prevPt.onCurve && pt.onCurve) {
                                                path.lineTo(pt.x, pt.y);
                                            }
                                            else if (prevPt.onCurve && !pt.onCurve) {
                                                var curvePt = pt;
                                            }
                                            else if (!prevPt.onCurve && !pt.onCurve) {
                                                var midX = (prevPt.x + pt.x) / 2;
                                                var midY = (prevPt.y + pt.y) / 2;
                                                path.quadraticCurveTo(prevPt.x, prevPt.y, midX, midY);
                                                var curvePt = pt;
                                            }
                                            else if (!prevPt.onCurve && pt.onCurve) {
                                                path.quadraticCurveTo(curvePt.x, curvePt.y, pt.x, pt.y);
                                                var curvePt = null;
                                            }
                                            else {
                                                throw new Error("Unknown TTF path state");
                                            }
                                        }
                                        if (firstPt !== lastPt) {
                                            if (curvePt) {
                                                path.quadraticCurveTo(curvePt.x, curvePt.y, firstPt.x, firstPt.y);
                                            }
                                            else {
                                                path.lineTo(firstPt.x, firstPt.y);
                                            }
                                        }
                                    }
                                    path.closePath();
                                    return path;
                                }
                            }]);
                        return TTFGlyph;
                    }(Glyph);
                    var Subset = function () {
                        function Subset(font) {
                            _classCallCheck(this, Subset);
                            this.font = font;
                            this.glyphs = [];
                            this.mapping = {};
                            this.includeGlyph(0);
                        }
                        _createClass(Subset, [{
                                key: 'includeGlyph',
                                value: function includeGlyph(glyph) {
                                    if ((typeof glyph === 'undefined' ? 'undefined' : _typeof(glyph)) === 'object') {
                                        glyph = glyph.id;
                                    }
                                    if (this.mapping[glyph] == null) {
                                        this.glyphs.push(glyph);
                                        this.mapping[glyph] = this.glyphs.length - 1;
                                    }
                                    return this.mapping[glyph];
                                }
                            }, {
                                key: 'encodeStream',
                                value: function encodeStream() {
                                    var _this = this;
                                    var s = new r.EncodeStream();
                                    process.nextTick(function () {
                                        _this.encode(s);
                                        return s.end();
                                    });
                                    return s;
                                }
                            }]);
                        return Subset;
                    }();
                    var TTFSubset = function (_Subset) {
                        _inherits(TTFSubset, _Subset);
                        function TTFSubset() {
                            _classCallCheck(this, TTFSubset);
                            return _possibleConstructorReturn(this, (TTFSubset.__proto__ || _Object$getPrototypeOf(TTFSubset)).apply(this, arguments));
                        }
                        _createClass(TTFSubset, [{
                                key: '_addGlyph',
                                value: function _addGlyph(gid) {
                                    var glyf = this.font.getGlyph(gid)._decode();
                                    var curOffset = this.font.loca.offsets[gid];
                                    var nextOffset = this.font.loca.offsets[gid + 1];
                                    var stream = this.font._getTableStream('glyf');
                                    stream.pos += curOffset;
                                    var buffer = stream.readBuffer(nextOffset - curOffset);
                                    if (glyf && glyf.numberOfContours < 0) {
                                        buffer = new Buffer(buffer);
                                        for (var i = 0, keys = Object.keys(glyf.components); i < keys.length; i++) {
                                            var component = glyf.components[keys[i]];
                                            gid = this.includeGlyph(component.glyphID);
                                            buffer.writeUInt16BE(gid, component.pos);
                                        }
                                    }
                                    this.glyf.push(buffer);
                                    this.loca.offsets.push(this.offset);
                                    if (gid < this.font.hmtx.metrics.length) {
                                        this.hmtx.metrics.push(this.font.hmtx.metrics.get(gid));
                                    }
                                    else {
                                        this.hmtx.metrics.push({
                                            advance: this.font.hmtx.metrics.get(this.font.hmtx.metrics.length - 1).advance,
                                            bearing: this.font.hmtx.bearings.get(gid - this.font.hmtx.metrics.length)
                                        });
                                    }
                                    this.offset += buffer.length;
                                    return this.glyf.length - 1;
                                }
                            }, {
                                key: 'encode',
                                value: function encode(stream) {
                                    this.glyf = [];
                                    this.offset = 0;
                                    this.loca = {
                                        offsets: []
                                    };
                                    this.hmtx = {
                                        metrics: [],
                                        bearings: []
                                    };
                                    var i = 0;
                                    while (i < this.glyphs.length) {
                                        this._addGlyph(this.glyphs[i++]);
                                    }
                                    var maxp = cloneDeep(this.font.maxp);
                                    maxp.numGlyphs = this.glyf.length;
                                    this.loca.offsets.push(this.offset);
                                    tables.loca.preEncode.call(this.loca);
                                    var head = cloneDeep(this.font.head);
                                    head.indexToLocFormat = this.loca.version;
                                    var hhea = cloneDeep(this.font.hhea);
                                    hhea.numberOfMetrics = this.hmtx.metrics.length;
                                    Directory.encode(stream, {
                                        tables: {
                                            head: head,
                                            hhea: hhea,
                                            loca: this.loca,
                                            maxp: maxp,
                                            'cvt ': this.font['cvt '],
                                            prep: this.font.prep,
                                            glyf: this.glyf,
                                            hmtx: this.hmtx,
                                            fpgm: this.font.fpgm
                                        }
                                    });
                                }
                            }]);
                        return TTFSubset;
                    }(Subset);
                    var _class;
                    function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
                        var desc = {};
                        Object['ke' + 'ys'](descriptor).forEach(function (key) {
                            desc[key] = descriptor[key];
                        });
                        desc.enumerable = !!desc.enumerable;
                        desc.configurable = !!desc.configurable;
                        if ('value' in desc || desc.initializer) {
                            desc.writable = true;
                        }
                        desc = decorators.slice().reverse().reduce(function (desc, decorator) {
                            return decorator(target, property, desc) || desc;
                        }, desc);
                        if (context && desc.initializer !== void 0) {
                            desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
                            desc.initializer = undefined;
                        }
                        if (desc.initializer === void 0) {
                            Object['define' + 'Property'](target, property, desc);
                            desc = null;
                        }
                        return desc;
                    }
                    var TTFFont = (_class = function () {
                        _createClass(TTFFont, null, [{
                                key: 'probe',
                                value: function probe(buffer) {
                                    var format = buffer.toString('ascii', 0, 4);
                                    return format === 'true' || format === 'OTTO' || format === String.fromCharCode(0, 1, 0, 0);
                                }
                            }]);
                        function TTFFont(stream, farg1) {
                            var variationCoords = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
                            _classCallCheck(this, TTFFont);
                            this.stream = stream;
                            this._directoryPos = this.stream.pos;
                            this._tables = {};
                            this._glyphs = {};
                            this._decodeDirectory();
                            for (var tag in this.directory.tables) {
                                var table = this.directory.tables[tag];
                                if (tables[tag] && table.length > 0) {
                                    _Object$defineProperty(this, tag, {
                                        get: this._getTable.bind(this, table)
                                    });
                                }
                            }
                        }
                        _createClass(TTFFont, [{
                                key: '_getTable',
                                value: function _getTable(table) {
                                    if (!(table.tag in this._tables)) {
                                        try {
                                            this._tables[table.tag] = this._decodeTable(table);
                                        }
                                        catch (e) {
                                            if (fontkit.logErrors) {
                                                console.error('Error decoding table ' + table.tag);
                                                console.error(e.stack);
                                            }
                                        }
                                    }
                                    return this._tables[table.tag];
                                }
                            }, {
                                key: '_getTableStream',
                                value: function _getTableStream(tag) {
                                    var table = this.directory.tables[tag];
                                    if (table) {
                                        this.stream.pos = table.offset;
                                        return this.stream;
                                    }
                                    return null;
                                }
                            }, {
                                key: '_decodeDirectory',
                                value: function _decodeDirectory() {
                                    return this.directory = Directory.decode(this.stream, { _startOffset: 0 });
                                }
                            }, {
                                key: '_decodeTable',
                                value: function _decodeTable(table) {
                                    var pos = this.stream.pos;
                                    var stream = this._getTableStream(table.tag);
                                    var result = tables[table.tag].decode(stream, this, table.length);
                                    this.stream.pos = pos;
                                    return result;
                                }
                            }, {
                                key: 'getName',
                                value: function getName(key) {
                                    var lang = arguments.length <= 1 || arguments[1] === undefined ? 'English' : arguments[1];
                                    var record = this.name.records[key];
                                    if (record) {
                                        return record[lang];
                                    }
                                    return null;
                                }
                            }, {
                                key: 'hasGlyphForCodePoint',
                                value: function hasGlyphForCodePoint(codePoint) {
                                    return !!this._cmapProcessor.lookup(codePoint);
                                }
                            }, {
                                key: 'glyphForCodePoint',
                                value: function glyphForCodePoint(codePoint) {
                                    return this.getGlyph(this._cmapProcessor.lookup(codePoint), [codePoint]);
                                }
                            }, {
                                key: 'glyphsForString',
                                value: function glyphsForString(string) {
                                    var glyphs = [];
                                    var len = string.length;
                                    var idx = 0;
                                    while (idx < len) {
                                        var code = string.charCodeAt(idx++);
                                        if (0xd800 <= code && code <= 0xdbff && idx < len) {
                                            var next = string.charCodeAt(idx);
                                            if (0xdc00 <= next && next <= 0xdfff) {
                                                idx++;
                                                code = ((code & 0x3FF) << 10) + (next & 0x3FF) + 0x10000;
                                            }
                                        }
                                        glyphs.push(this.glyphForCodePoint(code));
                                    }
                                    return glyphs;
                                }
                            }, {
                                key: 'layout',
                                value: function layout(string, userFeatures, script, language) {
                                    return this._layoutEngine.layout(string, userFeatures, script, language);
                                }
                            }, {
                                key: '_getBaseGlyph',
                                value: function _getBaseGlyph(glyph) {
                                    var characters = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];
                                    if (!this._glyphs[glyph]) {
                                        if (this.directory.tables.glyf) {
                                            this._glyphs[glyph] = new TTFGlyph(glyph, characters, this);
                                        }
                                    }
                                    return this._glyphs[glyph] || null;
                                }
                            }, {
                                key: 'getGlyph',
                                value: function getGlyph(glyph) {
                                    var characters = arguments.length <= 1 || arguments[1] === undefined ? [] : arguments[1];
                                    if (!this._glyphs[glyph]) {
                                        this._getBaseGlyph(glyph, characters);
                                    }
                                    return this._glyphs[glyph] || null;
                                }
                            }, {
                                key: 'createSubset',
                                value: function createSubset() {
                                    return new TTFSubset(this);
                                }
                            }, {
                                key: 'getVariation',
                                value: function getVariation(settings) {
                                    if (!this.directory.tables.fvar || !this.directory.tables.gvar || !this.directory.tables.glyf) {
                                        throw new Error('Variations require a font with the fvar, gvar, and glyf tables.');
                                    }
                                    if (typeof settings === 'string') {
                                        settings = this.namedVariations[settings];
                                    }
                                    if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) !== 'object') {
                                        throw new Error('Variation settings must be either a variation name or settings object.');
                                    }
                                    var stream = new r.DecodeStream(this.stream.buffer);
                                    stream.pos = this._directoryPos;
                                    var font = new TTFFont(stream);
                                    font._tables = this._tables;
                                    return font;
                                }
                            }, {
                                key: 'getFont',
                                value: function getFont(name) {
                                    return this.getVariation(name);
                                }
                            }, {
                                key: 'postscriptName',
                                get: function get() {
                                    var name = this.name.records.postscriptName;
                                    var lang = _Object$keys(name)[0];
                                    return name[lang];
                                }
                            }, {
                                key: 'fullName',
                                get: function get() {
                                    return this.getName('fullName');
                                }
                            }, {
                                key: 'familyName',
                                get: function get() {
                                    return this.getName('fontFamily');
                                }
                            }, {
                                key: 'subfamilyName',
                                get: function get() {
                                    return this.getName('fontSubfamily');
                                }
                            }, {
                                key: 'copyright',
                                get: function get() {
                                    return this.getName('copyright');
                                }
                            }, {
                                key: 'version',
                                get: function get() {
                                    return this.getName('version');
                                }
                            }, {
                                key: 'ascent',
                                get: function get() {
                                    return this.hhea.ascent;
                                }
                            }, {
                                key: 'descent',
                                get: function get() {
                                    return this.hhea.descent;
                                }
                            }, {
                                key: 'lineGap',
                                get: function get() {
                                    return this.hhea.lineGap;
                                }
                            }, {
                                key: 'underlinePosition',
                                get: function get() {
                                    return this.post.underlinePosition;
                                }
                            }, {
                                key: 'underlineThickness',
                                get: function get() {
                                    return this.post.underlineThickness;
                                }
                            }, {
                                key: 'italicAngle',
                                get: function get() {
                                    return this.post.italicAngle;
                                }
                            }, {
                                key: 'capHeight',
                                get: function get() {
                                    var os2 = this['OS/2'];
                                    return os2 ? os2.capHeight : this.ascent;
                                }
                            }, {
                                key: 'xHeight',
                                get: function get() {
                                    var os2 = this['OS/2'];
                                    return os2 ? os2.xHeight : 0;
                                }
                            }, {
                                key: 'numGlyphs',
                                get: function get() {
                                    return this.maxp.numGlyphs;
                                }
                            }, {
                                key: 'unitsPerEm',
                                get: function get() {
                                    return this.head.unitsPerEm;
                                }
                            }, {
                                key: 'bbox',
                                get: function get() {
                                    return _Object$freeze(new BBox(this.head.xMin, this.head.yMin, this.head.xMax, this.head.yMax));
                                }
                            }, {
                                key: '_cmapProcessor',
                                get: function get() {
                                    return new CmapProcessor(this.cmap);
                                }
                            }, {
                                key: 'characterSet',
                                get: function get() {
                                    return this._cmapProcessor.getCharacterSet();
                                }
                            }, {
                                key: '_layoutEngine',
                                get: function get() {
                                    return new LayoutEngine(this);
                                }
                            }, {
                                key: 'availableFeatures',
                                get: function get() {
                                    return this._layoutEngine.getAvailableFeatures();
                                }
                            }, {
                                key: 'variationAxes',
                                get: function get() {
                                    var res = {};
                                    return res;
                                }
                            }, {
                                key: 'namedVariations',
                                get: function get() {
                                    var res = {};
                                    return res;
                                }
                            }]);
                        return TTFFont;
                    }(), (_applyDecoratedDescriptor(_class.prototype, 'bbox', [cache], _Object$getOwnPropertyDescriptor(_class.prototype, 'bbox'), _class.prototype), _applyDecoratedDescriptor(_class.prototype, '_cmapProcessor', [cache], _Object$getOwnPropertyDescriptor(_class.prototype, '_cmapProcessor'), _class.prototype), _applyDecoratedDescriptor(_class.prototype, 'characterSet', [cache], _Object$getOwnPropertyDescriptor(_class.prototype, 'characterSet'), _class.prototype), _applyDecoratedDescriptor(_class.prototype, '_layoutEngine', [cache], _Object$getOwnPropertyDescriptor(_class.prototype, '_layoutEngine'), _class.prototype)), _class);
                    var TTCHeader = new r.VersionedStruct(r.uint32, {
                        0x00010000: {
                            numFonts: r.uint32,
                            offsets: new r.Array(r.uint32, 'numFonts')
                        },
                        0x00020000: {
                            numFonts: r.uint32,
                            offsets: new r.Array(r.uint32, 'numFonts'),
                            dsigTag: r.uint32,
                            dsigLength: r.uint32,
                            dsigOffset: r.uint32
                        }
                    });
                    var TrueTypeCollection = function () {
                        _createClass(TrueTypeCollection, null, [{
                                key: 'probe',
                                value: function probe(buffer) {
                                    return buffer.toString('ascii', 0, 4) === 'ttcf';
                                }
                            }]);
                        function TrueTypeCollection(stream) {
                            _classCallCheck(this, TrueTypeCollection);
                            this.stream = stream;
                            if (stream.readString(4) !== 'ttcf') {
                                throw new Error('Not a TrueType collection');
                            }
                            this.header = TTCHeader.decode(stream);
                        }
                        _createClass(TrueTypeCollection, [{
                                key: 'getFont',
                                value: function getFont(name) {
                                    for (var i = 0, keys = Object.keys(this.header.offsets); i < keys.length; i++) {
                                        var offset = this.header.offsets[keys[i]];
                                        var stream = new r.DecodeStream(this.stream.buffer);
                                        stream.pos = offset;
                                        var font = new TTFFont(stream);
                                        if (font.postscriptName === name) {
                                            return font;
                                        }
                                    }
                                    return null;
                                }
                            }, {
                                key: 'fonts',
                                get: function get() {
                                    var fonts = [];
                                    for (var i = 0, keys = Object.keys(this.header.offsets); i < keys.length; i++) {
                                        var offset = this.header.offsets[keys[i]];
                                        var stream = new r.DecodeStream(this.stream.buffer);
                                        stream.pos = offset;
                                        fonts.push(new TTFFont(stream));
                                    }
                                    return fonts;
                                }
                            }]);
                        return TrueTypeCollection;
                    }();
                    var DFontName = new r.String(r.uint8);
                    var DFontData = new r.Struct({
                        len: r.uint32,
                        buf: new r.Buffer('len')
                    });
                    var Ref = new r.Struct({
                        id: r.uint16,
                        nameOffset: r.int16,
                        attr: r.uint8,
                        dataOffset: r.uint24,
                        handle: r.uint32
                    });
                    var Type = new r.Struct({
                        name: new r.String(4),
                        maxTypeIndex: r.uint16,
                        refList: new r.Pointer(r.uint16, new r.Array(Ref, function (t) {
                            return t.maxTypeIndex + 1;
                        }), { type: 'parent' })
                    });
                    var TypeList = new r.Struct({
                        length: r.uint16,
                        types: new r.Array(Type, function (t) {
                            return t.length + 1;
                        })
                    });
                    var DFontMap = new r.Struct({
                        reserved: new r.Reserved(r.uint8, 24),
                        typeList: new r.Pointer(r.uint16, TypeList),
                        nameListOffset: new r.Pointer(r.uint16, 'void')
                    });
                    var DFontHeader = new r.Struct({
                        dataOffset: r.uint32,
                        map: new r.Pointer(r.uint32, DFontMap),
                        dataLength: r.uint32,
                        mapLength: r.uint32
                    });
                    var DFont = function () {
                        _createClass(DFont, null, [{
                                key: 'probe',
                                value: function probe(buffer) {
                                    var stream = new r.DecodeStream(buffer);
                                    try {
                                        var header = DFontHeader.decode(stream);
                                    }
                                    catch (e) {
                                        return false;
                                    }
                                    for (var i = 0, keys = Object.keys(header.map.typeList.types); i < keys.length; i++) {
                                        var type = header.map.typeList.types[keys[i]];
                                        if (type.name === 'sfnt') {
                                            return true;
                                        }
                                    }
                                    return false;
                                }
                            }]);
                        function DFont(stream) {
                            _classCallCheck(this, DFont);
                            this.stream = stream;
                            this.header = DFontHeader.decode(this.stream);
                            for (var i = 0, keys = Object.keys(this.header.map.typeList.types); i < keys.length; i++) {
                                var type = this.header.map.typeList.types[keys[i]];
                                for (var j = 0, keys2 = Object.keys(type.refList); j < keys2.length; j++) {
                                    var ref = type.refList[keys2[j]];
                                    if (ref.nameOffset >= 0) {
                                        this.stream.pos = ref.nameOffset + this.header.map.nameListOffset;
                                        ref.name = DFontName.decode(this.stream);
                                    }
                                    else {
                                        ref.name = null;
                                    }
                                }
                                if (type.name === 'sfnt') {
                                    this.sfnt = type;
                                }
                            }
                        }
                        _createClass(DFont, [{
                                key: 'getFont',
                                value: function getFont(name) {
                                    if (!this.sfnt) {
                                        return null;
                                    }
                                    for (var i = 0, keys = Object.keys(this.sfnt.refList); i < keys.length; i++) {
                                        var ref = this.sfnt.refList[keys[i]];
                                        var pos = this.header.dataOffset + ref.dataOffset + 4;
                                        var stream = new r.DecodeStream(this.stream.buffer.slice(pos));
                                        var font = new TTFFont(stream);
                                        if (font.postscriptName === name) {
                                            return font;
                                        }
                                    }
                                    return null;
                                }
                            }, {
                                key: 'fonts',
                                get: function get() {
                                    var fonts = [];
                                    for (var i = 0, keys = Object.keys(this.sfnt.refList); i < keys.length; i++) {
                                        var ref = this.sfnt.refList[keys[i]];
                                        var pos = this.header.dataOffset + ref.dataOffset + 4;
                                        var stream = new r.DecodeStream(this.stream.buffer.slice(pos));
                                        fonts.push(new TTFFont(stream));
                                    }
                                    return fonts;
                                }
                            }]);
                        return DFont;
                    }();
                    fontkit.registerFormat(TTFFont);
                    fontkit.registerFormat(TrueTypeCollection);
                    fontkit.registerFormat(DFont);
                    localModule.localExports = fontkit;
                }).call(this, localRequire('_process'), localRequire("buffer").Buffer);
            }, { "_process": 188, "babel-runtime/core-js/get-iterator": 24, "babel-runtime/core-js/object/assign": 26, "babel-runtime/core-js/object/define-properties": 28, "babel-runtime/core-js/object/define-property": 29, "babel-runtime/core-js/object/freeze": 30, "babel-runtime/core-js/object/get-own-property-descriptor": 31, "babel-runtime/core-js/object/get-prototype-of": 32, "babel-runtime/core-js/object/keys": 33, "babel-runtime/helpers/classCallCheck": 37, "babel-runtime/helpers/createClass": 38, "babel-runtime/helpers/get": 39, "babel-runtime/helpers/inherits": 40, "babel-runtime/helpers/possibleConstructorReturn": 41, "babel-runtime/helpers/slicedToArray": 42, "babel-runtime/helpers/toConsumableArray": 43, "babel-runtime/helpers/typeof": 44, "buffer": 60, "clone": 61, "restructure": 199, "restructure/src/utils": 215, "tiny-inflate": 218, "unicode-properties": 220, "unicode-trie": 221 }], 166: [function (localRequire, localModule, localExports) {
                localExports.read = function (buffer, offset, isLE, mLen, nBytes) {
                    var e, m;
                    var eLen = nBytes * 8 - mLen - 1;
                    var eMax = (1 << eLen) - 1;
                    var eBias = eMax >> 1;
                    var nBits = -7;
                    var i = isLE ? (nBytes - 1) : 0;
                    var d = isLE ? -1 : 1;
                    var s = buffer[offset + i];
                    i += d;
                    e = s & ((1 << (-nBits)) - 1);
                    s >>= (-nBits);
                    nBits += eLen;
                    for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) { }
                    m = e & ((1 << (-nBits)) - 1);
                    e >>= (-nBits);
                    nBits += mLen;
                    for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) { }
                    if (e === 0) {
                        e = 1 - eBias;
                    }
                    else if (e === eMax) {
                        return m ? NaN : ((s ? -1 : 1) * Infinity);
                    }
                    else {
                        m = m + Math.pow(2, mLen);
                        e = e - eBias;
                    }
                    return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
                };
                localExports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
                    var e, m, c;
                    var eLen = nBytes * 8 - mLen - 1;
                    var eMax = (1 << eLen) - 1;
                    var eBias = eMax >> 1;
                    var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0);
                    var i = isLE ? 0 : (nBytes - 1);
                    var d = isLE ? 1 : -1;
                    var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;
                    value = Math.abs(value);
                    if (isNaN(value) || value === Infinity) {
                        m = isNaN(value) ? 1 : 0;
                        e = eMax;
                    }
                    else {
                        e = Math.floor(Math.log(value) / Math.LN2);
                        if (value * (c = Math.pow(2, -e)) < 1) {
                            e--;
                            c *= 2;
                        }
                        if (e + eBias >= 1) {
                            value += rt / c;
                        }
                        else {
                            value += rt * Math.pow(2, 1 - eBias);
                        }
                        if (value * c >= 2) {
                            e++;
                            c /= 2;
                        }
                        if (e + eBias >= eMax) {
                            m = 0;
                            e = eMax;
                        }
                        else if (e + eBias >= 1) {
                            m = (value * c - 1) * Math.pow(2, mLen);
                            e = e + eBias;
                        }
                        else {
                            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
                            e = 0;
                        }
                    }
                    for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) { }
                    e = (e << mLen) | m;
                    eLen += mLen;
                    for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) { }
                    buffer[offset + i - d] |= s * 128;
                };
            }, {}], 167: [function (localRequire, localModule, localExports) {
                if (typeof Object.create === 'function') {
                    localModule.localExports = function inherits(ctor, superCtor) {
                        ctor.super_ = superCtor;
                        ctor.prototype = Object.create(superCtor.prototype, {
                            constructor: {
                                value: ctor,
                                enumerable: false,
                                writable: true,
                                configurable: true
                            }
                        });
                    };
                }
                else {
                    localModule.localExports = function inherits(ctor, superCtor) {
                        ctor.super_ = superCtor;
                        var TempCtor = function () { };
                        TempCtor.prototype = superCtor.prototype;
                        ctor.prototype = new TempCtor();
                        ctor.prototype.constructor = ctor;
                    };
                }
            }, {}], 168: [function (localRequire, localModule, localExports) {
                localModule.localExports = function (obj) {
                    return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer);
                };
                function isBuffer(obj) {
                    return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj);
                }
                function isSlowBuffer(obj) {
                    return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0));
                }
            }, {}], 169: [function (localRequire, localModule, localExports) {
                var toString = {}.toString;
                localModule.localExports = Array.isArray || function (arr) {
                    return toString.call(arr) == '[object Array]';
                };
            }, {}],
        172: [function (localRequire, localModule, localExports) {
                (function () {
                    var AI, AL, B2, BA, BB, BK, CB, CJ, CL, CM, CP, CR, EX, GL, H2, H3, HL, HY, ID, IN, IS, JL, JT, JV, LF, NL, NS, NU, OP, PO, PR, QU, RI, SA, SG, SP, SY, WJ, XX, ZW;
                    localExports.OP = OP = 0;
                    localExports.CL = CL = 1;
                    localExports.CP = CP = 2;
                    localExports.QU = QU = 3;
                    localExports.GL = GL = 4;
                    localExports.NS = NS = 5;
                    localExports.EX = EX = 6;
                    localExports.SY = SY = 7;
                    localExports.IS = IS = 8;
                    localExports.PR = PR = 9;
                    localExports.PO = PO = 10;
                    localExports.NU = NU = 11;
                    localExports.AL = AL = 12;
                    localExports.HL = HL = 13;
                    localExports.ID = ID = 14;
                    localExports.IN = IN = 15;
                    localExports.HY = HY = 16;
                    localExports.BA = BA = 17;
                    localExports.BB = BB = 18;
                    localExports.B2 = B2 = 19;
                    localExports.ZW = ZW = 20;
                    localExports.CM = CM = 21;
                    localExports.WJ = WJ = 22;
                    localExports.H2 = H2 = 23;
                    localExports.H3 = H3 = 24;
                    localExports.JL = JL = 25;
                    localExports.JV = JV = 26;
                    localExports.JT = JT = 27;
                    localExports.RI = RI = 28;
                    localExports.AI = AI = 29;
                    localExports.BK = BK = 30;
                    localExports.CB = CB = 31;
                    localExports.CJ = CJ = 32;
                    localExports.CR = CR = 33;
                    localExports.LF = LF = 34;
                    localExports.NL = NL = 35;
                    localExports.SA = SA = 36;
                    localExports.SG = SG = 37;
                    localExports.SP = SP = 38;
                    localExports.XX = XX = 39;
                }).call(this);
            }, {}], 173: [function (localRequire, localModule, localExports) {
                (function () {
                    var AI, AL, BA, BK, CB, CI_BRK, CJ, CP_BRK, CR, DI_BRK, ID, IN_BRK, LF, LineBreaker, NL, NS, PR_BRK, SA, SG, SP, UnicodeTrie, WJ, XX, characterClasses, classTrie, pairTable, _ref, _ref1;
                    UnicodeTrie = localRequire('unicode-trie');
                    var Buffer = localRequire("buffer").Buffer;
                    classTrie = new UnicodeTrie(new Buffer("AA4IAAAAAAAAAf2g3VZ7PNP7//+ebiriUKKwnRJyieRSxrZzoiS3IypilJ3KbW4rWjM7HURuK9cuNKUyHXeOhbGkTKGR+4ZhMWFbjA27fH7U+f31ezx+v/7+Pf95f96Px/N1eb5ez8f78eGOwO8yBn+iRSQBb4PFc2MpJuMfg73V9I5mfUfHsyfPvqE3NeX3M99whH07I8PY752rV77Lhm37Hl/EP15RCFD7IlqUnXJNetcDzz1t1lH5erf1nFusm8HIk78MNHt/t9/oXNN1Ug6x2EX7j23q4dZNxi/uX0rfnON5KW1H7eAlwoLWCqlgu5xFb/evOw/VdP+mBl00ff2zdqrprRT9K/eRt3TOeSKRIY2Xy0E3hgslGZEFP5bVcMHtN1XFIFLhLd0L5U25dZ1IOUT1MLuS8NNt9Uupd1YaxTMN6/mVKxQ89wSHpKKOr3ctHVNU9aC3/db5LS6gEHmt2xYcd3ffyVb1na/ub+k4TNvgiEywsCynDpRebRdoCUdhwGtY4b8tdYJB/cHzlDSX1LLu9oLvlbb5OJm2aMobVS58SPzemYZQXtVjvODKmmCz4/KowrjQU0o45J/7TqojN6i5fytRUtG6xXuuwn7l0KTd5rPHSM89vul1IQmET1Bx9WHspS4l9YsB67pDLzJ7yF++R1FQl+IORcnNucnao6NJSW0nPHbY263hQMLemc29v+4s1WZMF6SAVtXVbVPT/2e1ujcW5WtDczm147q5v3n3cQ2tdfUbFUzfrIv3v22129N/TfugfyL0A/8g2ID05rc1ZpedPOpa1wklnMLht1uRTmP+yXumPC/eUe0fvJiiJTwInIL9IDE7xuP3hLi9MwEFd3b/2+fFJOXW+6/f7Vp3lYphSWXzN2u5/mhGux8lpv1gaZn1/+3VtQ0MFvrogNd3fBuyN+BpgiVk+mkibIu6f7ypbrjpOwW0UcXb7cEhFe8UsVl43R8l7vtBIvwuYfvL8N9ttXaYw+2oeliHUqWooVH8vf3B+LYXccY3p4kBa17b9+8Uflp3ZqvV96WKhAS4HwwnUmVROETH53i2YdN4SsuRpgmNJsmH70fc5Zh3R2NW3ny/ZX6/qbUvJ4eFd0hv8h9LAB7wyJ42bBvdiQulDZtFdUpHOkcujTaOjEUerZh7iCUB2Py6gS8PxdnpdSLOQ2x4el1tRKdFErJsp48ZK7qDMmIhCKN1FCLMwFEdlH4LgTutwwxh5netg0K3EByldbT4mBEjOyhtFgINWof7Wkx4B6XZgoOn5dEQaFiUExDtDKCn0YhXg8Pgcnvle96TMTVwWiWXB/Pd3Cfmc9IO/iOGh5bH4j03Oofx4qLi063sEUEAVsRaMk06/Hb6T1PdqTxImmmLZMNuvV5mxvVzozevuHwb7R5wNKkgqDX56JUgktq1OfOD53eWxk8G443S0xMg3Fgbwrpv1JHxlUlJST4da08SGI+XEXEUSV7hqSlwpvfFO9nnr+7TCClvUxRrBIgXim5EE9PL/VZ20cW4bPt1W20NqX4v6N/GmNb8b7eyd+m+yOMVyfUkrd7HqSj/73i05mrM0z49MQv4ZUjCoU8CWD8DrbPN5csBx7b1O8z43UjXu5FmTTGnNxIxgGzX8oi85J1NleHz89saD/vK2Sgd4pT+IRx3VetQ4GBRXpbtfMdVEVNbzUIXUBYIbGwsuGNpKw3/KcePasjQgLqbPnQxEA8F/uEfn90C3XYo9/RKOlmcR/ZbjFFWvhf8ma73F3oL3mr5IZK5dXuZgNdWnxtejBk9dPPmBCTCRb+lmMtDyNsjlAZ5hP3+9iDaHuU639G8148MPU7j8wyHsydYtkb1p7+MvxLCJlbQghtz0h7w9gPlsK9HfokB6zjnwwkXG/BF9+zhTjeBmctjmFdOtbMnQMs4yHsfgy/8Qt9Zqm4g8B5NRAmbHR+bXUvz6YjCIU5H081IW9mcvOsqvjTr88xj9JPZhoErmSXRzsj5C+1anE9E+1cHmNexd2Dqvh8v+HFIrsCSKvsMbTKc2CCsxATApTiovViOjAkw0muk/gyDvUDhgVXzIKaMzj9NI1gRnkgF4SSwpqF7DsarN0J3NnYw9G8KEx6stZkp9plsPyJjty7poxX/wTfREmwY8Pexel821jKnVbj4MsGvFdCePCATwpHQAZt5JAi4lLtXHNieWSslLBU+Y0/0M1mt83Dnhj8Cga+wKw82DgeJaX2i4oze6Aw2vl8I72dBIwYSxiPm7zPgd9Af1Yx1HKgK4oVT8SKxMVtIqXeBuEhFSyC0lNOdE8hxcEMtGx9Yri66xVGt1lyySi+60vi18cXYq9RIngjTQpydBzfiJ1+zKyNVh+rKJg22xYKyw8TqxL6w54lsNx8tPa5Gc6WySKTpmrYfJP4EoraIrzRIanVKqa+WUGDHlzlSn3Dq8DGmlN6KMYtpDJ+2+aVoAK1CaOSZ1AGj1EiSDMXHM+ohlmHVOjZUJwOCxHaAgeEU4fiTmkPjIj5IgIXHMuHyRmKk3nIsvZgP/tyHl4iUJQtUeanNMI24u0SCAXuH5I7nDMb4Wb8ENudKZY+X6hf636axgqmyjz1PZBxqa1QDY87RF3eAC/fKx8ruRT3eqfeSMMgjc3iCQB1o9DMr2aZyb4PnPWWXq3KgQeDkLp4XY3pYREie8BGkBD/iT1mxthMazPFXVc4nDjCADBD2Ux58IYBKYp8ZpoeAacldLDqmrOGsDCsfQdvE6ula8NOeMZHUgx2pQBlV73ki3xSvUqkZU8pB/UmGAtYDhYyP7TiMXYWC70cz7bJQ3/tV2RvLoYurxxKnIM2TxP39zhBXHLjSJYNvIxSZLONSx/kBTlWyYk7PWOyI1s8ylznzp/3QAYu4TpGrywPBgXylFbbOsJwiLtb84KtRxJvrf0lNOoUpM11NdriwoF5RDVglNzeq0V2oL8/kRt6JoubA9p7nhQ+1wFNWGwF1GV5+IvLpqruPFmjGMbHVM2M+ozZ2IocgtXkvzOzvfDKJXoxDo+CB+ToIuMmA5bnquXYNdhYKC3zQK8POjsb/8QCvigAJOOiOQ2V9sxuyxrOOyA0Zu2YcAUWWlbi3360xeTbk0rtQXC5PtZyV6aISn83+0bkDTGXPTHtCb5M5gMzZySVHEJGDS/27Bd17OSeKMIOOlZ5onNK83OQhBTP5jimzKRFvkGYvXVk0CizIJh6vphkdsbTrbDqJa5et91Ih8UCxobd06mE8U+Bw6mt0BCuRKzUkfr2xA014ujBbsfXyMWFAQ1nIHJphzxSffQY5dBoTkqvt6kZ7530D0J7rwg0WjHFWpdjXdMf3MPyZaw7AR13eaDF3gekRL6aNW3mdSYQdVZHk2RYvimNBj8Wb4UqR05q7R5vg51NXfU54IICAePFFRvATm6wd+BWvsZXKm/oJ/VBh/dVbnOal9Duz8EBhD2Dk/PWqr0aMJZ0AneKesaItZM6JKlk4Y+m8mQH9uMTSTcpxB8aJ4utaForJ+7lWEvTJWpHoPnJAXNuem821usuV0m3daFEXyFEAhERiFd6tmePUx1L6qayDf5Ho/mpcvmKodNXak+g28GQgUrKdfMKD+XnEF7PY84yoRVWVifatiqozZNI/uZGcocSFZextIzxV/SzgpVNKDI91o1NpQpGKoIgC7G5tr5jPJySuErnzwcg5GsrkffSmPIgMNdCnM2PBXfLOkKmNRjFWlch/c/nH3zMU3aRm3Mq2KMAg+QAnr0RqMhe2LN6s74r54P54IavIZvL//edo6Wdpzie61far0siNb8SLru2jnkLIVTecUI5ylOBAcZlnOLY3yEKzReU+p/EU+epG8MDUc8ziLB930sTJOqcTTUe3hLHJcgx+V21mDb7XtJMOXTKl5NvS6JFj3YZ0s5byONtJh5upTYa4MPJRZXFYAxyhTeXFHiHEWifMQl4qZdkSHFak+5erOfrke2e/vK3iZPMHUFaLkgeBRfRtQzzXoq/iOG7koCYeFFaCQRrHUBoMteBNOvnam+j6xHC/m3k0Oqm+eNP0cOSe5ro0btXghAjKnGyb2S1sPifG+upkLUHmKxHw0Q/LH/5mqRbHVvngmcbiJ6vOC7LjDK7WQ6pdJQJ8IkCuzzVGSxVjlG+bg0zphEUWY5r/IQPFnOSvEQVtgiLbFS+xwz0m0Bvx6IXvxz4l0OyytT02gbzThgcKziyRsqLyJxFU2iqxDA7OOyMroSkx134qxqiRa65NSGj/nEveNW/twJJLZvA4dyf3snPyzkTLoOWO9IbkGAn0HBlDZtUxjxEglSMnMTwit2qXFwMT3D1URkeTHS9YwhJ3XsM/l0DIiHRHXpgHvBpRZv4pNUVJzR8rmWzmG0ZQqxFNpIV4cE+Zd43UoOqZAEDXcPWNH2Qv2YQ2HDLptgcxl4pW6ZfFuVwRqmyojsbG//Rf", "base64"));
                    _ref = localRequire('./classes'), BK = _ref.BK, CR = _ref.CR, LF = _ref.LF, NL = _ref.NL, CB = _ref.CB, BA = _ref.BA, SP = _ref.SP, WJ = _ref.WJ, SP = _ref.SP, BK = _ref.BK, LF = _ref.LF, NL = _ref.NL, AI = _ref.AI, AL = _ref.AL, SA = _ref.SA, SG = _ref.SG, XX = _ref.XX, CJ = _ref.CJ, ID = _ref.ID, NS = _ref.NS, characterClasses = _ref.characterClasses;
                    _ref1 = localRequire('./pairs'), DI_BRK = _ref1.DI_BRK, IN_BRK = _ref1.IN_BRK, CI_BRK = _ref1.CI_BRK, CP_BRK = _ref1.CP_BRK, PR_BRK = _ref1.PR_BRK, pairTable = _ref1.pairTable;
                    LineBreaker = (function () {
                        var Break, mapClass, mapFirst;
                        function LineBreaker(string) {
                            this.string = string;
                            this.pos = 0;
                            this.lastPos = 0;
                            this.curClass = null;
                            this.nextClass = null;
                        }
                        LineBreaker.prototype.nextCodePoint = function () {
                            var code, next;
                            code = this.string.charCodeAt(this.pos++);
                            next = this.string.charCodeAt(this.pos);
                            if ((0xd800 <= code && code <= 0xdbff) && (0xdc00 <= next && next <= 0xdfff)) {
                                this.pos++;
                                return ((code - 0xd800) * 0x400) + (next - 0xdc00) + 0x10000;
                            }
                            return code;
                        };
                        mapClass = function (c) {
                            switch (c) {
                                case AI:
                                    return AL;
                                case SA:
                                case SG:
                                case XX:
                                    return AL;
                                case CJ:
                                    return NS;
                                default:
                                    return c;
                            }
                        };
                        mapFirst = function (c) {
                            switch (c) {
                                case LF:
                                case NL:
                                    return BK;
                                case CB:
                                    return BA;
                                case SP:
                                    return WJ;
                                default:
                                    return c;
                            }
                        };
                        LineBreaker.prototype.nextCharClass = function (first) {
                            if (first == null) {
                                first = false;
                            }
                            return mapClass(classTrie.get(this.nextCodePoint()));
                        };
                        Break = (function () {
                            function Break(position, required) {
                                this.position = position;
                                this.required = required != null ? required : false;
                            }
                            return Break;
                        })();
                        LineBreaker.prototype.nextBreak = function () {
                            var cur, lastClass, shouldBreak;
                            if (this.curClass == null) {
                                this.curClass = mapFirst(this.nextCharClass());
                            }
                            while (this.pos < this.string.length) {
                                this.lastPos = this.pos;
                                lastClass = this.nextClass;
                                this.nextClass = this.nextCharClass();
                                if (this.curClass === BK || (this.curClass === CR && this.nextClass !== LF)) {
                                    this.curClass = mapFirst(mapClass(this.nextClass));
                                    return new Break(this.lastPos, true);
                                }
                                cur = (function () {
                                    switch (this.nextClass) {
                                        case SP:
                                            return this.curClass;
                                        case BK:
                                        case LF:
                                        case NL:
                                            return BK;
                                        case CR:
                                            return CR;
                                        case CB:
                                            return BA;
                                    }
                                }).call(this);
                                if (cur != null) {
                                    this.curClass = cur;
                                    if (this.nextClass === CB) {
                                        return new Break(this.lastPos);
                                    }
                                    continue;
                                }
                                shouldBreak = false;
                                switch (pairTable[this.curClass][this.nextClass]) {
                                    case DI_BRK:
                                        shouldBreak = true;
                                        break;
                                    case IN_BRK:
                                        shouldBreak = lastClass === SP;
                                        break;
                                    case CI_BRK:
                                        shouldBreak = lastClass === SP;
                                        if (!shouldBreak) {
                                            continue;
                                        }
                                        break;
                                    case CP_BRK:
                                        if (lastClass !== SP) {
                                            continue;
                                        }
                                }
                                this.curClass = this.nextClass;
                                if (shouldBreak) {
                                    return new Break(this.lastPos);
                                }
                            }
                            if (this.pos >= this.string.length) {
                                if (this.lastPos < this.string.length) {
                                    this.lastPos = this.string.length;
                                    return new Break(this.string.length);
                                }
                                else {
                                    return null;
                                }
                            }
                        };
                        return LineBreaker;
                    })();
                    localModule.localExports = LineBreaker;
                }).call(this);
            }, { "buffer": 60, "./classes": 172, "./pairs": 174, "unicode-trie": 221 }], 174: [function (localRequire, localModule, localExports) {
                (function () {
                    var CI_BRK, CP_BRK, DI_BRK, IN_BRK, PR_BRK;
                    localExports.DI_BRK = DI_BRK = 0;
                    localExports.IN_BRK = IN_BRK = 1;
                    localExports.CI_BRK = CI_BRK = 2;
                    localExports.CP_BRK = CP_BRK = 3;
                    localExports.PR_BRK = PR_BRK = 4;
                    localExports.pairTable = [[PR_BRK, PR_BRK, PR_BRK, PR_BRK, PR_BRK, PR_BRK, PR_BRK, PR_BRK, PR_BRK, PR_BRK, PR_BRK, PR_BRK, PR_BRK, PR_BRK, PR_BRK, PR_BRK, PR_BRK, PR_BRK, PR_BRK, PR_BRK, PR_BRK, CP_BRK, PR_BRK, PR_BRK, PR_BRK, PR_BRK, PR_BRK, PR_BRK, PR_BRK], [DI_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, PR_BRK, CI_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK], [DI_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, PR_BRK, CI_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK], [PR_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, CI_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK], [IN_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, CI_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK], [DI_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, PR_BRK, CI_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK], [DI_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, PR_BRK, CI_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK], [DI_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, DI_BRK, DI_BRK, IN_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, PR_BRK, CI_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK], [DI_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, DI_BRK, DI_BRK, IN_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, PR_BRK, CI_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK], [IN_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, DI_BRK, DI_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, DI_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, PR_BRK, CI_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, DI_BRK], [IN_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, DI_BRK, DI_BRK, IN_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, PR_BRK, CI_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK], [IN_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, DI_BRK, IN_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, PR_BRK, CI_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK], [IN_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, DI_BRK, DI_BRK, IN_BRK, IN_BRK, IN_BRK, DI_BRK, IN_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, PR_BRK, CI_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK], [IN_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, DI_BRK, DI_BRK, IN_BRK, IN_BRK, IN_BRK, DI_BRK, IN_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, PR_BRK, CI_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK], [DI_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, DI_BRK, IN_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, PR_BRK, CI_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK], [DI_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, PR_BRK, CI_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK], [DI_BRK, PR_BRK, PR_BRK, IN_BRK, DI_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, DI_BRK, DI_BRK, IN_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, PR_BRK, CI_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK], [DI_BRK, PR_BRK, PR_BRK, IN_BRK, DI_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, PR_BRK, CI_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK], [IN_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, CI_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK], [DI_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, IN_BRK, DI_BRK, PR_BRK, PR_BRK, CI_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK], [DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK], [IN_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, DI_BRK, DI_BRK, IN_BRK, IN_BRK, IN_BRK, DI_BRK, IN_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, PR_BRK, CI_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK], [IN_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, CI_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK], [DI_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, DI_BRK, IN_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, PR_BRK, CI_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, IN_BRK, DI_BRK], [DI_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, DI_BRK, IN_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, PR_BRK, CI_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, DI_BRK], [DI_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, DI_BRK, IN_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, PR_BRK, CI_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK], [DI_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, DI_BRK, IN_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, PR_BRK, CI_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, IN_BRK, DI_BRK], [DI_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, DI_BRK, IN_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, PR_BRK, CI_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, DI_BRK], [DI_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, PR_BRK, CI_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK]];
                }).call(this);
            }, {}], 175: [function (localRequire, localModule, localExports) {
                'use strict';
                var TYPED_OK = (typeof Uint8Array !== 'undefined') &&
                    (typeof Uint16Array !== 'undefined') &&
                    (typeof Int32Array !== 'undefined');
                localExports.assign = function (obj) {
                    var sources = Array.prototype.slice.call(arguments, 1);
                    while (sources.length) {
                        var source = sources.shift();
                        if (!source) {
                            continue;
                        }
                        if (typeof source !== 'object') {
                            throw new TypeError(source + 'must be non-object');
                        }
                        for (var p in source) {
                            if (source.hasOwnProperty(p)) {
                                obj[p] = source[p];
                            }
                        }
                    }
                    return obj;
                };
                localExports.shrinkBuf = function (buf, size) {
                    if (buf.length === size) {
                        return buf;
                    }
                    if (buf.subarray) {
                        return buf.subarray(0, size);
                    }
                    buf.length = size;
                    return buf;
                };
                var fnTyped = {
                    arraySet: function (dest, src, src_offs, len, dest_offs) {
                        if (src.subarray && dest.subarray) {
                            dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
                            return;
                        }
                        for (var i = 0; i < len; i++) {
                            dest[dest_offs + i] = src[src_offs + i];
                        }
                    },
                    flattenChunks: function (chunks) {
                        var i, l, len, pos, chunk, result;
                        len = 0;
                        for (i = 0, l = chunks.length; i < l; i++) {
                            len += chunks[i].length;
                        }
                        result = new Uint8Array(len);
                        pos = 0;
                        for (i = 0, l = chunks.length; i < l; i++) {
                            chunk = chunks[i];
                            result.set(chunk, pos);
                            pos += chunk.length;
                        }
                        return result;
                    }
                };
                var fnUntyped = {
                    arraySet: function (dest, src, src_offs, len, dest_offs) {
                        for (var i = 0; i < len; i++) {
                            dest[dest_offs + i] = src[src_offs + i];
                        }
                    },
                    flattenChunks: function (chunks) {
                        return [].concat.apply([], chunks);
                    }
                };
                localExports.setTyped = function (on) {
                    if (on) {
                        localExports.Buf8 = Uint8Array;
                        localExports.Buf16 = Uint16Array;
                        localExports.Buf32 = Int32Array;
                        localExports.assign(localExports, fnTyped);
                    }
                    else {
                        localExports.Buf8 = Array;
                        localExports.Buf16 = Array;
                        localExports.Buf32 = Array;
                        localExports.assign(localExports, fnUntyped);
                    }
                };
                localExports.setTyped(TYPED_OK);
            }, {}], 176: [function (localRequire, localModule, localExports) {
                'use strict';
                function adler32(adler, buf, len, pos) {
                    var s1 = (adler & 0xffff) | 0, s2 = ((adler >>> 16) & 0xffff) | 0, n = 0;
                    while (len !== 0) {
                        n = len > 2000 ? 2000 : len;
                        len -= n;
                        do {
                            s1 = (s1 + buf[pos++]) | 0;
                            s2 = (s2 + s1) | 0;
                        } while (--n);
                        s1 %= 65521;
                        s2 %= 65521;
                    }
                    return (s1 | (s2 << 16)) | 0;
                }
                localModule.localExports = adler32;
            }, {}], 177: [function (localRequire, localModule, localExports) {
                'use strict';
                localModule.localExports = {
                    Z_NO_FLUSH: 0,
                    Z_PARTIAL_FLUSH: 1,
                    Z_SYNC_FLUSH: 2,
                    Z_FULL_FLUSH: 3,
                    Z_FINISH: 4,
                    Z_BLOCK: 5,
                    Z_TREES: 6,
                    Z_OK: 0,
                    Z_STREAM_END: 1,
                    Z_NEED_DICT: 2,
                    Z_ERRNO: -1,
                    Z_STREAM_ERROR: -2,
                    Z_DATA_ERROR: -3,
                    Z_BUF_ERROR: -5,
                    Z_NO_COMPRESSION: 0,
                    Z_BEST_SPEED: 1,
                    Z_BEST_COMPRESSION: 9,
                    Z_DEFAULT_COMPRESSION: -1,
                    Z_FILTERED: 1,
                    Z_HUFFMAN_ONLY: 2,
                    Z_RLE: 3,
                    Z_FIXED: 4,
                    Z_DEFAULT_STRATEGY: 0,
                    Z_BINARY: 0,
                    Z_TEXT: 1,
                    Z_UNKNOWN: 2,
                    Z_DEFLATED: 8
                };
            }, {}], 178: [function (localRequire, localModule, localExports) {
                'use strict';
                function makeTable() {
                    var c, table = [];
                    for (var n = 0; n < 256; n++) {
                        c = n;
                        for (var k = 0; k < 8; k++) {
                            c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));
                        }
                        table[n] = c;
                    }
                    return table;
                }
                var crcTable = makeTable();
                function crc32(crc, buf, len, pos) {
                    var t = crcTable, end = pos + len;
                    crc ^= -1;
                    for (var i = pos; i < end; i++) {
                        crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];
                    }
                    return (crc ^ (-1));
                }
                localModule.localExports = crc32;
            }, {}], 179: [function (localRequire, localModule, localExports) {
                'use strict';
                var utils = localRequire('../utils/common');
                var trees = localRequire('./trees');
                var adler32 = localRequire('./adler32');
                var crc32 = localRequire('./crc32');
                var msg = localRequire('./messages');
                var Z_NO_FLUSH = 0;
                var Z_PARTIAL_FLUSH = 1;
                var Z_FULL_FLUSH = 3;
                var Z_FINISH = 4;
                var Z_BLOCK = 5;
                var Z_OK = 0;
                var Z_STREAM_END = 1;
                var Z_STREAM_ERROR = -2;
                var Z_DATA_ERROR = -3;
                var Z_BUF_ERROR = -5;
                var Z_DEFAULT_COMPRESSION = -1;
                var Z_FILTERED = 1;
                var Z_HUFFMAN_ONLY = 2;
                var Z_RLE = 3;
                var Z_FIXED = 4;
                var Z_DEFAULT_STRATEGY = 0;
                var Z_UNKNOWN = 2;
                var Z_DEFLATED = 8;
                var MAX_MEM_LEVEL = 9;
                var MAX_WBITS = 15;
                var DEF_MEM_LEVEL = 8;
                var LENGTH_CODES = 29;
                var LITERALS = 256;
                var L_CODES = LITERALS + 1 + LENGTH_CODES;
                var D_CODES = 30;
                var BL_CODES = 19;
                var HEAP_SIZE = 2 * L_CODES + 1;
                var MAX_BITS = 15;
                var MIN_MATCH = 3;
                var MAX_MATCH = 258;
                var MIN_LOOKAHEAD = (MAX_MATCH + MIN_MATCH + 1);
                var PRESET_DICT = 0x20;
                var INIT_STATE = 42;
                var EXTRA_STATE = 69;
                var NAME_STATE = 73;
                var COMMENT_STATE = 91;
                var HCRC_STATE = 103;
                var BUSY_STATE = 113;
                var FINISH_STATE = 666;
                var BS_NEED_MORE = 1;
                var BS_BLOCK_DONE = 2;
                var BS_FINISH_STARTED = 3;
                var BS_FINISH_DONE = 4;
                var OS_CODE = 0x03;
                function err(strm, errorCode) {
                    strm.msg = msg[errorCode];
                    return errorCode;
                }
                function rank(f) {
                    return ((f) << 1) - ((f) > 4 ? 9 : 0);
                }
                function zero(buf) { var len = buf.length; while (--len >= 0) {
                    buf[len] = 0;
                } }
                function flush_pending(strm) {
                    var s = strm.state;
                    var len = s.pending;
                    if (len > strm.avail_out) {
                        len = strm.avail_out;
                    }
                    if (len === 0) {
                        return;
                    }
                    utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);
                    strm.next_out += len;
                    s.pending_out += len;
                    strm.total_out += len;
                    strm.avail_out -= len;
                    s.pending -= len;
                    if (s.pending === 0) {
                        s.pending_out = 0;
                    }
                }
                function flush_block_only(s, last) {
                    trees._tr_flush_block(s, (s.block_start >= 0 ? s.block_start : -1), s.strstart - s.block_start, last);
                    s.block_start = s.strstart;
                    flush_pending(s.strm);
                }
                function put_byte(s, b) {
                    s.pending_buf[s.pending++] = b;
                }
                function putShortMSB(s, b) {
                    s.pending_buf[s.pending++] = (b >>> 8) & 0xff;
                    s.pending_buf[s.pending++] = b & 0xff;
                }
                function read_buf(strm, buf, start, size) {
                    var len = strm.avail_in;
                    if (len > size) {
                        len = size;
                    }
                    if (len === 0) {
                        return 0;
                    }
                    strm.avail_in -= len;
                    utils.arraySet(buf, strm.input, strm.next_in, len, start);
                    if (strm.state.wrap === 1) {
                        strm.adler = adler32(strm.adler, buf, len, start);
                    }
                    else if (strm.state.wrap === 2) {
                        strm.adler = crc32(strm.adler, buf, len, start);
                    }
                    strm.next_in += len;
                    strm.total_in += len;
                    return len;
                }
                function longest_match(s, cur_match) {
                    var chain_length = s.max_chain_length;
                    var scan = s.strstart;
                    var match;
                    var len;
                    var best_len = s.prev_length;
                    var nice_match = s.nice_match;
                    var limit = (s.strstart > (s.w_size - MIN_LOOKAHEAD)) ?
                        s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0;
                    var _win = s.window;
                    var wmask = s.w_mask;
                    var prev = s.prev;
                    var strend = s.strstart + MAX_MATCH;
                    var scan_end1 = _win[scan + best_len - 1];
                    var scan_end = _win[scan + best_len];
                    if (s.prev_length >= s.good_match) {
                        chain_length >>= 2;
                    }
                    if (nice_match > s.lookahead) {
                        nice_match = s.lookahead;
                    }
                    do {
                        match = cur_match;
                        if (_win[match + best_len] !== scan_end ||
                            _win[match + best_len - 1] !== scan_end1 ||
                            _win[match] !== _win[scan] ||
                            _win[++match] !== _win[scan + 1]) {
                            continue;
                        }
                        scan += 2;
                        match++;
                        do {
                        } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
                            _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
                            _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
                            _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
                            scan < strend);
                        len = MAX_MATCH - (strend - scan);
                        scan = strend - MAX_MATCH;
                        if (len > best_len) {
                            s.match_start = cur_match;
                            best_len = len;
                            if (len >= nice_match) {
                                break;
                            }
                            scan_end1 = _win[scan + best_len - 1];
                            scan_end = _win[scan + best_len];
                        }
                    } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
                    if (best_len <= s.lookahead) {
                        return best_len;
                    }
                    return s.lookahead;
                }
                function fill_window(s) {
                    var _w_size = s.w_size;
                    var p, n, m, more, str;
                    do {
                        more = s.window_size - s.lookahead - s.strstart;
                        if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
                            utils.arraySet(s.window, s.window, _w_size, _w_size, 0);
                            s.match_start -= _w_size;
                            s.strstart -= _w_size;
                            s.block_start -= _w_size;
                            n = s.hash_size;
                            p = n;
                            do {
                                m = s.head[--p];
                                s.head[p] = (m >= _w_size ? m - _w_size : 0);
                            } while (--n);
                            n = _w_size;
                            p = n;
                            do {
                                m = s.prev[--p];
                                s.prev[p] = (m >= _w_size ? m - _w_size : 0);
                            } while (--n);
                            more += _w_size;
                        }
                        if (s.strm.avail_in === 0) {
                            break;
                        }
                        n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
                        s.lookahead += n;
                        if (s.lookahead + s.insert >= MIN_MATCH) {
                            str = s.strstart - s.insert;
                            s.ins_h = s.window[str];
                            s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + 1]) & s.hash_mask;
                            while (s.insert) {
                                s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
                                s.prev[str & s.w_mask] = s.head[s.ins_h];
                                s.head[s.ins_h] = str;
                                str++;
                                s.insert--;
                                if (s.lookahead + s.insert < MIN_MATCH) {
                                    break;
                                }
                            }
                        }
                    } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);
                }
                function deflate_stored(s, flush) {
                    var max_block_size = 0xffff;
                    if (max_block_size > s.pending_buf_size - 5) {
                        max_block_size = s.pending_buf_size - 5;
                    }
                    for (;;) {
                        if (s.lookahead <= 1) {
                            fill_window(s);
                            if (s.lookahead === 0 && flush === Z_NO_FLUSH) {
                                return BS_NEED_MORE;
                            }
                            if (s.lookahead === 0) {
                                break;
                            }
                        }
                        s.strstart += s.lookahead;
                        s.lookahead = 0;
                        var max_start = s.block_start + max_block_size;
                        if (s.strstart === 0 || s.strstart >= max_start) {
                            s.lookahead = s.strstart - max_start;
                            s.strstart = max_start;
                            flush_block_only(s, false);
                            if (s.strm.avail_out === 0) {
                                return BS_NEED_MORE;
                            }
                        }
                        if (s.strstart - s.block_start >= (s.w_size - MIN_LOOKAHEAD)) {
                            flush_block_only(s, false);
                            if (s.strm.avail_out === 0) {
                                return BS_NEED_MORE;
                            }
                        }
                    }
                    s.insert = 0;
                    if (flush === Z_FINISH) {
                        flush_block_only(s, true);
                        if (s.strm.avail_out === 0) {
                            return BS_FINISH_STARTED;
                        }
                        return BS_FINISH_DONE;
                    }
                    if (s.strstart > s.block_start) {
                        flush_block_only(s, false);
                        if (s.strm.avail_out === 0) {
                            return BS_NEED_MORE;
                        }
                    }
                    return BS_NEED_MORE;
                }
                function deflate_fast(s, flush) {
                    var hash_head;
                    var bflush;
                    for (;;) {
                        if (s.lookahead < MIN_LOOKAHEAD) {
                            fill_window(s);
                            if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
                                return BS_NEED_MORE;
                            }
                            if (s.lookahead === 0) {
                                break;
                            }
                        }
                        hash_head = 0;
                        if (s.lookahead >= MIN_MATCH) {
                            s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
                            hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
                            s.head[s.ins_h] = s.strstart;
                        }
                        if (hash_head !== 0 && ((s.strstart - hash_head) <= (s.w_size - MIN_LOOKAHEAD))) {
                            s.match_length = longest_match(s, hash_head);
                        }
                        if (s.match_length >= MIN_MATCH) {
                            bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);
                            s.lookahead -= s.match_length;
                            if (s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH) {
                                s.match_length--;
                                do {
                                    s.strstart++;
                                    s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
                                    hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
                                    s.head[s.ins_h] = s.strstart;
                                } while (--s.match_length !== 0);
                                s.strstart++;
                            }
                            else {
                                s.strstart += s.match_length;
                                s.match_length = 0;
                                s.ins_h = s.window[s.strstart];
                                s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + 1]) & s.hash_mask;
                            }
                        }
                        else {
                            bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
                            s.lookahead--;
                            s.strstart++;
                        }
                        if (bflush) {
                            flush_block_only(s, false);
                            if (s.strm.avail_out === 0) {
                                return BS_NEED_MORE;
                            }
                        }
                    }
                    s.insert = ((s.strstart < (MIN_MATCH - 1)) ? s.strstart : MIN_MATCH - 1);
                    if (flush === Z_FINISH) {
                        flush_block_only(s, true);
                        if (s.strm.avail_out === 0) {
                            return BS_FINISH_STARTED;
                        }
                        return BS_FINISH_DONE;
                    }
                    if (s.last_lit) {
                        flush_block_only(s, false);
                        if (s.strm.avail_out === 0) {
                            return BS_NEED_MORE;
                        }
                    }
                    return BS_BLOCK_DONE;
                }
                function deflate_slow(s, flush) {
                    var hash_head;
                    var bflush;
                    var max_insert;
                    for (;;) {
                        if (s.lookahead < MIN_LOOKAHEAD) {
                            fill_window(s);
                            if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
                                return BS_NEED_MORE;
                            }
                            if (s.lookahead === 0) {
                                break;
                            }
                        }
                        hash_head = 0;
                        if (s.lookahead >= MIN_MATCH) {
                            s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
                            hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
                            s.head[s.ins_h] = s.strstart;
                        }
                        s.prev_length = s.match_length;
                        s.prev_match = s.match_start;
                        s.match_length = MIN_MATCH - 1;
                        if (hash_head !== 0 && s.prev_length < s.max_lazy_match &&
                            s.strstart - hash_head <= (s.w_size - MIN_LOOKAHEAD)) {
                            s.match_length = longest_match(s, hash_head);
                            if (s.match_length <= 5 &&
                                (s.strategy === Z_FILTERED || (s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096))) {
                                s.match_length = MIN_MATCH - 1;
                            }
                        }
                        if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
                            max_insert = s.strstart + s.lookahead - MIN_MATCH;
                            bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
                            s.lookahead -= s.prev_length - 1;
                            s.prev_length -= 2;
                            do {
                                if (++s.strstart <= max_insert) {
                                    s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
                                    hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
                                    s.head[s.ins_h] = s.strstart;
                                }
                            } while (--s.prev_length !== 0);
                            s.match_available = 0;
                            s.match_length = MIN_MATCH - 1;
                            s.strstart++;
                            if (bflush) {
                                flush_block_only(s, false);
                                if (s.strm.avail_out === 0) {
                                    return BS_NEED_MORE;
                                }
                            }
                        }
                        else if (s.match_available) {
                            bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
                            if (bflush) {
                                flush_block_only(s, false);
                            }
                            s.strstart++;
                            s.lookahead--;
                            if (s.strm.avail_out === 0) {
                                return BS_NEED_MORE;
                            }
                        }
                        else {
                            s.match_available = 1;
                            s.strstart++;
                            s.lookahead--;
                        }
                    }
                    if (s.match_available) {
                        bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
                        s.match_available = 0;
                    }
                    s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
                    if (flush === Z_FINISH) {
                        flush_block_only(s, true);
                        if (s.strm.avail_out === 0) {
                            return BS_FINISH_STARTED;
                        }
                        return BS_FINISH_DONE;
                    }
                    if (s.last_lit) {
                        flush_block_only(s, false);
                        if (s.strm.avail_out === 0) {
                            return BS_NEED_MORE;
                        }
                    }
                    return BS_BLOCK_DONE;
                }
                function deflate_rle(s, flush) {
                    var bflush;
                    var prev;
                    var scan, strend;
                    var _win = s.window;
                    for (;;) {
                        if (s.lookahead <= MAX_MATCH) {
                            fill_window(s);
                            if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
                                return BS_NEED_MORE;
                            }
                            if (s.lookahead === 0) {
                                break;
                            }
                        }
                        s.match_length = 0;
                        if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
                            scan = s.strstart - 1;
                            prev = _win[scan];
                            if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
                                strend = s.strstart + MAX_MATCH;
                                do {
                                } while (prev === _win[++scan] && prev === _win[++scan] &&
                                    prev === _win[++scan] && prev === _win[++scan] &&
                                    prev === _win[++scan] && prev === _win[++scan] &&
                                    prev === _win[++scan] && prev === _win[++scan] &&
                                    scan < strend);
                                s.match_length = MAX_MATCH - (strend - scan);
                                if (s.match_length > s.lookahead) {
                                    s.match_length = s.lookahead;
                                }
                            }
                        }
                        if (s.match_length >= MIN_MATCH) {
                            bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);
                            s.lookahead -= s.match_length;
                            s.strstart += s.match_length;
                            s.match_length = 0;
                        }
                        else {
                            bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
                            s.lookahead--;
                            s.strstart++;
                        }
                        if (bflush) {
                            flush_block_only(s, false);
                            if (s.strm.avail_out === 0) {
                                return BS_NEED_MORE;
                            }
                        }
                    }
                    s.insert = 0;
                    if (flush === Z_FINISH) {
                        flush_block_only(s, true);
                        if (s.strm.avail_out === 0) {
                            return BS_FINISH_STARTED;
                        }
                        return BS_FINISH_DONE;
                    }
                    if (s.last_lit) {
                        flush_block_only(s, false);
                        if (s.strm.avail_out === 0) {
                            return BS_NEED_MORE;
                        }
                    }
                    return BS_BLOCK_DONE;
                }
                function deflate_huff(s, flush) {
                    var bflush;
                    for (;;) {
                        if (s.lookahead === 0) {
                            fill_window(s);
                            if (s.lookahead === 0) {
                                if (flush === Z_NO_FLUSH) {
                                    return BS_NEED_MORE;
                                }
                                break;
                            }
                        }
                        s.match_length = 0;
                        bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
                        s.lookahead--;
                        s.strstart++;
                        if (bflush) {
                            flush_block_only(s, false);
                            if (s.strm.avail_out === 0) {
                                return BS_NEED_MORE;
                            }
                        }
                    }
                    s.insert = 0;
                    if (flush === Z_FINISH) {
                        flush_block_only(s, true);
                        if (s.strm.avail_out === 0) {
                            return BS_FINISH_STARTED;
                        }
                        return BS_FINISH_DONE;
                    }
                    if (s.last_lit) {
                        flush_block_only(s, false);
                        if (s.strm.avail_out === 0) {
                            return BS_NEED_MORE;
                        }
                    }
                    return BS_BLOCK_DONE;
                }
                function Config(good_length, max_lazy, nice_length, max_chain, func) {
                    this.good_length = good_length;
                    this.max_lazy = max_lazy;
                    this.nice_length = nice_length;
                    this.max_chain = max_chain;
                    this.func = func;
                }
                var configuration_table;
                configuration_table = [
                    new Config(0, 0, 0, 0, deflate_stored),
                    new Config(4, 4, 8, 4, deflate_fast),
                    new Config(4, 5, 16, 8, deflate_fast),
                    new Config(4, 6, 32, 32, deflate_fast),
                    new Config(4, 4, 16, 16, deflate_slow),
                    new Config(8, 16, 32, 32, deflate_slow),
                    new Config(8, 16, 128, 128, deflate_slow),
                    new Config(8, 32, 128, 256, deflate_slow),
                    new Config(32, 128, 258, 1024, deflate_slow),
                    new Config(32, 258, 258, 4096, deflate_slow)
                ];
                function lm_init(s) {
                    s.window_size = 2 * s.w_size;
                    zero(s.head);
                    s.max_lazy_match = configuration_table[s.level].max_lazy;
                    s.good_match = configuration_table[s.level].good_length;
                    s.nice_match = configuration_table[s.level].nice_length;
                    s.max_chain_length = configuration_table[s.level].max_chain;
                    s.strstart = 0;
                    s.block_start = 0;
                    s.lookahead = 0;
                    s.insert = 0;
                    s.match_length = s.prev_length = MIN_MATCH - 1;
                    s.match_available = 0;
                    s.ins_h = 0;
                }
                function DeflateState() {
                    this.strm = null;
                    this.status = 0;
                    this.pending_buf = null;
                    this.pending_buf_size = 0;
                    this.pending_out = 0;
                    this.pending = 0;
                    this.wrap = 0;
                    this.gzhead = null;
                    this.gzindex = 0;
                    this.method = Z_DEFLATED;
                    this.last_flush = -1;
                    this.w_size = 0;
                    this.w_bits = 0;
                    this.w_mask = 0;
                    this.window = null;
                    this.window_size = 0;
                    this.prev = null;
                    this.head = null;
                    this.ins_h = 0;
                    this.hash_size = 0;
                    this.hash_bits = 0;
                    this.hash_mask = 0;
                    this.hash_shift = 0;
                    this.block_start = 0;
                    this.match_length = 0;
                    this.prev_match = 0;
                    this.match_available = 0;
                    this.strstart = 0;
                    this.match_start = 0;
                    this.lookahead = 0;
                    this.prev_length = 0;
                    this.max_chain_length = 0;
                    this.max_lazy_match = 0;
                    this.level = 0;
                    this.strategy = 0;
                    this.good_match = 0;
                    this.nice_match = 0;
                    this.dyn_ltree = new utils.Buf16(HEAP_SIZE * 2);
                    this.dyn_dtree = new utils.Buf16((2 * D_CODES + 1) * 2);
                    this.bl_tree = new utils.Buf16((2 * BL_CODES + 1) * 2);
                    zero(this.dyn_ltree);
                    zero(this.dyn_dtree);
                    zero(this.bl_tree);
                    this.l_desc = null;
                    this.d_desc = null;
                    this.bl_desc = null;
                    this.bl_count = new utils.Buf16(MAX_BITS + 1);
                    this.heap = new utils.Buf16(2 * L_CODES + 1);
                    zero(this.heap);
                    this.heap_len = 0;
                    this.heap_max = 0;
                    this.depth = new utils.Buf16(2 * L_CODES + 1);
                    zero(this.depth);
                    this.l_buf = 0;
                    this.lit_bufsize = 0;
                    this.last_lit = 0;
                    this.d_buf = 0;
                    this.opt_len = 0;
                    this.static_len = 0;
                    this.matches = 0;
                    this.insert = 0;
                    this.bi_buf = 0;
                    this.bi_valid = 0;
                }
                function deflateResetKeep(strm) {
                    var s;
                    if (!strm || !strm.state) {
                        return err(strm, Z_STREAM_ERROR);
                    }
                    strm.total_in = strm.total_out = 0;
                    strm.data_type = Z_UNKNOWN;
                    s = strm.state;
                    s.pending = 0;
                    s.pending_out = 0;
                    if (s.wrap < 0) {
                        s.wrap = -s.wrap;
                    }
                    s.status = (s.wrap ? INIT_STATE : BUSY_STATE);
                    strm.adler = (s.wrap === 2) ?
                        0
                        :
                            1;
                    s.last_flush = Z_NO_FLUSH;
                    trees._tr_init(s);
                    return Z_OK;
                }
                function deflateReset(strm) {
                    var ret = deflateResetKeep(strm);
                    if (ret === Z_OK) {
                        lm_init(strm.state);
                    }
                    return ret;
                }
                function deflateSetHeader(strm, head) {
                    if (!strm || !strm.state) {
                        return Z_STREAM_ERROR;
                    }
                    if (strm.state.wrap !== 2) {
                        return Z_STREAM_ERROR;
                    }
                    strm.state.gzhead = head;
                    return Z_OK;
                }
                function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
                    if (!strm) {
                        return Z_STREAM_ERROR;
                    }
                    var wrap = 1;
                    if (level === Z_DEFAULT_COMPRESSION) {
                        level = 6;
                    }
                    if (windowBits < 0) {
                        wrap = 0;
                        windowBits = -windowBits;
                    }
                    else if (windowBits > 15) {
                        wrap = 2;
                        windowBits -= 16;
                    }
                    if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED ||
                        windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||
                        strategy < 0 || strategy > Z_FIXED) {
                        return err(strm, Z_STREAM_ERROR);
                    }
                    if (windowBits === 8) {
                        windowBits = 9;
                    }
                    var s = new DeflateState();
                    strm.state = s;
                    s.strm = strm;
                    s.wrap = wrap;
                    s.gzhead = null;
                    s.w_bits = windowBits;
                    s.w_size = 1 << s.w_bits;
                    s.w_mask = s.w_size - 1;
                    s.hash_bits = memLevel + 7;
                    s.hash_size = 1 << s.hash_bits;
                    s.hash_mask = s.hash_size - 1;
                    s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
                    s.window = new utils.Buf8(s.w_size * 2);
                    s.head = new utils.Buf16(s.hash_size);
                    s.prev = new utils.Buf16(s.w_size);
                    s.lit_bufsize = 1 << (memLevel + 6);
                    s.pending_buf_size = s.lit_bufsize * 4;
                    s.pending_buf = new utils.Buf8(s.pending_buf_size);
                    s.d_buf = 1 * s.lit_bufsize;
                    s.l_buf = (1 + 2) * s.lit_bufsize;
                    s.level = level;
                    s.strategy = strategy;
                    s.method = method;
                    return deflateReset(strm);
                }
                function deflateInit(strm, level) {
                    return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
                }
                function deflate(strm, flush) {
                    var old_flush, s;
                    var beg, val;
                    if (!strm || !strm.state ||
                        flush > Z_BLOCK || flush < 0) {
                        return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
                    }
                    s = strm.state;
                    if (!strm.output ||
                        (!strm.input && strm.avail_in !== 0) ||
                        (s.status === FINISH_STATE && flush !== Z_FINISH)) {
                        return err(strm, (strm.avail_out === 0) ? Z_BUF_ERROR : Z_STREAM_ERROR);
                    }
                    s.strm = strm;
                    old_flush = s.last_flush;
                    s.last_flush = flush;
                    if (s.status === INIT_STATE) {
                        if (s.wrap === 2) {
                            strm.adler = 0;
                            put_byte(s, 31);
                            put_byte(s, 139);
                            put_byte(s, 8);
                            if (!s.gzhead) {
                                put_byte(s, 0);
                                put_byte(s, 0);
                                put_byte(s, 0);
                                put_byte(s, 0);
                                put_byte(s, 0);
                                put_byte(s, s.level === 9 ? 2 :
                                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?
                                        4 : 0));
                                put_byte(s, OS_CODE);
                                s.status = BUSY_STATE;
                            }
                            else {
                                put_byte(s, (s.gzhead.text ? 1 : 0) +
                                    (s.gzhead.hcrc ? 2 : 0) +
                                    (!s.gzhead.extra ? 0 : 4) +
                                    (!s.gzhead.name ? 0 : 8) +
                                    (!s.gzhead.comment ? 0 : 16));
                                put_byte(s, s.gzhead.time & 0xff);
                                put_byte(s, (s.gzhead.time >> 8) & 0xff);
                                put_byte(s, (s.gzhead.time >> 16) & 0xff);
                                put_byte(s, (s.gzhead.time >> 24) & 0xff);
                                put_byte(s, s.level === 9 ? 2 :
                                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?
                                        4 : 0));
                                put_byte(s, s.gzhead.os & 0xff);
                                if (s.gzhead.extra && s.gzhead.extra.length) {
                                    put_byte(s, s.gzhead.extra.length & 0xff);
                                    put_byte(s, (s.gzhead.extra.length >> 8) & 0xff);
                                }
                                if (s.gzhead.hcrc) {
                                    strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
                                }
                                s.gzindex = 0;
                                s.status = EXTRA_STATE;
                            }
                        }
                        else {
                            var header = (Z_DEFLATED + ((s.w_bits - 8) << 4)) << 8;
                            var level_flags = -1;
                            if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
                                level_flags = 0;
                            }
                            else if (s.level < 6) {
                                level_flags = 1;
                            }
                            else if (s.level === 6) {
                                level_flags = 2;
                            }
                            else {
                                level_flags = 3;
                            }
                            header |= (level_flags << 6);
                            if (s.strstart !== 0) {
                                header |= PRESET_DICT;
                            }
                            header += 31 - (header % 31);
                            s.status = BUSY_STATE;
                            putShortMSB(s, header);
                            if (s.strstart !== 0) {
                                putShortMSB(s, strm.adler >>> 16);
                                putShortMSB(s, strm.adler & 0xffff);
                            }
                            strm.adler = 1;
                        }
                    }
                    if (s.status === EXTRA_STATE) {
                        if (s.gzhead.extra) {
                            beg = s.pending;
                            while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {
                                if (s.pending === s.pending_buf_size) {
                                    if (s.gzhead.hcrc && s.pending > beg) {
                                        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
                                    }
                                    flush_pending(strm);
                                    beg = s.pending;
                                    if (s.pending === s.pending_buf_size) {
                                        break;
                                    }
                                }
                                put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);
                                s.gzindex++;
                            }
                            if (s.gzhead.hcrc && s.pending > beg) {
                                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
                            }
                            if (s.gzindex === s.gzhead.extra.length) {
                                s.gzindex = 0;
                                s.status = NAME_STATE;
                            }
                        }
                        else {
                            s.status = NAME_STATE;
                        }
                    }
                    if (s.status === NAME_STATE) {
                        if (s.gzhead.name) {
                            beg = s.pending;
                            do {
                                if (s.pending === s.pending_buf_size) {
                                    if (s.gzhead.hcrc && s.pending > beg) {
                                        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
                                    }
                                    flush_pending(strm);
                                    beg = s.pending;
                                    if (s.pending === s.pending_buf_size) {
                                        val = 1;
                                        break;
                                    }
                                }
                                if (s.gzindex < s.gzhead.name.length) {
                                    val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;
                                }
                                else {
                                    val = 0;
                                }
                                put_byte(s, val);
                            } while (val !== 0);
                            if (s.gzhead.hcrc && s.pending > beg) {
                                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
                            }
                            if (val === 0) {
                                s.gzindex = 0;
                                s.status = COMMENT_STATE;
                            }
                        }
                        else {
                            s.status = COMMENT_STATE;
                        }
                    }
                    if (s.status === COMMENT_STATE) {
                        if (s.gzhead.comment) {
                            beg = s.pending;
                            do {
                                if (s.pending === s.pending_buf_size) {
                                    if (s.gzhead.hcrc && s.pending > beg) {
                                        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
                                    }
                                    flush_pending(strm);
                                    beg = s.pending;
                                    if (s.pending === s.pending_buf_size) {
                                        val = 1;
                                        break;
                                    }
                                }
                                if (s.gzindex < s.gzhead.comment.length) {
                                    val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;
                                }
                                else {
                                    val = 0;
                                }
                                put_byte(s, val);
                            } while (val !== 0);
                            if (s.gzhead.hcrc && s.pending > beg) {
                                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
                            }
                            if (val === 0) {
                                s.status = HCRC_STATE;
                            }
                        }
                        else {
                            s.status = HCRC_STATE;
                        }
                    }
                    if (s.status === HCRC_STATE) {
                        if (s.gzhead.hcrc) {
                            if (s.pending + 2 > s.pending_buf_size) {
                                flush_pending(strm);
                            }
                            if (s.pending + 2 <= s.pending_buf_size) {
                                put_byte(s, strm.adler & 0xff);
                                put_byte(s, (strm.adler >> 8) & 0xff);
                                strm.adler = 0;
                                s.status = BUSY_STATE;
                            }
                        }
                        else {
                            s.status = BUSY_STATE;
                        }
                    }
                    if (s.pending !== 0) {
                        flush_pending(strm);
                        if (strm.avail_out === 0) {
                            s.last_flush = -1;
                            return Z_OK;
                        }
                    }
                    else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) &&
                        flush !== Z_FINISH) {
                        return err(strm, Z_BUF_ERROR);
                    }
                    if (s.status === FINISH_STATE && strm.avail_in !== 0) {
                        return err(strm, Z_BUF_ERROR);
                    }
                    if (strm.avail_in !== 0 || s.lookahead !== 0 ||
                        (flush !== Z_NO_FLUSH && s.status !== FINISH_STATE)) {
                        var bstate = (s.strategy === Z_HUFFMAN_ONLY) ? deflate_huff(s, flush) :
                            (s.strategy === Z_RLE ? deflate_rle(s, flush) :
                                configuration_table[s.level].func(s, flush));
                        if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
                            s.status = FINISH_STATE;
                        }
                        if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
                            if (strm.avail_out === 0) {
                                s.last_flush = -1;
                            }
                            return Z_OK;
                        }
                        if (bstate === BS_BLOCK_DONE) {
                            if (flush === Z_PARTIAL_FLUSH) {
                                trees._tr_align(s);
                            }
                            else if (flush !== Z_BLOCK) {
                                trees._tr_stored_block(s, 0, 0, false);
                                if (flush === Z_FULL_FLUSH) {
                                    zero(s.head);
                                    if (s.lookahead === 0) {
                                        s.strstart = 0;
                                        s.block_start = 0;
                                        s.insert = 0;
                                    }
                                }
                            }
                            flush_pending(strm);
                            if (strm.avail_out === 0) {
                                s.last_flush = -1;
                                return Z_OK;
                            }
                        }
                    }
                    if (flush !== Z_FINISH) {
                        return Z_OK;
                    }
                    if (s.wrap <= 0) {
                        return Z_STREAM_END;
                    }
                    if (s.wrap === 2) {
                        put_byte(s, strm.adler & 0xff);
                        put_byte(s, (strm.adler >> 8) & 0xff);
                        put_byte(s, (strm.adler >> 16) & 0xff);
                        put_byte(s, (strm.adler >> 24) & 0xff);
                        put_byte(s, strm.total_in & 0xff);
                        put_byte(s, (strm.total_in >> 8) & 0xff);
                        put_byte(s, (strm.total_in >> 16) & 0xff);
                        put_byte(s, (strm.total_in >> 24) & 0xff);
                    }
                    else {
                        putShortMSB(s, strm.adler >>> 16);
                        putShortMSB(s, strm.adler & 0xffff);
                    }
                    flush_pending(strm);
                    if (s.wrap > 0) {
                        s.wrap = -s.wrap;
                    }
                    return s.pending !== 0 ? Z_OK : Z_STREAM_END;
                }
                function deflateEnd(strm) {
                    var status;
                    if (!strm || !strm.state) {
                        return Z_STREAM_ERROR;
                    }
                    status = strm.state.status;
                    if (status !== INIT_STATE &&
                        status !== EXTRA_STATE &&
                        status !== NAME_STATE &&
                        status !== COMMENT_STATE &&
                        status !== HCRC_STATE &&
                        status !== BUSY_STATE &&
                        status !== FINISH_STATE) {
                        return err(strm, Z_STREAM_ERROR);
                    }
                    strm.state = null;
                    return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
                }
                function deflateSetDictionary(strm, dictionary) {
                    var dictLength = dictionary.length;
                    var s;
                    var str, n;
                    var wrap;
                    var avail;
                    var next;
                    var input;
                    var tmpDict;
                    if (!strm || !strm.state) {
                        return Z_STREAM_ERROR;
                    }
                    s = strm.state;
                    wrap = s.wrap;
                    if (wrap === 2 || (wrap === 1 && s.status !== INIT_STATE) || s.lookahead) {
                        return Z_STREAM_ERROR;
                    }
                    if (wrap === 1) {
                        strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
                    }
                    s.wrap = 0;
                    if (dictLength >= s.w_size) {
                        if (wrap === 0) {
                            zero(s.head);
                            s.strstart = 0;
                            s.block_start = 0;
                            s.insert = 0;
                        }
                        tmpDict = new utils.Buf8(s.w_size);
                        utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);
                        dictionary = tmpDict;
                        dictLength = s.w_size;
                    }
                    avail = strm.avail_in;
                    next = strm.next_in;
                    input = strm.input;
                    strm.avail_in = dictLength;
                    strm.next_in = 0;
                    strm.input = dictionary;
                    fill_window(s);
                    while (s.lookahead >= MIN_MATCH) {
                        str = s.strstart;
                        n = s.lookahead - (MIN_MATCH - 1);
                        do {
                            s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
                            s.prev[str & s.w_mask] = s.head[s.ins_h];
                            s.head[s.ins_h] = str;
                            str++;
                        } while (--n);
                        s.strstart = str;
                        s.lookahead = MIN_MATCH - 1;
                        fill_window(s);
                    }
                    s.strstart += s.lookahead;
                    s.block_start = s.strstart;
                    s.insert = s.lookahead;
                    s.lookahead = 0;
                    s.match_length = s.prev_length = MIN_MATCH - 1;
                    s.match_available = 0;
                    strm.next_in = next;
                    strm.input = input;
                    strm.avail_in = avail;
                    s.wrap = wrap;
                    return Z_OK;
                }
                localExports.deflateInit = deflateInit;
                localExports.deflateInit2 = deflateInit2;
                localExports.deflateReset = deflateReset;
                localExports.deflateResetKeep = deflateResetKeep;
                localExports.deflateSetHeader = deflateSetHeader;
                localExports.deflate = deflate;
                localExports.deflateEnd = deflateEnd;
                localExports.deflateSetDictionary = deflateSetDictionary;
                localExports.deflateInfo = 'pako deflate (from Nodeca project)';
            }, { "../utils/common": 175, "./adler32": 176, "./crc32": 178, "./messages": 183, "./trees": 184 }], 180: [function (localRequire, localModule, localExports) {
                'use strict';
                var BAD = 30;
                var TYPE = 12;
                localModule.localExports = function inflate_fast(strm, start) {
                    var state;
                    var _in;
                    var last;
                    var _out;
                    var beg;
                    var end;
                    var dmax;
                    var wsize;
                    var whave;
                    var wnext;
                    var s_window;
                    var hold;
                    var bits;
                    var lcode;
                    var dcode;
                    var lmask;
                    var dmask;
                    var here;
                    var op;
                    var len;
                    var dist;
                    var from;
                    var from_source;
                    var input, output;
                    state = strm.state;
                    _in = strm.next_in;
                    input = strm.input;
                    last = _in + (strm.avail_in - 5);
                    _out = strm.next_out;
                    output = strm.output;
                    beg = _out - (start - strm.avail_out);
                    end = _out + (strm.avail_out - 257);
                    dmax = state.dmax;
                    wsize = state.wsize;
                    whave = state.whave;
                    wnext = state.wnext;
                    s_window = state.window;
                    hold = state.hold;
                    bits = state.bits;
                    lcode = state.lencode;
                    dcode = state.distcode;
                    lmask = (1 << state.lenbits) - 1;
                    dmask = (1 << state.distbits) - 1;
                    top: do {
                        if (bits < 15) {
                            hold += input[_in++] << bits;
                            bits += 8;
                            hold += input[_in++] << bits;
                            bits += 8;
                        }
                        here = lcode[hold & lmask];
                        dolen: for (;;) {
                            op = here >>> 24;
                            hold >>>= op;
                            bits -= op;
                            op = (here >>> 16) & 0xff;
                            if (op === 0) {
                                output[_out++] = here & 0xffff;
                            }
                            else if (op & 16) {
                                len = here & 0xffff;
                                op &= 15;
                                if (op) {
                                    if (bits < op) {
                                        hold += input[_in++] << bits;
                                        bits += 8;
                                    }
                                    len += hold & ((1 << op) - 1);
                                    hold >>>= op;
                                    bits -= op;
                                }
                                if (bits < 15) {
                                    hold += input[_in++] << bits;
                                    bits += 8;
                                    hold += input[_in++] << bits;
                                    bits += 8;
                                }
                                here = dcode[hold & dmask];
                                dodist: for (;;) {
                                    op = here >>> 24;
                                    hold >>>= op;
                                    bits -= op;
                                    op = (here >>> 16) & 0xff;
                                    if (op & 16) {
                                        dist = here & 0xffff;
                                        op &= 15;
                                        if (bits < op) {
                                            hold += input[_in++] << bits;
                                            bits += 8;
                                            if (bits < op) {
                                                hold += input[_in++] << bits;
                                                bits += 8;
                                            }
                                        }
                                        dist += hold & ((1 << op) - 1);
                                        if (dist > dmax) {
                                            strm.msg = 'invalid distance too far back';
                                            state.mode = BAD;
                                            break top;
                                        }
                                        hold >>>= op;
                                        bits -= op;
                                        op = _out - beg;
                                        if (dist > op) {
                                            op = dist - op;
                                            if (op > whave) {
                                                if (state.sane) {
                                                    strm.msg = 'invalid distance too far back';
                                                    state.mode = BAD;
                                                    break top;
                                                }
                                            }
                                            from = 0;
                                            from_source = s_window;
                                            if (wnext === 0) {
                                                from += wsize - op;
                                                if (op < len) {
                                                    len -= op;
                                                    do {
                                                        output[_out++] = s_window[from++];
                                                    } while (--op);
                                                    from = _out - dist;
                                                    from_source = output;
                                                }
                                            }
                                            else if (wnext < op) {
                                                from += wsize + wnext - op;
                                                op -= wnext;
                                                if (op < len) {
                                                    len -= op;
                                                    do {
                                                        output[_out++] = s_window[from++];
                                                    } while (--op);
                                                    from = 0;
                                                    if (wnext < len) {
                                                        op = wnext;
                                                        len -= op;
                                                        do {
                                                            output[_out++] = s_window[from++];
                                                        } while (--op);
                                                        from = _out - dist;
                                                        from_source = output;
                                                    }
                                                }
                                            }
                                            else {
                                                from += wnext - op;
                                                if (op < len) {
                                                    len -= op;
                                                    do {
                                                        output[_out++] = s_window[from++];
                                                    } while (--op);
                                                    from = _out - dist;
                                                    from_source = output;
                                                }
                                            }
                                            while (len > 2) {
                                                output[_out++] = from_source[from++];
                                                output[_out++] = from_source[from++];
                                                output[_out++] = from_source[from++];
                                                len -= 3;
                                            }
                                            if (len) {
                                                output[_out++] = from_source[from++];
                                                if (len > 1) {
                                                    output[_out++] = from_source[from++];
                                                }
                                            }
                                        }
                                        else {
                                            from = _out - dist;
                                            do {
                                                output[_out++] = output[from++];
                                                output[_out++] = output[from++];
                                                output[_out++] = output[from++];
                                                len -= 3;
                                            } while (len > 2);
                                            if (len) {
                                                output[_out++] = output[from++];
                                                if (len > 1) {
                                                    output[_out++] = output[from++];
                                                }
                                            }
                                        }
                                    }
                                    else if ((op & 64) === 0) {
                                        here = dcode[(here & 0xffff) + (hold & ((1 << op) - 1))];
                                        continue dodist;
                                    }
                                    else {
                                        strm.msg = 'invalid distance code';
                                        state.mode = BAD;
                                        break top;
                                    }
                                    break;
                                }
                            }
                            else if ((op & 64) === 0) {
                                here = lcode[(here & 0xffff) + (hold & ((1 << op) - 1))];
                                continue dolen;
                            }
                            else if (op & 32) {
                                state.mode = TYPE;
                                break top;
                            }
                            else {
                                strm.msg = 'invalid literal/length code';
                                state.mode = BAD;
                                break top;
                            }
                            break;
                        }
                    } while (_in < last && _out < end);
                    len = bits >> 3;
                    _in -= len;
                    bits -= len << 3;
                    hold &= (1 << bits) - 1;
                    strm.next_in = _in;
                    strm.next_out = _out;
                    strm.avail_in = (_in < last ? 5 + (last - _in) : 5 - (_in - last));
                    strm.avail_out = (_out < end ? 257 + (end - _out) : 257 - (_out - end));
                    state.hold = hold;
                    state.bits = bits;
                    return;
                };
            }, {}], 181: [function (localRequire, localModule, localExports) {
                'use strict';
                var utils = localRequire('../utils/common');
                var adler32 = localRequire('./adler32');
                var crc32 = localRequire('./crc32');
                var inflate_fast = localRequire('./inffast');
                var inflate_table = localRequire('./inftrees');
                var CODES = 0;
                var LENS = 1;
                var DISTS = 2;
                var Z_FINISH = 4;
                var Z_BLOCK = 5;
                var Z_TREES = 6;
                var Z_OK = 0;
                var Z_STREAM_END = 1;
                var Z_NEED_DICT = 2;
                var Z_STREAM_ERROR = -2;
                var Z_DATA_ERROR = -3;
                var Z_MEM_ERROR = -4;
                var Z_BUF_ERROR = -5;
                var Z_DEFLATED = 8;
                var HEAD = 1;
                var FLAGS = 2;
                var TIME = 3;
                var OS = 4;
                var EXLEN = 5;
                var EXTRA = 6;
                var NAME = 7;
                var COMMENT = 8;
                var HCRC = 9;
                var DICTID = 10;
                var DICT = 11;
                var TYPE = 12;
                var TYPEDO = 13;
                var STORED = 14;
                var COPY_ = 15;
                var COPY = 16;
                var TABLE = 17;
                var LENLENS = 18;
                var CODELENS = 19;
                var LEN_ = 20;
                var LEN = 21;
                var LENEXT = 22;
                var DIST = 23;
                var DISTEXT = 24;
                var MATCH = 25;
                var LIT = 26;
                var CHECK = 27;
                var LENGTH = 28;
                var DONE = 29;
                var BAD = 30;
                var MEM = 31;
                var SYNC = 32;
                var ENOUGH_LENS = 852;
                var ENOUGH_DISTS = 592;
                var MAX_WBITS = 15;
                var DEF_WBITS = MAX_WBITS;
                function zswap32(q) {
                    return (((q >>> 24) & 0xff) +
                        ((q >>> 8) & 0xff00) +
                        ((q & 0xff00) << 8) +
                        ((q & 0xff) << 24));
                }
                function InflateState() {
                    this.mode = 0;
                    this.last = false;
                    this.wrap = 0;
                    this.havedict = false;
                    this.flags = 0;
                    this.dmax = 0;
                    this.check = 0;
                    this.total = 0;
                    this.head = null;
                    this.wbits = 0;
                    this.wsize = 0;
                    this.whave = 0;
                    this.wnext = 0;
                    this.window = null;
                    this.hold = 0;
                    this.bits = 0;
                    this.length = 0;
                    this.offset = 0;
                    this.extra = 0;
                    this.lencode = null;
                    this.distcode = null;
                    this.lenbits = 0;
                    this.distbits = 0;
                    this.ncode = 0;
                    this.nlen = 0;
                    this.ndist = 0;
                    this.have = 0;
                    this.next = null;
                    this.lens = new utils.Buf16(320);
                    this.work = new utils.Buf16(288);
                    this.lendyn = null;
                    this.distdyn = null;
                    this.sane = 0;
                    this.back = 0;
                    this.was = 0;
                }
                function inflateResetKeep(strm) {
                    var state;
                    if (!strm || !strm.state) {
                        return Z_STREAM_ERROR;
                    }
                    state = strm.state;
                    strm.total_in = strm.total_out = state.total = 0;
                    strm.msg = '';
                    if (state.wrap) {
                        strm.adler = state.wrap & 1;
                    }
                    state.mode = HEAD;
                    state.last = 0;
                    state.havedict = 0;
                    state.dmax = 32768;
                    state.head = null;
                    state.hold = 0;
                    state.bits = 0;
                    state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);
                    state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);
                    state.sane = 1;
                    state.back = -1;
                    return Z_OK;
                }
                function inflateReset(strm) {
                    var state;
                    if (!strm || !strm.state) {
                        return Z_STREAM_ERROR;
                    }
                    state = strm.state;
                    state.wsize = 0;
                    state.whave = 0;
                    state.wnext = 0;
                    return inflateResetKeep(strm);
                }
                function inflateReset2(strm, windowBits) {
                    var wrap;
                    var state;
                    if (!strm || !strm.state) {
                        return Z_STREAM_ERROR;
                    }
                    state = strm.state;
                    if (windowBits < 0) {
                        wrap = 0;
                        windowBits = -windowBits;
                    }
                    else {
                        wrap = (windowBits >> 4) + 1;
                        if (windowBits < 48) {
                            windowBits &= 15;
                        }
                    }
                    if (windowBits && (windowBits < 8 || windowBits > 15)) {
                        return Z_STREAM_ERROR;
                    }
                    if (state.window !== null && state.wbits !== windowBits) {
                        state.window = null;
                    }
                    state.wrap = wrap;
                    state.wbits = windowBits;
                    return inflateReset(strm);
                }
                function inflateInit2(strm, windowBits) {
                    var ret;
                    var state;
                    if (!strm) {
                        return Z_STREAM_ERROR;
                    }
                    state = new InflateState();
                    strm.state = state;
                    state.window = null;
                    ret = inflateReset2(strm, windowBits);
                    if (ret !== Z_OK) {
                        strm.state = null;
                    }
                    return ret;
                }
                function inflateInit(strm) {
                    return inflateInit2(strm, DEF_WBITS);
                }
                var virgin = true;
                var lenfix, distfix;
                function fixedtables(state) {
                    if (virgin) {
                        var sym;
                        lenfix = new utils.Buf32(512);
                        distfix = new utils.Buf32(32);
                        sym = 0;
                        while (sym < 144) {
                            state.lens[sym++] = 8;
                        }
                        while (sym < 256) {
                            state.lens[sym++] = 9;
                        }
                        while (sym < 280) {
                            state.lens[sym++] = 7;
                        }
                        while (sym < 288) {
                            state.lens[sym++] = 8;
                        }
                        inflate_table(LENS, state.lens, 0, 288, lenfix, 0, state.work, { bits: 9 });
                        sym = 0;
                        while (sym < 32) {
                            state.lens[sym++] = 5;
                        }
                        inflate_table(DISTS, state.lens, 0, 32, distfix, 0, state.work, { bits: 5 });
                        virgin = false;
                    }
                    state.lencode = lenfix;
                    state.lenbits = 9;
                    state.distcode = distfix;
                    state.distbits = 5;
                }
                function updatewindow(strm, src, end, copy) {
                    var dist;
                    var state = strm.state;
                    if (state.window === null) {
                        state.wsize = 1 << state.wbits;
                        state.wnext = 0;
                        state.whave = 0;
                        state.window = new utils.Buf8(state.wsize);
                    }
                    if (copy >= state.wsize) {
                        utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);
                        state.wnext = 0;
                        state.whave = state.wsize;
                    }
                    else {
                        dist = state.wsize - state.wnext;
                        if (dist > copy) {
                            dist = copy;
                        }
                        utils.arraySet(state.window, src, end - copy, dist, state.wnext);
                        copy -= dist;
                        if (copy) {
                            utils.arraySet(state.window, src, end - copy, copy, 0);
                            state.wnext = copy;
                            state.whave = state.wsize;
                        }
                        else {
                            state.wnext += dist;
                            if (state.wnext === state.wsize) {
                                state.wnext = 0;
                            }
                            if (state.whave < state.wsize) {
                                state.whave += dist;
                            }
                        }
                    }
                    return 0;
                }
                function inflate(strm, flush) {
                    var state;
                    var input, output;
                    var next;
                    var put;
                    var have, left;
                    var hold;
                    var bits;
                    var _in, _out;
                    var copy;
                    var from;
                    var from_source;
                    var here = 0;
                    var here_bits, here_op, here_val;
                    var last_bits, last_op, last_val;
                    var len;
                    var ret;
                    var hbuf = new utils.Buf8(4);
                    var opts;
                    var n;
                    var order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
                    if (!strm || !strm.state || !strm.output ||
                        (!strm.input && strm.avail_in !== 0)) {
                        return Z_STREAM_ERROR;
                    }
                    state = strm.state;
                    if (state.mode === TYPE) {
                        state.mode = TYPEDO;
                    }
                    put = strm.next_out;
                    output = strm.output;
                    left = strm.avail_out;
                    next = strm.next_in;
                    input = strm.input;
                    have = strm.avail_in;
                    hold = state.hold;
                    bits = state.bits;
                    _in = have;
                    _out = left;
                    ret = Z_OK;
                    inf_leave: for (;;) {
                        switch (state.mode) {
                            case HEAD:
                                if (state.wrap === 0) {
                                    state.mode = TYPEDO;
                                    break;
                                }
                                while (bits < 16) {
                                    if (have === 0) {
                                        break inf_leave;
                                    }
                                    have--;
                                    hold += input[next++] << bits;
                                    bits += 8;
                                }
                                if ((state.wrap & 2) && hold === 0x8b1f) {
                                    state.check = 0;
                                    hbuf[0] = hold & 0xff;
                                    hbuf[1] = (hold >>> 8) & 0xff;
                                    state.check = crc32(state.check, hbuf, 2, 0);
                                    hold = 0;
                                    bits = 0;
                                    state.mode = FLAGS;
                                    break;
                                }
                                state.flags = 0;
                                if (state.head) {
                                    state.head.done = false;
                                }
                                if (!(state.wrap & 1) ||
                                    (((hold & 0xff) << 8) + (hold >> 8)) % 31) {
                                    strm.msg = 'incorrect header check';
                                    state.mode = BAD;
                                    break;
                                }
                                if ((hold & 0x0f) !== Z_DEFLATED) {
                                    strm.msg = 'unknown compression method';
                                    state.mode = BAD;
                                    break;
                                }
                                hold >>>= 4;
                                bits -= 4;
                                len = (hold & 0x0f) + 8;
                                if (state.wbits === 0) {
                                    state.wbits = len;
                                }
                                else if (len > state.wbits) {
                                    strm.msg = 'invalid window size';
                                    state.mode = BAD;
                                    break;
                                }
                                state.dmax = 1 << len;
                                strm.adler = state.check = 1;
                                state.mode = hold & 0x200 ? DICTID : TYPE;
                                hold = 0;
                                bits = 0;
                                break;
                            case FLAGS:
                                while (bits < 16) {
                                    if (have === 0) {
                                        break inf_leave;
                                    }
                                    have--;
                                    hold += input[next++] << bits;
                                    bits += 8;
                                }
                                state.flags = hold;
                                if ((state.flags & 0xff) !== Z_DEFLATED) {
                                    strm.msg = 'unknown compression method';
                                    state.mode = BAD;
                                    break;
                                }
                                if (state.flags & 0xe000) {
                                    strm.msg = 'unknown header flags set';
                                    state.mode = BAD;
                                    break;
                                }
                                if (state.head) {
                                    state.head.text = ((hold >> 8) & 1);
                                }
                                if (state.flags & 0x0200) {
                                    hbuf[0] = hold & 0xff;
                                    hbuf[1] = (hold >>> 8) & 0xff;
                                    state.check = crc32(state.check, hbuf, 2, 0);
                                }
                                hold = 0;
                                bits = 0;
                                state.mode = TIME;
                            case TIME:
                                while (bits < 32) {
                                    if (have === 0) {
                                        break inf_leave;
                                    }
                                    have--;
                                    hold += input[next++] << bits;
                                    bits += 8;
                                }
                                if (state.head) {
                                    state.head.time = hold;
                                }
                                if (state.flags & 0x0200) {
                                    hbuf[0] = hold & 0xff;
                                    hbuf[1] = (hold >>> 8) & 0xff;
                                    hbuf[2] = (hold >>> 16) & 0xff;
                                    hbuf[3] = (hold >>> 24) & 0xff;
                                    state.check = crc32(state.check, hbuf, 4, 0);
                                }
                                hold = 0;
                                bits = 0;
                                state.mode = OS;
                            case OS:
                                while (bits < 16) {
                                    if (have === 0) {
                                        break inf_leave;
                                    }
                                    have--;
                                    hold += input[next++] << bits;
                                    bits += 8;
                                }
                                if (state.head) {
                                    state.head.xflags = (hold & 0xff);
                                    state.head.os = (hold >> 8);
                                }
                                if (state.flags & 0x0200) {
                                    hbuf[0] = hold & 0xff;
                                    hbuf[1] = (hold >>> 8) & 0xff;
                                    state.check = crc32(state.check, hbuf, 2, 0);
                                }
                                hold = 0;
                                bits = 0;
                                state.mode = EXLEN;
                            case EXLEN:
                                if (state.flags & 0x0400) {
                                    while (bits < 16) {
                                        if (have === 0) {
                                            break inf_leave;
                                        }
                                        have--;
                                        hold += input[next++] << bits;
                                        bits += 8;
                                    }
                                    state.length = hold;
                                    if (state.head) {
                                        state.head.extra_len = hold;
                                    }
                                    if (state.flags & 0x0200) {
                                        hbuf[0] = hold & 0xff;
                                        hbuf[1] = (hold >>> 8) & 0xff;
                                        state.check = crc32(state.check, hbuf, 2, 0);
                                    }
                                    hold = 0;
                                    bits = 0;
                                }
                                else if (state.head) {
                                    state.head.extra = null;
                                }
                                state.mode = EXTRA;
                            case EXTRA:
                                if (state.flags & 0x0400) {
                                    copy = state.length;
                                    if (copy > have) {
                                        copy = have;
                                    }
                                    if (copy) {
                                        if (state.head) {
                                            len = state.head.extra_len - state.length;
                                            if (!state.head.extra) {
                                                state.head.extra = new Array(state.head.extra_len);
                                            }
                                            utils.arraySet(state.head.extra, input, next, copy, len);
                                        }
                                        if (state.flags & 0x0200) {
                                            state.check = crc32(state.check, input, copy, next);
                                        }
                                        have -= copy;
                                        next += copy;
                                        state.length -= copy;
                                    }
                                    if (state.length) {
                                        break inf_leave;
                                    }
                                }
                                state.length = 0;
                                state.mode = NAME;
                            case NAME:
                                if (state.flags & 0x0800) {
                                    if (have === 0) {
                                        break inf_leave;
                                    }
                                    copy = 0;
                                    do {
                                        len = input[next + copy++];
                                        if (state.head && len &&
                                            (state.length < 65536)) {
                                            state.head.name += String.fromCharCode(len);
                                        }
                                    } while (len && copy < have);
                                    if (state.flags & 0x0200) {
                                        state.check = crc32(state.check, input, copy, next);
                                    }
                                    have -= copy;
                                    next += copy;
                                    if (len) {
                                        break inf_leave;
                                    }
                                }
                                else if (state.head) {
                                    state.head.name = null;
                                }
                                state.length = 0;
                                state.mode = COMMENT;
                            case COMMENT:
                                if (state.flags & 0x1000) {
                                    if (have === 0) {
                                        break inf_leave;
                                    }
                                    copy = 0;
                                    do {
                                        len = input[next + copy++];
                                        if (state.head && len &&
                                            (state.length < 65536)) {
                                            state.head.comment += String.fromCharCode(len);
                                        }
                                    } while (len && copy < have);
                                    if (state.flags & 0x0200) {
                                        state.check = crc32(state.check, input, copy, next);
                                    }
                                    have -= copy;
                                    next += copy;
                                    if (len) {
                                        break inf_leave;
                                    }
                                }
                                else if (state.head) {
                                    state.head.comment = null;
                                }
                                state.mode = HCRC;
                            case HCRC:
                                if (state.flags & 0x0200) {
                                    while (bits < 16) {
                                        if (have === 0) {
                                            break inf_leave;
                                        }
                                        have--;
                                        hold += input[next++] << bits;
                                        bits += 8;
                                    }
                                    if (hold !== (state.check & 0xffff)) {
                                        strm.msg = 'header crc mismatch';
                                        state.mode = BAD;
                                        break;
                                    }
                                    hold = 0;
                                    bits = 0;
                                }
                                if (state.head) {
                                    state.head.hcrc = ((state.flags >> 9) & 1);
                                    state.head.done = true;
                                }
                                strm.adler = state.check = 0;
                                state.mode = TYPE;
                                break;
                            case DICTID:
                                while (bits < 32) {
                                    if (have === 0) {
                                        break inf_leave;
                                    }
                                    have--;
                                    hold += input[next++] << bits;
                                    bits += 8;
                                }
                                strm.adler = state.check = zswap32(hold);
                                hold = 0;
                                bits = 0;
                                state.mode = DICT;
                            case DICT:
                                if (state.havedict === 0) {
                                    strm.next_out = put;
                                    strm.avail_out = left;
                                    strm.next_in = next;
                                    strm.avail_in = have;
                                    state.hold = hold;
                                    state.bits = bits;
                                    return Z_NEED_DICT;
                                }
                                strm.adler = state.check = 1;
                                state.mode = TYPE;
                            case TYPE:
                                if (flush === Z_BLOCK || flush === Z_TREES) {
                                    break inf_leave;
                                }
                            case TYPEDO:
                                if (state.last) {
                                    hold >>>= bits & 7;
                                    bits -= bits & 7;
                                    state.mode = CHECK;
                                    break;
                                }
                                while (bits < 3) {
                                    if (have === 0) {
                                        break inf_leave;
                                    }
                                    have--;
                                    hold += input[next++] << bits;
                                    bits += 8;
                                }
                                state.last = (hold & 0x01);
                                hold >>>= 1;
                                bits -= 1;
                                switch ((hold & 0x03)) {
                                    case 0:
                                        state.mode = STORED;
                                        break;
                                    case 1:
                                        fixedtables(state);
                                        state.mode = LEN_;
                                        if (flush === Z_TREES) {
                                            hold >>>= 2;
                                            bits -= 2;
                                            break inf_leave;
                                        }
                                        break;
                                    case 2:
                                        state.mode = TABLE;
                                        break;
                                    case 3:
                                        strm.msg = 'invalid block type';
                                        state.mode = BAD;
                                }
                                hold >>>= 2;
                                bits -= 2;
                                break;
                            case STORED:
                                hold >>>= bits & 7;
                                bits -= bits & 7;
                                while (bits < 32) {
                                    if (have === 0) {
                                        break inf_leave;
                                    }
                                    have--;
                                    hold += input[next++] << bits;
                                    bits += 8;
                                }
                                if ((hold & 0xffff) !== ((hold >>> 16) ^ 0xffff)) {
                                    strm.msg = 'invalid stored block lengths';
                                    state.mode = BAD;
                                    break;
                                }
                                state.length = hold & 0xffff;
                                hold = 0;
                                bits = 0;
                                state.mode = COPY_;
                                if (flush === Z_TREES) {
                                    break inf_leave;
                                }
                            case COPY_:
                                state.mode = COPY;
                            case COPY:
                                copy = state.length;
                                if (copy) {
                                    if (copy > have) {
                                        copy = have;
                                    }
                                    if (copy > left) {
                                        copy = left;
                                    }
                                    if (copy === 0) {
                                        break inf_leave;
                                    }
                                    utils.arraySet(output, input, next, copy, put);
                                    have -= copy;
                                    next += copy;
                                    left -= copy;
                                    put += copy;
                                    state.length -= copy;
                                    break;
                                }
                                state.mode = TYPE;
                                break;
                            case TABLE:
                                while (bits < 14) {
                                    if (have === 0) {
                                        break inf_leave;
                                    }
                                    have--;
                                    hold += input[next++] << bits;
                                    bits += 8;
                                }
                                state.nlen = (hold & 0x1f) + 257;
                                hold >>>= 5;
                                bits -= 5;
                                state.ndist = (hold & 0x1f) + 1;
                                hold >>>= 5;
                                bits -= 5;
                                state.ncode = (hold & 0x0f) + 4;
                                hold >>>= 4;
                                bits -= 4;
                                if (state.nlen > 286 || state.ndist > 30) {
                                    strm.msg = 'too many length or distance symbols';
                                    state.mode = BAD;
                                    break;
                                }
                                state.have = 0;
                                state.mode = LENLENS;
                            case LENLENS:
                                while (state.have < state.ncode) {
                                    while (bits < 3) {
                                        if (have === 0) {
                                            break inf_leave;
                                        }
                                        have--;
                                        hold += input[next++] << bits;
                                        bits += 8;
                                    }
                                    state.lens[order[state.have++]] = (hold & 0x07);
                                    hold >>>= 3;
                                    bits -= 3;
                                }
                                while (state.have < 19) {
                                    state.lens[order[state.have++]] = 0;
                                }
                                state.lencode = state.lendyn;
                                state.lenbits = 7;
                                opts = { bits: state.lenbits };
                                ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
                                state.lenbits = opts.bits;
                                if (ret) {
                                    strm.msg = 'invalid code lengths set';
                                    state.mode = BAD;
                                    break;
                                }
                                state.have = 0;
                                state.mode = CODELENS;
                            case CODELENS:
                                while (state.have < state.nlen + state.ndist) {
                                    for (;;) {
                                        here = state.lencode[hold & ((1 << state.lenbits) - 1)];
                                        here_bits = here >>> 24;
                                        here_op = (here >>> 16) & 0xff;
                                        here_val = here & 0xffff;
                                        if ((here_bits) <= bits) {
                                            break;
                                        }
                                        if (have === 0) {
                                            break inf_leave;
                                        }
                                        have--;
                                        hold += input[next++] << bits;
                                        bits += 8;
                                    }
                                    if (here_val < 16) {
                                        hold >>>= here_bits;
                                        bits -= here_bits;
                                        state.lens[state.have++] = here_val;
                                    }
                                    else {
                                        if (here_val === 16) {
                                            n = here_bits + 2;
                                            while (bits < n) {
                                                if (have === 0) {
                                                    break inf_leave;
                                                }
                                                have--;
                                                hold += input[next++] << bits;
                                                bits += 8;
                                            }
                                            hold >>>= here_bits;
                                            bits -= here_bits;
                                            if (state.have === 0) {
                                                strm.msg = 'invalid bit length repeat';
                                                state.mode = BAD;
                                                break;
                                            }
                                            len = state.lens[state.have - 1];
                                            copy = 3 + (hold & 0x03);
                                            hold >>>= 2;
                                            bits -= 2;
                                        }
                                        else if (here_val === 17) {
                                            n = here_bits + 3;
                                            while (bits < n) {
                                                if (have === 0) {
                                                    break inf_leave;
                                                }
                                                have--;
                                                hold += input[next++] << bits;
                                                bits += 8;
                                            }
                                            hold >>>= here_bits;
                                            bits -= here_bits;
                                            len = 0;
                                            copy = 3 + (hold & 0x07);
                                            hold >>>= 3;
                                            bits -= 3;
                                        }
                                        else {
                                            n = here_bits + 7;
                                            while (bits < n) {
                                                if (have === 0) {
                                                    break inf_leave;
                                                }
                                                have--;
                                                hold += input[next++] << bits;
                                                bits += 8;
                                            }
                                            hold >>>= here_bits;
                                            bits -= here_bits;
                                            len = 0;
                                            copy = 11 + (hold & 0x7f);
                                            hold >>>= 7;
                                            bits -= 7;
                                        }
                                        if (state.have + copy > state.nlen + state.ndist) {
                                            strm.msg = 'invalid bit length repeat';
                                            state.mode = BAD;
                                            break;
                                        }
                                        while (copy--) {
                                            state.lens[state.have++] = len;
                                        }
                                    }
                                }
                                if (state.mode === BAD) {
                                    break;
                                }
                                if (state.lens[256] === 0) {
                                    strm.msg = 'invalid code -- missing end-of-block';
                                    state.mode = BAD;
                                    break;
                                }
                                state.lenbits = 9;
                                opts = { bits: state.lenbits };
                                ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
                                state.lenbits = opts.bits;
                                if (ret) {
                                    strm.msg = 'invalid literal/lengths set';
                                    state.mode = BAD;
                                    break;
                                }
                                state.distbits = 6;
                                state.distcode = state.distdyn;
                                opts = { bits: state.distbits };
                                ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
                                state.distbits = opts.bits;
                                if (ret) {
                                    strm.msg = 'invalid distances set';
                                    state.mode = BAD;
                                    break;
                                }
                                state.mode = LEN_;
                                if (flush === Z_TREES) {
                                    break inf_leave;
                                }
                            case LEN_:
                                state.mode = LEN;
                            case LEN:
                                if (have >= 6 && left >= 258) {
                                    strm.next_out = put;
                                    strm.avail_out = left;
                                    strm.next_in = next;
                                    strm.avail_in = have;
                                    state.hold = hold;
                                    state.bits = bits;
                                    inflate_fast(strm, _out);
                                    put = strm.next_out;
                                    output = strm.output;
                                    left = strm.avail_out;
                                    next = strm.next_in;
                                    input = strm.input;
                                    have = strm.avail_in;
                                    hold = state.hold;
                                    bits = state.bits;
                                    if (state.mode === TYPE) {
                                        state.back = -1;
                                    }
                                    break;
                                }
                                state.back = 0;
                                for (;;) {
                                    here = state.lencode[hold & ((1 << state.lenbits) - 1)];
                                    here_bits = here >>> 24;
                                    here_op = (here >>> 16) & 0xff;
                                    here_val = here & 0xffff;
                                    if (here_bits <= bits) {
                                        break;
                                    }
                                    if (have === 0) {
                                        break inf_leave;
                                    }
                                    have--;
                                    hold += input[next++] << bits;
                                    bits += 8;
                                }
                                if (here_op && (here_op & 0xf0) === 0) {
                                    last_bits = here_bits;
                                    last_op = here_op;
                                    last_val = here_val;
                                    for (;;) {
                                        here = state.lencode[last_val +
                                            ((hold & ((1 << (last_bits + last_op)) - 1)) >> last_bits)];
                                        here_bits = here >>> 24;
                                        here_op = (here >>> 16) & 0xff;
                                        here_val = here & 0xffff;
                                        if ((last_bits + here_bits) <= bits) {
                                            break;
                                        }
                                        if (have === 0) {
                                            break inf_leave;
                                        }
                                        have--;
                                        hold += input[next++] << bits;
                                        bits += 8;
                                    }
                                    hold >>>= last_bits;
                                    bits -= last_bits;
                                    state.back += last_bits;
                                }
                                hold >>>= here_bits;
                                bits -= here_bits;
                                state.back += here_bits;
                                state.length = here_val;
                                if (here_op === 0) {
                                    state.mode = LIT;
                                    break;
                                }
                                if (here_op & 32) {
                                    state.back = -1;
                                    state.mode = TYPE;
                                    break;
                                }
                                if (here_op & 64) {
                                    strm.msg = 'invalid literal/length code';
                                    state.mode = BAD;
                                    break;
                                }
                                state.extra = here_op & 15;
                                state.mode = LENEXT;
                            case LENEXT:
                                if (state.extra) {
                                    n = state.extra;
                                    while (bits < n) {
                                        if (have === 0) {
                                            break inf_leave;
                                        }
                                        have--;
                                        hold += input[next++] << bits;
                                        bits += 8;
                                    }
                                    state.length += hold & ((1 << state.extra) - 1);
                                    hold >>>= state.extra;
                                    bits -= state.extra;
                                    state.back += state.extra;
                                }
                                state.was = state.length;
                                state.mode = DIST;
                            case DIST:
                                for (;;) {
                                    here = state.distcode[hold & ((1 << state.distbits) - 1)];
                                    here_bits = here >>> 24;
                                    here_op = (here >>> 16) & 0xff;
                                    here_val = here & 0xffff;
                                    if ((here_bits) <= bits) {
                                        break;
                                    }
                                    if (have === 0) {
                                        break inf_leave;
                                    }
                                    have--;
                                    hold += input[next++] << bits;
                                    bits += 8;
                                }
                                if ((here_op & 0xf0) === 0) {
                                    last_bits = here_bits;
                                    last_op = here_op;
                                    last_val = here_val;
                                    for (;;) {
                                        here = state.distcode[last_val +
                                            ((hold & ((1 << (last_bits + last_op)) - 1)) >> last_bits)];
                                        here_bits = here >>> 24;
                                        here_op = (here >>> 16) & 0xff;
                                        here_val = here & 0xffff;
                                        if ((last_bits + here_bits) <= bits) {
                                            break;
                                        }
                                        if (have === 0) {
                                            break inf_leave;
                                        }
                                        have--;
                                        hold += input[next++] << bits;
                                        bits += 8;
                                    }
                                    hold >>>= last_bits;
                                    bits -= last_bits;
                                    state.back += last_bits;
                                }
                                hold >>>= here_bits;
                                bits -= here_bits;
                                state.back += here_bits;
                                if (here_op & 64) {
                                    strm.msg = 'invalid distance code';
                                    state.mode = BAD;
                                    break;
                                }
                                state.offset = here_val;
                                state.extra = (here_op) & 15;
                                state.mode = DISTEXT;
                            case DISTEXT:
                                if (state.extra) {
                                    n = state.extra;
                                    while (bits < n) {
                                        if (have === 0) {
                                            break inf_leave;
                                        }
                                        have--;
                                        hold += input[next++] << bits;
                                        bits += 8;
                                    }
                                    state.offset += hold & ((1 << state.extra) - 1);
                                    hold >>>= state.extra;
                                    bits -= state.extra;
                                    state.back += state.extra;
                                }
                                if (state.offset > state.dmax) {
                                    strm.msg = 'invalid distance too far back';
                                    state.mode = BAD;
                                    break;
                                }
                                state.mode = MATCH;
                            case MATCH:
                                if (left === 0) {
                                    break inf_leave;
                                }
                                copy = _out - left;
                                if (state.offset > copy) {
                                    copy = state.offset - copy;
                                    if (copy > state.whave) {
                                        if (state.sane) {
                                            strm.msg = 'invalid distance too far back';
                                            state.mode = BAD;
                                            break;
                                        }
                                    }
                                    if (copy > state.wnext) {
                                        copy -= state.wnext;
                                        from = state.wsize - copy;
                                    }
                                    else {
                                        from = state.wnext - copy;
                                    }
                                    if (copy > state.length) {
                                        copy = state.length;
                                    }
                                    from_source = state.window;
                                }
                                else {
                                    from_source = output;
                                    from = put - state.offset;
                                    copy = state.length;
                                }
                                if (copy > left) {
                                    copy = left;
                                }
                                left -= copy;
                                state.length -= copy;
                                do {
                                    output[put++] = from_source[from++];
                                } while (--copy);
                                if (state.length === 0) {
                                    state.mode = LEN;
                                }
                                break;
                            case LIT:
                                if (left === 0) {
                                    break inf_leave;
                                }
                                output[put++] = state.length;
                                left--;
                                state.mode = LEN;
                                break;
                            case CHECK:
                                if (state.wrap) {
                                    while (bits < 32) {
                                        if (have === 0) {
                                            break inf_leave;
                                        }
                                        have--;
                                        hold |= input[next++] << bits;
                                        bits += 8;
                                    }
                                    _out -= left;
                                    strm.total_out += _out;
                                    state.total += _out;
                                    if (_out) {
                                        strm.adler = state.check =
                                            (state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out));
                                    }
                                    _out = left;
                                    if ((state.flags ? hold : zswap32(hold)) !== state.check) {
                                        strm.msg = 'incorrect data check';
                                        state.mode = BAD;
                                        break;
                                    }
                                    hold = 0;
                                    bits = 0;
                                }
                                state.mode = LENGTH;
                            case LENGTH:
                                if (state.wrap && state.flags) {
                                    while (bits < 32) {
                                        if (have === 0) {
                                            break inf_leave;
                                        }
                                        have--;
                                        hold += input[next++] << bits;
                                        bits += 8;
                                    }
                                    if (hold !== (state.total & 0xffffffff)) {
                                        strm.msg = 'incorrect length check';
                                        state.mode = BAD;
                                        break;
                                    }
                                    hold = 0;
                                    bits = 0;
                                }
                                state.mode = DONE;
                            case DONE:
                                ret = Z_STREAM_END;
                                break inf_leave;
                            case BAD:
                                ret = Z_DATA_ERROR;
                                break inf_leave;
                            case MEM:
                                return Z_MEM_ERROR;
                            case SYNC:
                            default:
                                return Z_STREAM_ERROR;
                        }
                    }
                    strm.next_out = put;
                    strm.avail_out = left;
                    strm.next_in = next;
                    strm.avail_in = have;
                    state.hold = hold;
                    state.bits = bits;
                    if (state.wsize || (_out !== strm.avail_out && state.mode < BAD &&
                        (state.mode < CHECK || flush !== Z_FINISH))) {
                        if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
                            state.mode = MEM;
                            return Z_MEM_ERROR;
                        }
                    }
                    _in -= strm.avail_in;
                    _out -= strm.avail_out;
                    strm.total_in += _in;
                    strm.total_out += _out;
                    state.total += _out;
                    if (state.wrap && _out) {
                        strm.adler = state.check =
                            (state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out));
                    }
                    strm.data_type = state.bits + (state.last ? 64 : 0) +
                        (state.mode === TYPE ? 128 : 0) +
                        (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
                    if (((_in === 0 && _out === 0) || flush === Z_FINISH) && ret === Z_OK) {
                        ret = Z_BUF_ERROR;
                    }
                    return ret;
                }
                function inflateEnd(strm) {
                    if (!strm || !strm.state) {
                        return Z_STREAM_ERROR;
                    }
                    var state = strm.state;
                    if (state.window) {
                        state.window = null;
                    }
                    strm.state = null;
                    return Z_OK;
                }
                function inflateGetHeader(strm, head) {
                    var state;
                    if (!strm || !strm.state) {
                        return Z_STREAM_ERROR;
                    }
                    state = strm.state;
                    if ((state.wrap & 2) === 0) {
                        return Z_STREAM_ERROR;
                    }
                    state.head = head;
                    head.done = false;
                    return Z_OK;
                }
                function inflateSetDictionary(strm, dictionary) {
                    var dictLength = dictionary.length;
                    var state;
                    var dictid;
                    var ret;
                    if (!strm || !strm.state) {
                        return Z_STREAM_ERROR;
                    }
                    state = strm.state;
                    if (state.wrap !== 0 && state.mode !== DICT) {
                        return Z_STREAM_ERROR;
                    }
                    if (state.mode === DICT) {
                        dictid = 1;
                        dictid = adler32(dictid, dictionary, dictLength, 0);
                        if (dictid !== state.check) {
                            return Z_DATA_ERROR;
                        }
                    }
                    ret = updatewindow(strm, dictionary, dictLength, dictLength);
                    if (ret) {
                        state.mode = MEM;
                        return Z_MEM_ERROR;
                    }
                    state.havedict = 1;
                    return Z_OK;
                }
                localExports.inflateReset = inflateReset;
                localExports.inflateReset2 = inflateReset2;
                localExports.inflateResetKeep = inflateResetKeep;
                localExports.inflateInit = inflateInit;
                localExports.inflateInit2 = inflateInit2;
                localExports.inflate = inflate;
                localExports.inflateEnd = inflateEnd;
                localExports.inflateGetHeader = inflateGetHeader;
                localExports.inflateSetDictionary = inflateSetDictionary;
                localExports.inflateInfo = 'pako inflate (from Nodeca project)';
            }, { "../utils/common": 175, "./adler32": 176, "./crc32": 178, "./inffast": 180, "./inftrees": 182 }], 182: [function (localRequire, localModule, localExports) {
                'use strict';
                var utils = localRequire('../utils/common');
                var MAXBITS = 15;
                var ENOUGH_LENS = 852;
                var ENOUGH_DISTS = 592;
                var CODES = 0;
                var LENS = 1;
                var DISTS = 2;
                var lbase = [
                    3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
                    35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0
                ];
                var lext = [
                    16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,
                    19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78
                ];
                var dbase = [
                    1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
                    257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
                    8193, 12289, 16385, 24577, 0, 0
                ];
                var dext = [
                    16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,
                    23, 23, 24, 24, 25, 25, 26, 26, 27, 27,
                    28, 28, 29, 29, 64, 64
                ];
                localModule.localExports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts) {
                    var bits = opts.bits;
                    var len = 0;
                    var sym = 0;
                    var min = 0, max = 0;
                    var root = 0;
                    var curr = 0;
                    var drop = 0;
                    var left = 0;
                    var used = 0;
                    var huff = 0;
                    var incr;
                    var fill;
                    var low;
                    var mask;
                    var next;
                    var base = null;
                    var base_index = 0;
                    var end;
                    var count = new utils.Buf16(MAXBITS + 1);
                    var offs = new utils.Buf16(MAXBITS + 1);
                    var extra = null;
                    var extra_index = 0;
                    var here_bits, here_op, here_val;
                    for (len = 0; len <= MAXBITS; len++) {
                        count[len] = 0;
                    }
                    for (sym = 0; sym < codes; sym++) {
                        count[lens[lens_index + sym]]++;
                    }
                    root = bits;
                    for (max = MAXBITS; max >= 1; max--) {
                        if (count[max] !== 0) {
                            break;
                        }
                    }
                    if (root > max) {
                        root = max;
                    }
                    if (max === 0) {
                        table[table_index++] = (1 << 24) | (64 << 16) | 0;
                        table[table_index++] = (1 << 24) | (64 << 16) | 0;
                        opts.bits = 1;
                        return 0;
                    }
                    for (min = 1; min < max; min++) {
                        if (count[min] !== 0) {
                            break;
                        }
                    }
                    if (root < min) {
                        root = min;
                    }
                    left = 1;
                    for (len = 1; len <= MAXBITS; len++) {
                        left <<= 1;
                        left -= count[len];
                        if (left < 0) {
                            return -1;
                        }
                    }
                    if (left > 0 && (type === CODES || max !== 1)) {
                        return -1;
                    }
                    offs[1] = 0;
                    for (len = 1; len < MAXBITS; len++) {
                        offs[len + 1] = offs[len] + count[len];
                    }
                    for (sym = 0; sym < codes; sym++) {
                        if (lens[lens_index + sym] !== 0) {
                            work[offs[lens[lens_index + sym]]++] = sym;
                        }
                    }
                    if (type === CODES) {
                        base = extra = work;
                        end = 19;
                    }
                    else if (type === LENS) {
                        base = lbase;
                        base_index -= 257;
                        extra = lext;
                        extra_index -= 257;
                        end = 256;
                    }
                    else {
                        base = dbase;
                        extra = dext;
                        end = -1;
                    }
                    huff = 0;
                    sym = 0;
                    len = min;
                    next = table_index;
                    curr = root;
                    drop = 0;
                    low = -1;
                    used = 1 << root;
                    mask = used - 1;
                    if ((type === LENS && used > ENOUGH_LENS) ||
                        (type === DISTS && used > ENOUGH_DISTS)) {
                        return 1;
                    }
                    var i = 0;
                    for (;;) {
                        i++;
                        here_bits = len - drop;
                        if (work[sym] < end) {
                            here_op = 0;
                            here_val = work[sym];
                        }
                        else if (work[sym] > end) {
                            here_op = extra[extra_index + work[sym]];
                            here_val = base[base_index + work[sym]];
                        }
                        else {
                            here_op = 32 + 64;
                            here_val = 0;
                        }
                        incr = 1 << (len - drop);
                        fill = 1 << curr;
                        min = fill;
                        do {
                            fill -= incr;
                            table[next + (huff >> drop) + fill] = (here_bits << 24) | (here_op << 16) | here_val | 0;
                        } while (fill !== 0);
                        incr = 1 << (len - 1);
                        while (huff & incr) {
                            incr >>= 1;
                        }
                        if (incr !== 0) {
                            huff &= incr - 1;
                            huff += incr;
                        }
                        else {
                            huff = 0;
                        }
                        sym++;
                        if (--count[len] === 0) {
                            if (len === max) {
                                break;
                            }
                            len = lens[lens_index + work[sym]];
                        }
                        if (len > root && (huff & mask) !== low) {
                            if (drop === 0) {
                                drop = root;
                            }
                            next += min;
                            curr = len - drop;
                            left = 1 << curr;
                            while (curr + drop < max) {
                                left -= count[curr + drop];
                                if (left <= 0) {
                                    break;
                                }
                                curr++;
                                left <<= 1;
                            }
                            used += 1 << curr;
                            if ((type === LENS && used > ENOUGH_LENS) ||
                                (type === DISTS && used > ENOUGH_DISTS)) {
                                return 1;
                            }
                            low = huff & mask;
                            table[low] = (root << 24) | (curr << 16) | (next - table_index) | 0;
                        }
                    }
                    if (huff !== 0) {
                        table[next + huff] = ((len - drop) << 24) | (64 << 16) | 0;
                    }
                    opts.bits = root;
                    return 0;
                };
            }, { "../utils/common": 175 }], 183: [function (localRequire, localModule, localExports) {
                'use strict';
                localModule.localExports = {
                    2: 'need dictionary',
                    1: 'stream end',
                    0: '',
                    '-1': 'file error',
                    '-2': 'stream error',
                    '-3': 'data error',
                    '-4': 'insufficient memory',
                    '-5': 'buffer error',
                    '-6': 'incompatible version'
                };
            }, {}], 184: [function (localRequire, localModule, localExports) {
                'use strict';
                var utils = localRequire('../utils/common');
                var Z_FIXED = 4;
                var Z_BINARY = 0;
                var Z_TEXT = 1;
                var Z_UNKNOWN = 2;
                function zero(buf) { var len = buf.length; while (--len >= 0) {
                    buf[len] = 0;
                } }
                var STORED_BLOCK = 0;
                var STATIC_TREES = 1;
                var DYN_TREES = 2;
                var MIN_MATCH = 3;
                var MAX_MATCH = 258;
                var LENGTH_CODES = 29;
                var LITERALS = 256;
                var L_CODES = LITERALS + 1 + LENGTH_CODES;
                var D_CODES = 30;
                var BL_CODES = 19;
                var HEAP_SIZE = 2 * L_CODES + 1;
                var MAX_BITS = 15;
                var Buf_size = 16;
                var MAX_BL_BITS = 7;
                var END_BLOCK = 256;
                var REP_3_6 = 16;
                var REPZ_3_10 = 17;
                var REPZ_11_138 = 18;
                var extra_lbits = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0];
                var extra_dbits = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];
                var extra_blbits = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7];
                var bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
                var DIST_CODE_LEN = 512;
                var static_ltree = new Array((L_CODES + 2) * 2);
                zero(static_ltree);
                var static_dtree = new Array(D_CODES * 2);
                zero(static_dtree);
                var _dist_code = new Array(DIST_CODE_LEN);
                zero(_dist_code);
                var _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);
                zero(_length_code);
                var base_length = new Array(LENGTH_CODES);
                zero(base_length);
                var base_dist = new Array(D_CODES);
                zero(base_dist);
                function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
                    this.static_tree = static_tree;
                    this.extra_bits = extra_bits;
                    this.extra_base = extra_base;
                    this.elems = elems;
                    this.max_length = max_length;
                    this.has_stree = static_tree && static_tree.length;
                }
                var static_l_desc;
                var static_d_desc;
                var static_bl_desc;
                function TreeDesc(dyn_tree, stat_desc) {
                    this.dyn_tree = dyn_tree;
                    this.max_code = 0;
                    this.stat_desc = stat_desc;
                }
                function d_code(dist) {
                    return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
                }
                function put_short(s, w) {
                    s.pending_buf[s.pending++] = (w) & 0xff;
                    s.pending_buf[s.pending++] = (w >>> 8) & 0xff;
                }
                function send_bits(s, value, length) {
                    if (s.bi_valid > (Buf_size - length)) {
                        s.bi_buf |= (value << s.bi_valid) & 0xffff;
                        put_short(s, s.bi_buf);
                        s.bi_buf = value >> (Buf_size - s.bi_valid);
                        s.bi_valid += length - Buf_size;
                    }
                    else {
                        s.bi_buf |= (value << s.bi_valid) & 0xffff;
                        s.bi_valid += length;
                    }
                }
                function send_code(s, c, tree) {
                    send_bits(s, tree[c * 2], tree[c * 2 + 1]);
                }
                function bi_reverse(code, len) {
                    var res = 0;
                    do {
                        res |= code & 1;
                        code >>>= 1;
                        res <<= 1;
                    } while (--len > 0);
                    return res >>> 1;
                }
                function bi_flush(s) {
                    if (s.bi_valid === 16) {
                        put_short(s, s.bi_buf);
                        s.bi_buf = 0;
                        s.bi_valid = 0;
                    }
                    else if (s.bi_valid >= 8) {
                        s.pending_buf[s.pending++] = s.bi_buf & 0xff;
                        s.bi_buf >>= 8;
                        s.bi_valid -= 8;
                    }
                }
                function gen_bitlen(s, desc) {
                    var tree = desc.dyn_tree;
                    var max_code = desc.max_code;
                    var stree = desc.stat_desc.static_tree;
                    var has_stree = desc.stat_desc.has_stree;
                    var extra = desc.stat_desc.extra_bits;
                    var base = desc.stat_desc.extra_base;
                    var max_length = desc.stat_desc.max_length;
                    var h;
                    var n, m;
                    var bits;
                    var xbits;
                    var f;
                    var overflow = 0;
                    for (bits = 0; bits <= MAX_BITS; bits++) {
                        s.bl_count[bits] = 0;
                    }
                    tree[s.heap[s.heap_max] * 2 + 1] = 0;
                    for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
                        n = s.heap[h];
                        bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
                        if (bits > max_length) {
                            bits = max_length;
                            overflow++;
                        }
                        tree[n * 2 + 1] = bits;
                        if (n > max_code) {
                            continue;
                        }
                        s.bl_count[bits]++;
                        xbits = 0;
                        if (n >= base) {
                            xbits = extra[n - base];
                        }
                        f = tree[n * 2];
                        s.opt_len += f * (bits + xbits);
                        if (has_stree) {
                            s.static_len += f * (stree[n * 2 + 1] + xbits);
                        }
                    }
                    if (overflow === 0) {
                        return;
                    }
                    do {
                        bits = max_length - 1;
                        while (s.bl_count[bits] === 0) {
                            bits--;
                        }
                        s.bl_count[bits]--;
                        s.bl_count[bits + 1] += 2;
                        s.bl_count[max_length]--;
                        overflow -= 2;
                    } while (overflow > 0);
                    for (bits = max_length; bits !== 0; bits--) {
                        n = s.bl_count[bits];
                        while (n !== 0) {
                            m = s.heap[--h];
                            if (m > max_code) {
                                continue;
                            }
                            if (tree[m * 2 + 1] !== bits) {
                                s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
                                tree[m * 2 + 1] = bits;
                            }
                            n--;
                        }
                    }
                }
                function gen_codes(tree, max_code, bl_count) {
                    var next_code = new Array(MAX_BITS + 1);
                    var code = 0;
                    var bits;
                    var n;
                    for (bits = 1; bits <= MAX_BITS; bits++) {
                        next_code[bits] = code = (code + bl_count[bits - 1]) << 1;
                    }
                    for (n = 0; n <= max_code; n++) {
                        var len = tree[n * 2 + 1];
                        if (len === 0) {
                            continue;
                        }
                        tree[n * 2] = bi_reverse(next_code[len]++, len);
                    }
                }
                function tr_static_init() {
                    var n;
                    var bits;
                    var length;
                    var code;
                    var dist;
                    var bl_count = new Array(MAX_BITS + 1);
                    length = 0;
                    for (code = 0; code < LENGTH_CODES - 1; code++) {
                        base_length[code] = length;
                        for (n = 0; n < (1 << extra_lbits[code]); n++) {
                            _length_code[length++] = code;
                        }
                    }
                    _length_code[length - 1] = code;
                    dist = 0;
                    for (code = 0; code < 16; code++) {
                        base_dist[code] = dist;
                        for (n = 0; n < (1 << extra_dbits[code]); n++) {
                            _dist_code[dist++] = code;
                        }
                    }
                    dist >>= 7;
                    for (; code < D_CODES; code++) {
                        base_dist[code] = dist << 7;
                        for (n = 0; n < (1 << (extra_dbits[code] - 7)); n++) {
                            _dist_code[256 + dist++] = code;
                        }
                    }
                    for (bits = 0; bits <= MAX_BITS; bits++) {
                        bl_count[bits] = 0;
                    }
                    n = 0;
                    while (n <= 143) {
                        static_ltree[n * 2 + 1] = 8;
                        n++;
                        bl_count[8]++;
                    }
                    while (n <= 255) {
                        static_ltree[n * 2 + 1] = 9;
                        n++;
                        bl_count[9]++;
                    }
                    while (n <= 279) {
                        static_ltree[n * 2 + 1] = 7;
                        n++;
                        bl_count[7]++;
                    }
                    while (n <= 287) {
                        static_ltree[n * 2 + 1] = 8;
                        n++;
                        bl_count[8]++;
                    }
                    gen_codes(static_ltree, L_CODES + 1, bl_count);
                    for (n = 0; n < D_CODES; n++) {
                        static_dtree[n * 2 + 1] = 5;
                        static_dtree[n * 2] = bi_reverse(n, 5);
                    }
                    static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
                    static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS);
                    static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS);
                }
                function init_block(s) {
                    var n;
                    for (n = 0; n < L_CODES; n++) {
                        s.dyn_ltree[n * 2] = 0;
                    }
                    for (n = 0; n < D_CODES; n++) {
                        s.dyn_dtree[n * 2] = 0;
                    }
                    for (n = 0; n < BL_CODES; n++) {
                        s.bl_tree[n * 2] = 0;
                    }
                    s.dyn_ltree[END_BLOCK * 2] = 1;
                    s.opt_len = s.static_len = 0;
                    s.last_lit = s.matches = 0;
                }
                function bi_windup(s) {
                    if (s.bi_valid > 8) {
                        put_short(s, s.bi_buf);
                    }
                    else if (s.bi_valid > 0) {
                        s.pending_buf[s.pending++] = s.bi_buf;
                    }
                    s.bi_buf = 0;
                    s.bi_valid = 0;
                }
                function copy_block(s, buf, len, header) {
                    bi_windup(s);
                    if (header) {
                        put_short(s, len);
                        put_short(s, ~len);
                    }
                    utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);
                    s.pending += len;
                }
                function smaller(tree, n, m, depth) {
                    var _n2 = n * 2;
                    var _m2 = m * 2;
                    return (tree[_n2] < tree[_m2] ||
                        (tree[_n2] === tree[_m2] && depth[n] <= depth[m]));
                }
                function pqdownheap(s, tree, k) {
                    var v = s.heap[k];
                    var j = k << 1;
                    while (j <= s.heap_len) {
                        if (j < s.heap_len &&
                            smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
                            j++;
                        }
                        if (smaller(tree, v, s.heap[j], s.depth)) {
                            break;
                        }
                        s.heap[k] = s.heap[j];
                        k = j;
                        j <<= 1;
                    }
                    s.heap[k] = v;
                }
                function compress_block(s, ltree, dtree) {
                    var dist;
                    var lc;
                    var lx = 0;
                    var code;
                    var extra;
                    if (s.last_lit !== 0) {
                        do {
                            dist = (s.pending_buf[s.d_buf + lx * 2] << 8) | (s.pending_buf[s.d_buf + lx * 2 + 1]);
                            lc = s.pending_buf[s.l_buf + lx];
                            lx++;
                            if (dist === 0) {
                                send_code(s, lc, ltree);
                            }
                            else {
                                code = _length_code[lc];
                                send_code(s, code + LITERALS + 1, ltree);
                                extra = extra_lbits[code];
                                if (extra !== 0) {
                                    lc -= base_length[code];
                                    send_bits(s, lc, extra);
                                }
                                dist--;
                                code = d_code(dist);
                                send_code(s, code, dtree);
                                extra = extra_dbits[code];
                                if (extra !== 0) {
                                    dist -= base_dist[code];
                                    send_bits(s, dist, extra);
                                }
                            }
                        } while (lx < s.last_lit);
                    }
                    send_code(s, END_BLOCK, ltree);
                }
                function build_tree(s, desc) {
                    var tree = desc.dyn_tree;
                    var stree = desc.stat_desc.static_tree;
                    var has_stree = desc.stat_desc.has_stree;
                    var elems = desc.stat_desc.elems;
                    var n, m;
                    var max_code = -1;
                    var node;
                    s.heap_len = 0;
                    s.heap_max = HEAP_SIZE;
                    for (n = 0; n < elems; n++) {
                        if (tree[n * 2] !== 0) {
                            s.heap[++s.heap_len] = max_code = n;
                            s.depth[n] = 0;
                        }
                        else {
                            tree[n * 2 + 1] = 0;
                        }
                    }
                    while (s.heap_len < 2) {
                        node = s.heap[++s.heap_len] = (max_code < 2 ? ++max_code : 0);
                        tree[node * 2] = 1;
                        s.depth[node] = 0;
                        s.opt_len--;
                        if (has_stree) {
                            s.static_len -= stree[node * 2 + 1];
                        }
                    }
                    desc.max_code = max_code;
                    for (n = (s.heap_len >> 1); n >= 1; n--) {
                        pqdownheap(s, tree, n);
                    }
                    node = elems;
                    do {
                        n = s.heap[1];
                        s.heap[1] = s.heap[s.heap_len--];
                        pqdownheap(s, tree, 1);
                        m = s.heap[1];
                        s.heap[--s.heap_max] = n;
                        s.heap[--s.heap_max] = m;
                        tree[node * 2] = tree[n * 2] + tree[m * 2];
                        s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
                        tree[n * 2 + 1] = tree[m * 2 + 1] = node;
                        s.heap[1] = node++;
                        pqdownheap(s, tree, 1);
                    } while (s.heap_len >= 2);
                    s.heap[--s.heap_max] = s.heap[1];
                    gen_bitlen(s, desc);
                    gen_codes(tree, max_code, s.bl_count);
                }
                function scan_tree(s, tree, max_code) {
                    var n;
                    var prevlen = -1;
                    var curlen;
                    var nextlen = tree[0 * 2 + 1];
                    var count = 0;
                    var max_count = 7;
                    var min_count = 4;
                    if (nextlen === 0) {
                        max_count = 138;
                        min_count = 3;
                    }
                    tree[(max_code + 1) * 2 + 1] = 0xffff;
                    for (n = 0; n <= max_code; n++) {
                        curlen = nextlen;
                        nextlen = tree[(n + 1) * 2 + 1];
                        if (++count < max_count && curlen === nextlen) {
                            continue;
                        }
                        else if (count < min_count) {
                            s.bl_tree[curlen * 2] += count;
                        }
                        else if (curlen !== 0) {
                            if (curlen !== prevlen) {
                                s.bl_tree[curlen * 2]++;
                            }
                            s.bl_tree[REP_3_6 * 2]++;
                        }
                        else if (count <= 10) {
                            s.bl_tree[REPZ_3_10 * 2]++;
                        }
                        else {
                            s.bl_tree[REPZ_11_138 * 2]++;
                        }
                        count = 0;
                        prevlen = curlen;
                        if (nextlen === 0) {
                            max_count = 138;
                            min_count = 3;
                        }
                        else if (curlen === nextlen) {
                            max_count = 6;
                            min_count = 3;
                        }
                        else {
                            max_count = 7;
                            min_count = 4;
                        }
                    }
                }
                function send_tree(s, tree, max_code) {
                    var n;
                    var prevlen = -1;
                    var curlen;
                    var nextlen = tree[0 * 2 + 1];
                    var count = 0;
                    var max_count = 7;
                    var min_count = 4;
                    if (nextlen === 0) {
                        max_count = 138;
                        min_count = 3;
                    }
                    for (n = 0; n <= max_code; n++) {
                        curlen = nextlen;
                        nextlen = tree[(n + 1) * 2 + 1];
                        if (++count < max_count && curlen === nextlen) {
                            continue;
                        }
                        else if (count < min_count) {
                            do {
                                send_code(s, curlen, s.bl_tree);
                            } while (--count !== 0);
                        }
                        else if (curlen !== 0) {
                            if (curlen !== prevlen) {
                                send_code(s, curlen, s.bl_tree);
                                count--;
                            }
                            send_code(s, REP_3_6, s.bl_tree);
                            send_bits(s, count - 3, 2);
                        }
                        else if (count <= 10) {
                            send_code(s, REPZ_3_10, s.bl_tree);
                            send_bits(s, count - 3, 3);
                        }
                        else {
                            send_code(s, REPZ_11_138, s.bl_tree);
                            send_bits(s, count - 11, 7);
                        }
                        count = 0;
                        prevlen = curlen;
                        if (nextlen === 0) {
                            max_count = 138;
                            min_count = 3;
                        }
                        else if (curlen === nextlen) {
                            max_count = 6;
                            min_count = 3;
                        }
                        else {
                            max_count = 7;
                            min_count = 4;
                        }
                    }
                }
                function build_bl_tree(s) {
                    var max_blindex;
                    scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
                    scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
                    build_tree(s, s.bl_desc);
                    for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
                        if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
                            break;
                        }
                    }
                    s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
                    return max_blindex;
                }
                function send_all_trees(s, lcodes, dcodes, blcodes) {
                    var rank;
                    send_bits(s, lcodes - 257, 5);
                    send_bits(s, dcodes - 1, 5);
                    send_bits(s, blcodes - 4, 4);
                    for (rank = 0; rank < blcodes; rank++) {
                        send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1], 3);
                    }
                    send_tree(s, s.dyn_ltree, lcodes - 1);
                    send_tree(s, s.dyn_dtree, dcodes - 1);
                }
                function detect_data_type(s) {
                    var black_mask = 0xf3ffc07f;
                    var n;
                    for (n = 0; n <= 31; n++, black_mask >>>= 1) {
                        if ((black_mask & 1) && (s.dyn_ltree[n * 2] !== 0)) {
                            return Z_BINARY;
                        }
                    }
                    if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 ||
                        s.dyn_ltree[13 * 2] !== 0) {
                        return Z_TEXT;
                    }
                    for (n = 32; n < LITERALS; n++) {
                        if (s.dyn_ltree[n * 2] !== 0) {
                            return Z_TEXT;
                        }
                    }
                    return Z_BINARY;
                }
                var static_init_done = false;
                function _tr_init(s) {
                    if (!static_init_done) {
                        tr_static_init();
                        static_init_done = true;
                    }
                    s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
                    s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
                    s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
                    s.bi_buf = 0;
                    s.bi_valid = 0;
                    init_block(s);
                }
                function _tr_stored_block(s, buf, stored_len, last) {
                    send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
                    copy_block(s, buf, stored_len, true);
                }
                function _tr_align(s) {
                    send_bits(s, STATIC_TREES << 1, 3);
                    send_code(s, END_BLOCK, static_ltree);
                    bi_flush(s);
                }
                function _tr_flush_block(s, buf, stored_len, last) {
                    var opt_lenb, static_lenb;
                    var max_blindex = 0;
                    if (s.level > 0) {
                        if (s.strm.data_type === Z_UNKNOWN) {
                            s.strm.data_type = detect_data_type(s);
                        }
                        build_tree(s, s.l_desc);
                        build_tree(s, s.d_desc);
                        max_blindex = build_bl_tree(s);
                        opt_lenb = (s.opt_len + 3 + 7) >>> 3;
                        static_lenb = (s.static_len + 3 + 7) >>> 3;
                        if (static_lenb <= opt_lenb) {
                            opt_lenb = static_lenb;
                        }
                    }
                    else {
                        opt_lenb = static_lenb = stored_len + 5;
                    }
                    if ((stored_len + 4 <= opt_lenb) && (buf !== -1)) {
                        _tr_stored_block(s, buf, stored_len, last);
                    }
                    else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {
                        send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
                        compress_block(s, static_ltree, static_dtree);
                    }
                    else {
                        send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
                        send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
                        compress_block(s, s.dyn_ltree, s.dyn_dtree);
                    }
                    init_block(s);
                    if (last) {
                        bi_windup(s);
                    }
                }
                function _tr_tally(s, dist, lc) {
                    s.pending_buf[s.d_buf + s.last_lit * 2] = (dist >>> 8) & 0xff;
                    s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff;
                    s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;
                    s.last_lit++;
                    if (dist === 0) {
                        s.dyn_ltree[lc * 2]++;
                    }
                    else {
                        s.matches++;
                        dist--;
                        s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]++;
                        s.dyn_dtree[d_code(dist) * 2]++;
                    }
                    return (s.last_lit === s.lit_bufsize - 1);
                }
                localExports._tr_init = _tr_init;
                localExports._tr_stored_block = _tr_stored_block;
                localExports._tr_flush_block = _tr_flush_block;
                localExports._tr_tally = _tr_tally;
                localExports._tr_align = _tr_align;
            }, { "../utils/common": 175 }], 185: [function (localRequire, localModule, localExports) {
                'use strict';
                function ZStream() {
                    this.input = null;
                    this.next_in = 0;
                    this.avail_in = 0;
                    this.total_in = 0;
                    this.output = null;
                    this.next_out = 0;
                    this.avail_out = 0;
                    this.total_out = 0;
                    this.msg = '';
                    this.state = null;
                    this.data_type = 2;
                    this.adler = 0;
                }
                localModule.localExports = ZStream;
            }, {}], 186: [function (localRequire, localModule, localExports) {
                (function (Buffer) {
                    (function () {
                        var PNG, fs, zlib;
                        fs = localRequire('fs');
                        zlib = localRequire('zlib');
                        localModule.localExports = PNG = (function () {
                            PNG.decode = function (path, fn) {
                                return fs.readFile(path, function (err, file) {
                                    var png;
                                    png = new PNG(file);
                                    return png.decode(function (pixels) {
                                        return fn(pixels);
                                    });
                                });
                            };
                            PNG.load = function (path) {
                                var file;
                                file = fs.readFileSync(path);
                                return new PNG(file);
                            };
                            function PNG(data) {
                                var chunkSize, colors, i, index, key, section, short, text, _i, _j, _ref;
                                this.data = data;
                                this.pos = 8;
                                this.palette = [];
                                this.imgData = [];
                                this.transparency = {};
                                this.text = {};
                                while (true) {
                                    chunkSize = this.readUInt32();
                                    section = ((function () {
                                        var _i, _results;
                                        _results = [];
                                        for (i = _i = 0; _i < 4; i = ++_i) {
                                            _results.push(String.fromCharCode(this.data[this.pos++]));
                                        }
                                        return _results;
                                    }).call(this)).join('');
                                    switch (section) {
                                        case 'IHDR':
                                            this.width = this.readUInt32();
                                            this.height = this.readUInt32();
                                            this.bits = this.data[this.pos++];
                                            this.colorType = this.data[this.pos++];
                                            this.compressionMethod = this.data[this.pos++];
                                            this.filterMethod = this.data[this.pos++];
                                            this.interlaceMethod = this.data[this.pos++];
                                            break;
                                        case 'PLTE':
                                            this.palette = this.read(chunkSize);
                                            break;
                                        case 'IDAT':
                                            for (i = _i = 0; _i < chunkSize; i = _i += 1) {
                                                this.imgData.push(this.data[this.pos++]);
                                            }
                                            break;
                                        case 'tRNS':
                                            this.transparency = {};
                                            switch (this.colorType) {
                                                case 3:
                                                    this.transparency.indexed = this.read(chunkSize);
                                                    short = 255 - this.transparency.indexed.length;
                                                    if (short > 0) {
                                                        for (i = _j = 0; 0 <= short ? _j < short : _j > short; i = 0 <= short ? ++_j : --_j) {
                                                            this.transparency.indexed.push(255);
                                                        }
                                                    }
                                                    break;
                                                case 0:
                                                    this.transparency.grayscale = this.read(chunkSize)[0];
                                                    break;
                                                case 2:
                                                    this.transparency.rgb = this.read(chunkSize);
                                            }
                                            break;
                                        case 'tEXt':
                                            text = this.read(chunkSize);
                                            index = text.indexOf(0);
                                            key = String.fromCharCode.apply(String, text.slice(0, index));
                                            this.text[key] = String.fromCharCode.apply(String, text.slice(index + 1));
                                            break;
                                        case 'IEND':
                                            this.colors = (function () {
                                                switch (this.colorType) {
                                                    case 0:
                                                    case 3:
                                                    case 4:
                                                        return 1;
                                                    case 2:
                                                    case 6:
                                                        return 3;
                                                }
                                            }).call(this);
                                            this.hasAlphaChannel = (_ref = this.colorType) === 4 || _ref === 6;
                                            colors = this.colors + (this.hasAlphaChannel ? 1 : 0);
                                            this.pixelBitlength = this.bits * colors;
                                            this.colorSpace = (function () {
                                                switch (this.colors) {
                                                    case 1:
                                                        return 'DeviceGray';
                                                    case 3:
                                                        return 'DeviceRGB';
                                                }
                                            }).call(this);
                                            this.imgData = new Buffer(this.imgData);
                                            return;
                                        default:
                                            this.pos += chunkSize;
                                    }
                                    this.pos += 4;
                                    if (this.pos > this.data.length) {
                                        throw new Error("Incomplete or corrupt PNG file");
                                    }
                                }
                            }
                            PNG.prototype.read = function (bytes) {
                                var i, _i, _results;
                                _results = [];
                                for (i = _i = 0; 0 <= bytes ? _i < bytes : _i > bytes; i = 0 <= bytes ? ++_i : --_i) {
                                    _results.push(this.data[this.pos++]);
                                }
                                return _results;
                            };
                            PNG.prototype.readUInt32 = function () {
                                var b1, b2, b3, b4;
                                b1 = this.data[this.pos++] << 24;
                                b2 = this.data[this.pos++] << 16;
                                b3 = this.data[this.pos++] << 8;
                                b4 = this.data[this.pos++];
                                return b1 | b2 | b3 | b4;
                            };
                            PNG.prototype.readUInt16 = function () {
                                var b1, b2;
                                b1 = this.data[this.pos++] << 8;
                                b2 = this.data[this.pos++];
                                return b1 | b2;
                            };
                            PNG.prototype.decodePixels = function (fn) {
                                var _this = this;
                                return zlib.inflate(this.imgData, function (err, data) {
                                    var byte, c, col, i, left, length, p, pa, paeth, pb, pc, pixelBytes, pixels, pos, row, scanlineLength, upper, upperLeft, _i, _j, _k, _l, _m;
                                    if (err) {
                                        throw err;
                                    }
                                    pixelBytes = _this.pixelBitlength / 8;
                                    scanlineLength = pixelBytes * _this.width;
                                    pixels = new Buffer(scanlineLength * _this.height);
                                    length = data.length;
                                    row = 0;
                                    pos = 0;
                                    c = 0;
                                    while (pos < length) {
                                        switch (data[pos++]) {
                                            case 0:
                                                for (i = _i = 0; _i < scanlineLength; i = _i += 1) {
                                                    pixels[c++] = data[pos++];
                                                }
                                                break;
                                            case 1:
                                                for (i = _j = 0; _j < scanlineLength; i = _j += 1) {
                                                    byte = data[pos++];
                                                    left = i < pixelBytes ? 0 : pixels[c - pixelBytes];
                                                    pixels[c++] = (byte + left) % 256;
                                                }
                                                break;
                                            case 2:
                                                for (i = _k = 0; _k < scanlineLength; i = _k += 1) {
                                                    byte = data[pos++];
                                                    col = (i - (i % pixelBytes)) / pixelBytes;
                                                    upper = row && pixels[(row - 1) * scanlineLength + col * pixelBytes + (i % pixelBytes)];
                                                    pixels[c++] = (upper + byte) % 256;
                                                }
                                                break;
                                            case 3:
                                                for (i = _l = 0; _l < scanlineLength; i = _l += 1) {
                                                    byte = data[pos++];
                                                    col = (i - (i % pixelBytes)) / pixelBytes;
                                                    left = i < pixelBytes ? 0 : pixels[c - pixelBytes];
                                                    upper = row && pixels[(row - 1) * scanlineLength + col * pixelBytes + (i % pixelBytes)];
                                                    pixels[c++] = (byte + Math.floor((left + upper) / 2)) % 256;
                                                }
                                                break;
                                            case 4:
                                                for (i = _m = 0; _m < scanlineLength; i = _m += 1) {
                                                    byte = data[pos++];
                                                    col = (i - (i % pixelBytes)) / pixelBytes;
                                                    left = i < pixelBytes ? 0 : pixels[c - pixelBytes];
                                                    if (row === 0) {
                                                        upper = upperLeft = 0;
                                                    }
                                                    else {
                                                        upper = pixels[(row - 1) * scanlineLength + col * pixelBytes + (i % pixelBytes)];
                                                        upperLeft = col && pixels[(row - 1) * scanlineLength + (col - 1) * pixelBytes + (i % pixelBytes)];
                                                    }
                                                    p = left + upper - upperLeft;
                                                    pa = Math.abs(p - left);
                                                    pb = Math.abs(p - upper);
                                                    pc = Math.abs(p - upperLeft);
                                                    if (pa <= pb && pa <= pc) {
                                                        paeth = left;
                                                    }
                                                    else if (pb <= pc) {
                                                        paeth = upper;
                                                    }
                                                    else {
                                                        paeth = upperLeft;
                                                    }
                                                    pixels[c++] = (byte + paeth) % 256;
                                                }
                                                break;
                                            default:
                                                throw new Error("Invalid filter algorithm: " + data[pos - 1]);
                                        }
                                        row++;
                                    }
                                    return fn(pixels);
                                });
                            };
                            PNG.prototype.decodePalette = function () {
                                var c, i, length, palette, pos, ret, transparency, _i, _ref, _ref1;
                                palette = this.palette;
                                transparency = this.transparency.indexed || [];
                                ret = new Buffer(transparency.length + palette.length);
                                pos = 0;
                                length = palette.length;
                                c = 0;
                                for (i = _i = 0, _ref = palette.length; _i < _ref; i = _i += 3) {
                                    ret[pos++] = palette[i];
                                    ret[pos++] = palette[i + 1];
                                    ret[pos++] = palette[i + 2];
                                    ret[pos++] = (_ref1 = transparency[c++]) != null ? _ref1 : 255;
                                }
                                return ret;
                            };
                            PNG.prototype.copyToImageData = function (imageData, pixels) {
                                var alpha, colors, data, i, input, j, k, length, palette, v, _ref;
                                colors = this.colors;
                                palette = null;
                                alpha = this.hasAlphaChannel;
                                if (this.palette.length) {
                                    palette = (_ref = this._decodedPalette) != null ? _ref : this._decodedPalette = this.decodePalette();
                                    colors = 4;
                                    alpha = true;
                                }
                                data = (imageData != null ? imageData.data : void 0) || imageData;
                                length = data.length;
                                input = palette || pixels;
                                i = j = 0;
                                if (colors === 1) {
                                    while (i < length) {
                                        k = palette ? pixels[i / 4] * 4 : j;
                                        v = input[k++];
                                        data[i++] = v;
                                        data[i++] = v;
                                        data[i++] = v;
                                        data[i++] = alpha ? input[k++] : 255;
                                        j = k;
                                    }
                                }
                                else {
                                    while (i < length) {
                                        k = palette ? pixels[i / 4] * 4 : j;
                                        data[i++] = input[k++];
                                        data[i++] = input[k++];
                                        data[i++] = input[k++];
                                        data[i++] = alpha ? input[k++] : 255;
                                        j = k;
                                    }
                                }
                            };
                            PNG.prototype.decode = function (fn) {
                                var ret, _this = this;
                                ret = new Buffer(this.width * this.height * 4);
                                return this.decodePixels(function (pixels) {
                                    _this.copyToImageData(ret, pixels);
                                    return fn(ret);
                                });
                            };
                            return PNG;
                        })();
                    }).call(this);
                }).call(this, localRequire("buffer").Buffer);
            }, { "buffer": 60, "fs": 59, "zlib": 58 }], 187: [function (localRequire, localModule, localExports) {
                (function (process) {
                    'use strict';
                    if (!process.version ||
                        process.version.indexOf('v0.') === 0 ||
                        process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
                        localModule.localExports = nextTick;
                    }
                    else {
                        localModule.localExports = process.nextTick;
                    }
                    function nextTick(fn, arg1, arg2, arg3) {
                        if (typeof fn !== 'function') {
                            throw new TypeError('"callback" argument must be a function');
                        }
                        var len = arguments.length;
                        var args, i;
                        switch (len) {
                            case 0:
                            case 1:
                                return process.nextTick(fn);
                            case 2:
                                return process.nextTick(function afterTickOne() {
                                    fn.call(null, arg1);
                                });
                            case 3:
                                return process.nextTick(function afterTickTwo() {
                                    fn.call(null, arg1, arg2);
                                });
                            case 4:
                                return process.nextTick(function afterTickThree() {
                                    fn.call(null, arg1, arg2, arg3);
                                });
                            default:
                                args = new Array(len - 1);
                                i = 0;
                                while (i < args.length) {
                                    args[i++] = arguments[i];
                                }
                                return process.nextTick(function afterTick() {
                                    fn.apply(null, args);
                                });
                        }
                    }
                }).call(this, localRequire('_process'));
            }, { "_process": 188 }], 188: [function (localRequire, localModule, localExports) {
                var process = localModule.localExports = {};
                var cachedSetTimeout;
                var cachedClearTimeout;
                (function () {
                    try {
                        cachedSetTimeout = setTimeout;
                    }
                    catch (e) {
                        cachedSetTimeout = function () {
                            throw new Error('setTimeout is not defined');
                        };
                    }
                    try {
                        cachedClearTimeout = clearTimeout;
                    }
                    catch (e) {
                        cachedClearTimeout = function () {
                            throw new Error('clearTimeout is not defined');
                        };
                    }
                }());
                function runTimeout(fun) {
                    if (cachedSetTimeout === setTimeout) {
                        return setTimeout(fun, 0);
                    }
                    try {
                        return cachedSetTimeout(fun, 0);
                    }
                    catch (e) {
                        try {
                            return cachedSetTimeout.call(null, fun, 0);
                        }
                        catch (e) {
                            return cachedSetTimeout.call(this, fun, 0);
                        }
                    }
                }
                function runClearTimeout(marker) {
                    if (cachedClearTimeout === clearTimeout) {
                        return clearTimeout(marker);
                    }
                    try {
                        return cachedClearTimeout(marker);
                    }
                    catch (e) {
                        try {
                            return cachedClearTimeout.call(null, marker);
                        }
                        catch (e) {
                            return cachedClearTimeout.call(this, marker);
                        }
                    }
                }
                var queue = [];
                var draining = false;
                var currentQueue;
                var queueIndex = -1;
                function cleanUpNextTick() {
                    if (!draining || !currentQueue) {
                        return;
                    }
                    draining = false;
                    if (currentQueue.length) {
                        queue = currentQueue.concat(queue);
                    }
                    else {
                        queueIndex = -1;
                    }
                    if (queue.length) {
                        drainQueue();
                    }
                }
                function drainQueue() {
                    if (draining) {
                        return;
                    }
                    var timeout = runTimeout(cleanUpNextTick);
                    draining = true;
                    var len = queue.length;
                    while (len) {
                        currentQueue = queue;
                        queue = [];
                        while (++queueIndex < len) {
                            if (currentQueue) {
                                currentQueue[queueIndex].run();
                            }
                        }
                        queueIndex = -1;
                        len = queue.length;
                    }
                    currentQueue = null;
                    draining = false;
                    runClearTimeout(timeout);
                }
                process.nextTick = function (fun) {
                    var args = new Array(arguments.length - 1);
                    if (arguments.length > 1) {
                        for (var i = 1; i < arguments.length; i++) {
                            args[i - 1] = arguments[i];
                        }
                    }
                    queue.push(new Item(fun, args));
                    if (queue.length === 1 && !draining) {
                        runTimeout(drainQueue);
                    }
                };
                function Item(fun, array) {
                    this.fun = fun;
                    this.array = array;
                }
                Item.prototype.run = function () {
                    this.fun.apply(null, this.array);
                };
                process.title = 'browser';
                process.browser = true;
                process.env = {};
                process.argv = [];
                process.version = '';
                process.versions = {};
                function noop() { }
                process.on = noop;
                process.addListener = noop;
                process.once = noop;
                process.off = noop;
                process.removeListener = noop;
                process.removeAllListeners = noop;
                process.emit = noop;
                process.binding = function (name) {
                    throw new Error('process.binding is not supported');
                };
                process.cwd = function () { return '/'; };
                process.chdir = function (dir) {
                    throw new Error('process.chdir is not supported');
                };
                process.umask = function () { return 0; };
            }, {}], 189: [function (localRequire, localModule, localExports) {
                localModule.localExports = localRequire("./lib/_stream_duplex.js");
            }, { "./lib/_stream_duplex.js": 190 }], 190: [function (localRequire, localModule, localExports) {
                'use strict';
                var objectKeys = Object.keys || function (obj) {
                    var keys = [];
                    for (var key in obj) {
                        keys.push(key);
                    }
                    return keys;
                };
                localModule.localExports = Duplex;
                var processNextTick = localRequire('process-nextick-args');
                var util = localRequire('core-util-is');
                util.inherits = localRequire('inherits');
                var Readable = localRequire('./_stream_readable');
                var Writable = localRequire('./_stream_writable');
                util.inherits(Duplex, Readable);
                var keys = objectKeys(Writable.prototype);
                for (var v = 0; v < keys.length; v++) {
                    var method = keys[v];
                    if (!Duplex.prototype[method])
                        Duplex.prototype[method] = Writable.prototype[method];
                }
                function Duplex(options) {
                    if (!(this instanceof Duplex))
                        return new Duplex(options);
                    Readable.call(this, options);
                    Writable.call(this, options);
                    if (options && options.readable === false)
                        this.readable = false;
                    if (options && options.writable === false)
                        this.writable = false;
                    this.allowHalfOpen = true;
                    if (options && options.allowHalfOpen === false)
                        this.allowHalfOpen = false;
                    this.once('end', onend);
                }
                function onend() {
                    if (this.allowHalfOpen || this._writableState.ended)
                        return;
                    processNextTick(onEndNT, this);
                }
                function onEndNT(self) {
                    self.end();
                }
                function forEach(xs, f) {
                    for (var i = 0, l = xs.length; i < l; i++) {
                        f(xs[i], i);
                    }
                }
            }, { "./_stream_readable": 192, "./_stream_writable": 194, "core-util-is": 160, "inherits": 167, "process-nextick-args": 187 }], 191: [function (localRequire, localModule, localExports) {
                'use strict';
                localModule.localExports = PassThrough;
                var Transform = localRequire('./_stream_transform');
                var util = localRequire('core-util-is');
                util.inherits = localRequire('inherits');
                util.inherits(PassThrough, Transform);
                function PassThrough(options) {
                    if (!(this instanceof PassThrough))
                        return new PassThrough(options);
                    Transform.call(this, options);
                }
                PassThrough.prototype._transform = function (chunk, encoding, cb) {
                    cb(null, chunk);
                };
            }, { "./_stream_transform": 193, "core-util-is": 160, "inherits": 167 }], 192: [function (localRequire, localModule, localExports) {
                (function (process) {
                    'use strict';
                    localModule.localExports = Readable;
                    var processNextTick = localRequire('process-nextick-args');
                    var isArray = localRequire('isarray');
                    var Buffer = localRequire('buffer').Buffer;
                    Readable.ReadableState = ReadableState;
                    var EE = localRequire('events');
                    var EElistenerCount = function (emitter, type) {
                        return emitter.listeners(type).length;
                    };
                    var Stream;
                    (function () {
                        try {
                            Stream = localRequire('st' + 'ream');
                        }
                        catch (_) { }
                        finally {
                            if (!Stream)
                                Stream = localRequire('events').EventEmitter;
                        }
                    })();
                    var Buffer = localRequire('buffer').Buffer;
                    var util = localRequire('core-util-is');
                    util.inherits = localRequire('inherits');
                    var debugUtil = localRequire('util');
                    var debug = undefined;
                    if (debugUtil && debugUtil.debuglog) {
                        debug = debugUtil.debuglog('stream');
                    }
                    else {
                        debug = function () { };
                    }
                    var StringDecoder;
                    util.inherits(Readable, Stream);
                    var Duplex;
                    function ReadableState(options, stream) {
                        Duplex = Duplex || localRequire('./_stream_duplex');
                        options = options || {};
                        this.objectMode = !!options.objectMode;
                        if (stream instanceof Duplex)
                            this.objectMode = this.objectMode || !!options.readableObjectMode;
                        var hwm = options.highWaterMark;
                        var defaultHwm = this.objectMode ? 16 : 16 * 1024;
                        this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;
                        this.highWaterMark = ~~this.highWaterMark;
                        this.buffer = [];
                        this.length = 0;
                        this.pipes = null;
                        this.pipesCount = 0;
                        this.flowing = null;
                        this.ended = false;
                        this.endEmitted = false;
                        this.reading = false;
                        this.sync = true;
                        this.needReadable = false;
                        this.emittedReadable = false;
                        this.readableListening = false;
                        this.resumeScheduled = false;
                        this.defaultEncoding = options.defaultEncoding || 'utf8';
                        this.ranOut = false;
                        this.awaitDrain = 0;
                        this.readingMore = false;
                        this.decoder = null;
                        this.encoding = null;
                        if (options.encoding) {
                            if (!StringDecoder)
                                StringDecoder = localRequire('string_decoder/').StringDecoder;
                            this.decoder = new StringDecoder(options.encoding);
                            this.encoding = options.encoding;
                        }
                    }
                    var Duplex;
                    function Readable(options) {
                        Duplex = Duplex || localRequire('./_stream_duplex');
                        if (!(this instanceof Readable))
                            return new Readable(options);
                        this._readableState = new ReadableState(options, this);
                        this.readable = true;
                        if (options && typeof options.read === 'function')
                            this._read = options.read;
                        Stream.call(this);
                    }
                    Readable.prototype.push = function (chunk, encoding) {
                        var state = this._readableState;
                        if (!state.objectMode && typeof chunk === 'string') {
                            encoding = encoding || state.defaultEncoding;
                            if (encoding !== state.encoding) {
                                chunk = new Buffer(chunk, encoding);
                                encoding = '';
                            }
                        }
                        return readableAddChunk(this, state, chunk, encoding, false);
                    };
                    Readable.prototype.unshift = function (chunk) {
                        var state = this._readableState;
                        return readableAddChunk(this, state, chunk, '', true);
                    };
                    Readable.prototype.isPaused = function () {
                        return this._readableState.flowing === false;
                    };
                    function readableAddChunk(stream, state, chunk, encoding, addToFront) {
                        var er = chunkInvalid(state, chunk);
                        if (er) {
                            stream.emit('error', er);
                        }
                        else if (chunk === null) {
                            state.reading = false;
                            onEofChunk(stream, state);
                        }
                        else if (state.objectMode || chunk && chunk.length > 0) {
                            if (state.ended && !addToFront) {
                                var e = new Error('stream.push() after EOF');
                                stream.emit('error', e);
                            }
                            else if (state.endEmitted && addToFront) {
                                var e = new Error('stream.unshift() after end event');
                                stream.emit('error', e);
                            }
                            else {
                                var skipAdd;
                                if (state.decoder && !addToFront && !encoding) {
                                    chunk = state.decoder.write(chunk);
                                    skipAdd = !state.objectMode && chunk.length === 0;
                                }
                                if (!addToFront)
                                    state.reading = false;
                                if (!skipAdd) {
                                    if (state.flowing && state.length === 0 && !state.sync) {
                                        stream.emit('data', chunk);
                                        stream.read(0);
                                    }
                                    else {
                                        state.length += state.objectMode ? 1 : chunk.length;
                                        if (addToFront)
                                            state.buffer.unshift(chunk);
                                        else
                                            state.buffer.push(chunk);
                                        if (state.needReadable)
                                            emitReadable(stream);
                                    }
                                }
                                maybeReadMore(stream, state);
                            }
                        }
                        else if (!addToFront) {
                            state.reading = false;
                        }
                        return needMoreData(state);
                    }
                    function needMoreData(state) {
                        return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
                    }
                    Readable.prototype.setEncoding = function (enc) {
                        if (!StringDecoder)
                            StringDecoder = localRequire('string_decoder/').StringDecoder;
                        this._readableState.decoder = new StringDecoder(enc);
                        this._readableState.encoding = enc;
                        return this;
                    };
                    var MAX_HWM = 0x800000;
                    function computeNewHighWaterMark(n) {
                        if (n >= MAX_HWM) {
                            n = MAX_HWM;
                        }
                        else {
                            n--;
                            n |= n >>> 1;
                            n |= n >>> 2;
                            n |= n >>> 4;
                            n |= n >>> 8;
                            n |= n >>> 16;
                            n++;
                        }
                        return n;
                    }
                    function howMuchToRead(n, state) {
                        if (state.length === 0 && state.ended)
                            return 0;
                        if (state.objectMode)
                            return n === 0 ? 0 : 1;
                        if (n === null || isNaN(n)) {
                            if (state.flowing && state.buffer.length)
                                return state.buffer[0].length;
                            else
                                return state.length;
                        }
                        if (n <= 0)
                            return 0;
                        if (n > state.highWaterMark)
                            state.highWaterMark = computeNewHighWaterMark(n);
                        if (n > state.length) {
                            if (!state.ended) {
                                state.needReadable = true;
                                return 0;
                            }
                            else {
                                return state.length;
                            }
                        }
                        return n;
                    }
                    Readable.prototype.read = function (n) {
                        debug('read', n);
                        var state = this._readableState;
                        var nOrig = n;
                        if (typeof n !== 'number' || n > 0)
                            state.emittedReadable = false;
                        if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
                            debug('read: emitReadable', state.length, state.ended);
                            if (state.length === 0 && state.ended)
                                endReadable(this);
                            else
                                emitReadable(this);
                            return null;
                        }
                        n = howMuchToRead(n, state);
                        if (n === 0 && state.ended) {
                            if (state.length === 0)
                                endReadable(this);
                            return null;
                        }
                        var doRead = state.needReadable;
                        debug('need readable', doRead);
                        if (state.length === 0 || state.length - n < state.highWaterMark) {
                            doRead = true;
                            debug('length less than watermark', doRead);
                        }
                        if (state.ended || state.reading) {
                            doRead = false;
                            debug('reading or ended', doRead);
                        }
                        if (doRead) {
                            debug('do read');
                            state.reading = true;
                            state.sync = true;
                            if (state.length === 0)
                                state.needReadable = true;
                            this._read(state.highWaterMark);
                            state.sync = false;
                        }
                        if (doRead && !state.reading)
                            n = howMuchToRead(nOrig, state);
                        var ret;
                        if (n > 0)
                            ret = fromList(n, state);
                        else
                            ret = null;
                        if (ret === null) {
                            state.needReadable = true;
                            n = 0;
                        }
                        state.length -= n;
                        if (state.length === 0 && !state.ended)
                            state.needReadable = true;
                        if (nOrig !== n && state.ended && state.length === 0)
                            endReadable(this);
                        if (ret !== null)
                            this.emit('data', ret);
                        return ret;
                    };
                    function chunkInvalid(state, chunk) {
                        var er = null;
                        if (!Buffer.isBuffer(chunk) && typeof chunk !== 'string' && chunk !== null && chunk !== undefined && !state.objectMode) {
                            er = new TypeError('Invalid non-string/buffer chunk');
                        }
                        return er;
                    }
                    function onEofChunk(stream, state) {
                        if (state.ended)
                            return;
                        if (state.decoder) {
                            var chunk = state.decoder.end();
                            if (chunk && chunk.length) {
                                state.buffer.push(chunk);
                                state.length += state.objectMode ? 1 : chunk.length;
                            }
                        }
                        state.ended = true;
                        emitReadable(stream);
                    }
                    function emitReadable(stream, farg1) {
                        var state = stream._readableState;
                        state.needReadable = false;
                        if (!state.emittedReadable) {
                            debug('emitReadable', state.flowing);
                            state.emittedReadable = true;
                            if (state.sync)
                                processNextTick(emitReadable_, stream);
                            else
                                emitReadable_(stream);
                        }
                    }
                    function emitReadable_(stream) {
                        debug('emit readable');
                        stream.emit('readable');
                        flow(stream);
                    }
                    function maybeReadMore(stream, state) {
                        if (!state.readingMore) {
                            state.readingMore = true;
                            processNextTick(maybeReadMore_, stream, state);
                        }
                    }
                    function maybeReadMore_(stream, state) {
                        var len = state.length;
                        while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
                            debug('maybeReadMore read 0');
                            stream.read(0);
                            if (len === state.length)
                                break;
                            else
                                len = state.length;
                        }
                        state.readingMore = false;
                    }
                    Readable.prototype._read = function (n) {
                        this.emit('error', new Error('not implemented'));
                    };
                    Readable.prototype.pipe = function (dest, pipeOpts) {
                        var src = this;
                        var state = this._readableState;
                        switch (state.pipesCount) {
                            case 0:
                                state.pipes = dest;
                                break;
                            case 1:
                                state.pipes = [state.pipes, dest];
                                break;
                            default:
                                state.pipes.push(dest);
                                break;
                        }
                        state.pipesCount += 1;
                        debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
                        var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
                        var endFn = doEnd ? onend : cleanup;
                        if (state.endEmitted)
                            processNextTick(endFn);
                        else
                            src.once('end', endFn);
                        dest.on('unpipe', onunpipe);
                        function onunpipe(readable) {
                            debug('onunpipe');
                            if (readable === src) {
                                cleanup();
                            }
                        }
                        function onend() {
                            debug('onend');
                            dest.end();
                        }
                        var ondrain = pipeOnDrain(src);
                        dest.on('drain', ondrain);
                        var cleanedUp = false;
                        function cleanup() {
                            debug('cleanup');
                            dest.removeListener('close', onclose);
                            dest.removeListener('finish', onfinish);
                            dest.removeListener('drain', ondrain);
                            dest.removeListener('error', onerror);
                            dest.removeListener('unpipe', onunpipe);
                            src.removeListener('end', onend);
                            src.removeListener('end', cleanup);
                            src.removeListener('data', ondata);
                            cleanedUp = true;
                            if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
                                ondrain();
                        }
                        src.on('data', ondata);
                        function ondata(chunk) {
                            debug('ondata');
                            var ret = dest.write(chunk);
                            if (false === ret) {
                                if (state.pipesCount === 1 && state.pipes[0] === dest && src.listenerCount('data') === 1 && !cleanedUp) {
                                    debug('false write response, pause', src._readableState.awaitDrain);
                                    src._readableState.awaitDrain++;
                                }
                                src.pause();
                            }
                        }
                        function onerror(er) {
                            debug('onerror', er);
                            unpipe();
                            dest.removeListener('error', onerror);
                            if (EElistenerCount(dest, 'error') === 0)
                                dest.emit('error', er);
                        }
                        if (!dest._events || !dest._events.error)
                            dest.on('error', onerror);
                        else if (isArray(dest._events.error))
                            dest._events.error.unshift(onerror);
                        else
                            dest._events.error = [onerror, dest._events.error];
                        function onclose() {
                            dest.removeListener('finish', onfinish);
                            unpipe();
                        }
                        dest.once('close', onclose);
                        function onfinish() {
                            debug('onfinish');
                            dest.removeListener('close', onclose);
                            unpipe();
                        }
                        dest.once('finish', onfinish);
                        function unpipe() {
                            debug('unpipe');
                            src.unpipe(dest);
                        }
                        dest.emit('pipe', src);
                        if (!state.flowing) {
                            debug('pipe resume');
                            src.resume();
                        }
                        return dest;
                    };
                    function pipeOnDrain(src) {
                        return function () {
                            var state = src._readableState;
                            debug('pipeOnDrain', state.awaitDrain);
                            if (state.awaitDrain)
                                state.awaitDrain--;
                            if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
                                state.flowing = true;
                                flow(src);
                            }
                        };
                    }
                    Readable.prototype.unpipe = function (dest) {
                        var state = this._readableState;
                        if (state.pipesCount === 0)
                            return this;
                        if (state.pipesCount === 1) {
                            if (dest && dest !== state.pipes)
                                return this;
                            if (!dest)
                                dest = state.pipes;
                            state.pipes = null;
                            state.pipesCount = 0;
                            state.flowing = false;
                            if (dest)
                                dest.emit('unpipe', this);
                            return this;
                        }
                        if (!dest) {
                            var dests = state.pipes;
                            var len = state.pipesCount;
                            state.pipes = null;
                            state.pipesCount = 0;
                            state.flowing = false;
                            for (var _i = 0; _i < len; _i++) {
                                dests[_i].emit('unpipe', this);
                            }
                            return this;
                        }
                        var i = indexOf(state.pipes, dest);
                        if (i === -1)
                            return this;
                        state.pipes.splice(i, 1);
                        state.pipesCount -= 1;
                        if (state.pipesCount === 1)
                            state.pipes = state.pipes[0];
                        dest.emit('unpipe', this);
                        return this;
                    };
                    Readable.prototype.on = function (ev, fn) {
                        var res = Stream.prototype.on.call(this, ev, fn);
                        if (ev === 'data' && false !== this._readableState.flowing) {
                            this.resume();
                        }
                        if (ev === 'readable' && !this._readableState.endEmitted) {
                            var state = this._readableState;
                            if (!state.readableListening) {
                                state.readableListening = true;
                                state.emittedReadable = false;
                                state.needReadable = true;
                                if (!state.reading) {
                                    processNextTick(nReadingNextTick, this);
                                }
                                else if (state.length) {
                                    emitReadable(this, state);
                                }
                            }
                        }
                        return res;
                    };
                    Readable.prototype.addListener = Readable.prototype.on;
                    function nReadingNextTick(self) {
                        debug('readable nexttick read 0');
                        self.read(0);
                    }
                    Readable.prototype.resume = function () {
                        var state = this._readableState;
                        if (!state.flowing) {
                            debug('resume');
                            state.flowing = true;
                            resume(this, state);
                        }
                        return this;
                    };
                    function resume(stream, state) {
                        if (!state.resumeScheduled) {
                            state.resumeScheduled = true;
                            processNextTick(resume_, stream, state);
                        }
                    }
                    function resume_(stream, state) {
                        if (!state.reading) {
                            debug('resume read 0');
                            stream.read(0);
                        }
                        state.resumeScheduled = false;
                        stream.emit('resume');
                        flow(stream);
                        if (state.flowing && !state.reading)
                            stream.read(0);
                    }
                    Readable.prototype.pause = function () {
                        debug('call pause flowing=%j', this._readableState.flowing);
                        if (false !== this._readableState.flowing) {
                            debug('pause');
                            this._readableState.flowing = false;
                            this.emit('pause');
                        }
                        return this;
                    };
                    function flow(stream) {
                        var state = stream._readableState;
                        debug('flow', state.flowing);
                        if (state.flowing) {
                            do {
                                var chunk = stream.read();
                            } while (null !== chunk && state.flowing);
                        }
                    }
                    Readable.prototype.wrap = function (stream) {
                        var state = this._readableState;
                        var paused = false;
                        var self = this;
                        stream.on('end', function () {
                            debug('wrapped end');
                            if (state.decoder && !state.ended) {
                                var chunk = state.decoder.end();
                                if (chunk && chunk.length)
                                    self.push(chunk);
                            }
                            self.push(null);
                        });
                        stream.on('data', function (chunk) {
                            debug('wrapped data');
                            if (state.decoder)
                                chunk = state.decoder.write(chunk);
                            if (state.objectMode && (chunk === null || chunk === undefined))
                                return;
                            else if (!state.objectMode && (!chunk || !chunk.length))
                                return;
                            var ret = self.push(chunk);
                            if (!ret) {
                                paused = true;
                                stream.pause();
                            }
                        });
                        for (var i in stream) {
                            if (this[i] === undefined && typeof stream[i] === 'function') {
                                this[i] = function (method) {
                                    return function () {
                                        return stream[method].apply(stream, arguments);
                                    };
                                }(i);
                            }
                        }
                        var events = ['error', 'close', 'destroy', 'pause', 'resume'];
                        forEach(events, function (ev) {
                            stream.on(ev, self.emit.bind(self, ev));
                        });
                        self._read = function (n) {
                            debug('wrapped _read', n);
                            if (paused) {
                                paused = false;
                                stream.resume();
                            }
                        };
                        return self;
                    };
                    Readable._fromList = fromList;
                    function fromList(n, state) {
                        var list = state.buffer;
                        var length = state.length;
                        var stringMode = !!state.decoder;
                        var objectMode = !!state.objectMode;
                        var ret;
                        if (list.length === 0)
                            return null;
                        if (length === 0)
                            ret = null;
                        else if (objectMode)
                            ret = list.shift();
                        else if (!n || n >= length) {
                            if (stringMode)
                                ret = list.join('');
                            else if (list.length === 1)
                                ret = list[0];
                            else
                                ret = Buffer.concat(list, length);
                            list.length = 0;
                        }
                        else {
                            if (n < list[0].length) {
                                var buf = list[0];
                                ret = buf.slice(0, n);
                                list[0] = buf.slice(n);
                            }
                            else if (n === list[0].length) {
                                ret = list.shift();
                            }
                            else {
                                if (stringMode)
                                    ret = '';
                                else
                                    ret = new Buffer(n);
                                var c = 0;
                                for (var i = 0, l = list.length; i < l && c < n; i++) {
                                    var buf = list[0];
                                    var cpy = Math.min(n - c, buf.length);
                                    if (stringMode)
                                        ret += buf.slice(0, cpy);
                                    else
                                        buf.copy(ret, c, 0, cpy);
                                    if (cpy < buf.length)
                                        list[0] = buf.slice(cpy);
                                    else
                                        list.shift();
                                    c += cpy;
                                }
                            }
                        }
                        return ret;
                    }
                    function endReadable(stream) {
                        var state = stream._readableState;
                        if (state.length > 0)
                            throw new Error('endReadable called on non-empty stream');
                        if (!state.endEmitted) {
                            state.ended = true;
                            processNextTick(endReadableNT, state, stream);
                        }
                    }
                    function endReadableNT(state, stream) {
                        if (!state.endEmitted && state.length === 0) {
                            state.endEmitted = true;
                            stream.readable = false;
                            stream.emit('end');
                        }
                    }
                    function forEach(xs, f) {
                        for (var i = 0, l = xs.length; i < l; i++) {
                            f(xs[i], i);
                        }
                    }
                    function indexOf(xs, x) {
                        for (var i = 0, l = xs.length; i < l; i++) {
                            if (xs[i] === x)
                                return i;
                        }
                        return -1;
                    }
                }).call(this, localRequire('_process'));
            }, { "./_stream_duplex": 190, "_process": 188, "buffer": 60, "core-util-is": 160, "events": 164, "inherits": 167, "isarray": 169, "process-nextick-args": 187, "string_decoder/": 217, "util": 56 }], 193: [function (localRequire, localModule, localExports) {
                'use strict';
                localModule.localExports = Transform;
                var Duplex = localRequire('./_stream_duplex');
                var util = localRequire('core-util-is');
                util.inherits = localRequire('inherits');
                util.inherits(Transform, Duplex);
                function TransformState(stream) {
                    this.afterTransform = function (er, data) {
                        return afterTransform(stream, er, data);
                    };
                    this.needTransform = false;
                    this.transforming = false;
                    this.writecb = null;
                    this.writechunk = null;
                    this.writeencoding = null;
                }
                function afterTransform(stream, er, data) {
                    var ts = stream._transformState;
                    ts.transforming = false;
                    var cb = ts.writecb;
                    if (!cb)
                        return stream.emit('error', new Error('no writecb in Transform class'));
                    ts.writechunk = null;
                    ts.writecb = null;
                    if (data !== null && data !== undefined)
                        stream.push(data);
                    cb(er);
                    var rs = stream._readableState;
                    rs.reading = false;
                    if (rs.needReadable || rs.length < rs.highWaterMark) {
                        stream._read(rs.highWaterMark);
                    }
                }
                function Transform(options) {
                    if (!(this instanceof Transform))
                        return new Transform(options);
                    Duplex.call(this, options);
                    this._transformState = new TransformState(this);
                    var stream = this;
                    this._readableState.needReadable = true;
                    this._readableState.sync = false;
                    if (options) {
                        if (typeof options.transform === 'function')
                            this._transform = options.transform;
                        if (typeof options.flush === 'function')
                            this._flush = options.flush;
                    }
                    this.once('prefinish', function () {
                        if (typeof this._flush === 'function')
                            this._flush(function (er) {
                                done(stream, er);
                            });
                        else
                            done(stream);
                    });
                }
                Transform.prototype.push = function (chunk, encoding) {
                    this._transformState.needTransform = false;
                    return Duplex.prototype.push.call(this, chunk, encoding);
                };
                Transform.prototype._transform = function (chunk, encoding, cb) {
                    throw new Error('not implemented');
                };
                Transform.prototype._write = function (chunk, encoding, cb) {
                    var ts = this._transformState;
                    ts.writecb = cb;
                    ts.writechunk = chunk;
                    ts.writeencoding = encoding;
                    if (!ts.transforming) {
                        var rs = this._readableState;
                        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
                            this._read(rs.highWaterMark);
                    }
                };
                Transform.prototype._read = function (n) {
                    var ts = this._transformState;
                    if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
                        ts.transforming = true;
                        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
                    }
                    else {
                        ts.needTransform = true;
                    }
                };
                function done(stream, er) {
                    if (er)
                        return stream.emit('error', er);
                    var ws = stream._writableState;
                    var ts = stream._transformState;
                    if (ws.length)
                        throw new Error('calling transform done when ws.length != 0');
                    if (ts.transforming)
                        throw new Error('calling transform done when still transforming');
                    return stream.push(null);
                }
            }, { "./_stream_duplex": 190, "core-util-is": 160, "inherits": 167 }], 194: [function (localRequire, localModule, localExports) {
                (function (process) {
                    'use strict';
                    localModule.localExports = Writable;
                    var processNextTick = localRequire('process-nextick-args');
                    var asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : processNextTick;
                    var Buffer = localRequire('buffer').Buffer;
                    Writable.WritableState = WritableState;
                    var util = localRequire('core-util-is');
                    util.inherits = localRequire('inherits');
                    var internalUtil = {
                        deprecate: localRequire('util-deprecate')
                    };
                    var Stream;
                    (function () {
                        try {
                            Stream = localRequire('st' + 'ream');
                        }
                        catch (_) { }
                        finally {
                            if (!Stream)
                                Stream = localRequire('events').EventEmitter;
                        }
                    })();
                    var Buffer = localRequire('buffer').Buffer;
                    util.inherits(Writable, Stream);
                    function nop() { }
                    function WriteReq(chunk, encoding, cb) {
                        this.chunk = chunk;
                        this.encoding = encoding;
                        this.callback = cb;
                        this.next = null;
                    }
                    var Duplex;
                    function WritableState(options, stream) {
                        Duplex = Duplex || localRequire('./_stream_duplex');
                        options = options || {};
                        this.objectMode = !!options.objectMode;
                        if (stream instanceof Duplex)
                            this.objectMode = this.objectMode || !!options.writableObjectMode;
                        var hwm = options.highWaterMark;
                        var defaultHwm = this.objectMode ? 16 : 16 * 1024;
                        this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;
                        this.highWaterMark = ~~this.highWaterMark;
                        this.needDrain = false;
                        this.ending = false;
                        this.ended = false;
                        this.finished = false;
                        var noDecode = options.decodeStrings === false;
                        this.decodeStrings = !noDecode;
                        this.defaultEncoding = options.defaultEncoding || 'utf8';
                        this.length = 0;
                        this.writing = false;
                        this.corked = 0;
                        this.sync = true;
                        this.bufferProcessing = false;
                        this.onwrite = function (er) {
                            onwrite(stream, er);
                        };
                        this.writecb = null;
                        this.writelen = 0;
                        this.bufferedRequest = null;
                        this.lastBufferedRequest = null;
                        this.pendingcb = 0;
                        this.prefinished = false;
                        this.errorEmitted = false;
                        this.bufferedRequestCount = 0;
                        this.corkedRequestsFree = new CorkedRequest(this);
                        this.corkedRequestsFree.next = new CorkedRequest(this);
                    }
                    WritableState.prototype.getBuffer = function writableStateGetBuffer() {
                        var current = this.bufferedRequest;
                        var out = [];
                        while (current) {
                            out.push(current);
                            current = current.next;
                        }
                        return out;
                    };
                    (function () {
                        try {
                            Object.defineProperty(WritableState.prototype, 'buffer', {
                                get: internalUtil.deprecate(function () {
                                    return this.getBuffer();
                                }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.')
                            });
                        }
                        catch (_) { }
                    })();
                    var Duplex;
                    function Writable(options) {
                        Duplex = Duplex || localRequire('./_stream_duplex');
                        if (!(this instanceof Writable) && !(this instanceof Duplex))
                            return new Writable(options);
                        this._writableState = new WritableState(options, this);
                        this.writable = true;
                        if (options) {
                            if (typeof options.write === 'function')
                                this._write = options.write;
                            if (typeof options.writev === 'function')
                                this._writev = options.writev;
                        }
                        Stream.call(this);
                    }
                    Writable.prototype.pipe = function () {
                        this.emit('error', new Error('Cannot pipe. Not readable.'));
                    };
                    function writeAfterEnd(stream, cb) {
                        var er = new Error('write after end');
                        stream.emit('error', er);
                        processNextTick(cb, er);
                    }
                    function validChunk(stream, state, chunk, cb) {
                        var valid = true;
                        if (!Buffer.isBuffer(chunk) && typeof chunk !== 'string' && chunk !== null && chunk !== undefined && !state.objectMode) {
                            var er = new TypeError('Invalid non-string/buffer chunk');
                            stream.emit('error', er);
                            processNextTick(cb, er);
                            valid = false;
                        }
                        return valid;
                    }
                    Writable.prototype.write = function (chunk, encoding, cb) {
                        var state = this._writableState;
                        var ret = false;
                        if (typeof encoding === 'function') {
                            cb = encoding;
                            encoding = null;
                        }
                        if (Buffer.isBuffer(chunk))
                            encoding = 'buffer';
                        else if (!encoding)
                            encoding = state.defaultEncoding;
                        if (typeof cb !== 'function')
                            cb = nop;
                        if (state.ended)
                            writeAfterEnd(this, cb);
                        else if (validChunk(this, state, chunk, cb)) {
                            state.pendingcb++;
                            ret = writeOrBuffer(this, state, chunk, encoding, cb);
                        }
                        return ret;
                    };
                    Writable.prototype.cork = function () {
                        var state = this._writableState;
                        state.corked++;
                    };
                    Writable.prototype.uncork = function () {
                        var state = this._writableState;
                        if (state.corked) {
                            state.corked--;
                            if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest)
                                clearBuffer(this, state);
                        }
                    };
                    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
                        if (typeof encoding === 'string')
                            encoding = encoding.toLowerCase();
                        if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1))
                            throw new TypeError('Unknown encoding: ' + encoding);
                        this._writableState.defaultEncoding = encoding;
                    };
                    function decodeChunk(state, chunk, encoding) {
                        if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
                            chunk = new Buffer(chunk, encoding);
                        }
                        return chunk;
                    }
                    function writeOrBuffer(stream, state, chunk, encoding, cb) {
                        chunk = decodeChunk(state, chunk, encoding);
                        if (Buffer.isBuffer(chunk))
                            encoding = 'buffer';
                        var len = state.objectMode ? 1 : chunk.length;
                        state.length += len;
                        var ret = state.length < state.highWaterMark;
                        if (!ret)
                            state.needDrain = true;
                        if (state.writing || state.corked) {
                            var last = state.lastBufferedRequest;
                            state.lastBufferedRequest = new WriteReq(chunk, encoding, cb);
                            if (last) {
                                last.next = state.lastBufferedRequest;
                            }
                            else {
                                state.bufferedRequest = state.lastBufferedRequest;
                            }
                            state.bufferedRequestCount += 1;
                        }
                        else {
                            doWrite(stream, state, false, len, chunk, encoding, cb);
                        }
                        return ret;
                    }
                    function doWrite(stream, state, writev, len, chunk, encoding, cb) {
                        state.writelen = len;
                        state.writecb = cb;
                        state.writing = true;
                        state.sync = true;
                        if (writev)
                            stream._writev(chunk, state.onwrite);
                        else
                            stream._write(chunk, encoding, state.onwrite);
                        state.sync = false;
                    }
                    function onwriteError(stream, state, sync, er, cb) {
                        --state.pendingcb;
                        if (sync)
                            processNextTick(cb, er);
                        else
                            cb(er);
                        stream._writableState.errorEmitted = true;
                        stream.emit('error', er);
                    }
                    function onwriteStateUpdate(state) {
                        state.writing = false;
                        state.writecb = null;
                        state.length -= state.writelen;
                        state.writelen = 0;
                    }
                    function onwrite(stream, er) {
                        var state = stream._writableState;
                        var sync = state.sync;
                        var cb = state.writecb;
                        onwriteStateUpdate(state);
                        if (er)
                            onwriteError(stream, state, sync, er, cb);
                        else {
                            var finished = needFinish(state);
                            if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
                                clearBuffer(stream, state);
                            }
                            if (sync) {
                                asyncWrite(afterWrite, stream, state, finished, cb);
                            }
                            else {
                                afterWrite(stream, state, finished, cb);
                            }
                        }
                    }
                    function afterWrite(stream, state, finished, cb) {
                        if (!finished)
                            onwriteDrain(stream, state);
                        state.pendingcb--;
                        cb();
                        finishMaybe(stream, state);
                    }
                    function onwriteDrain(stream, state) {
                        if (state.length === 0 && state.needDrain) {
                            state.needDrain = false;
                            stream.emit('drain');
                        }
                    }
                    function clearBuffer(stream, state) {
                        state.bufferProcessing = true;
                        var entry = state.bufferedRequest;
                        if (stream._writev && entry && entry.next) {
                            var l = state.bufferedRequestCount;
                            var buffer = new Array(l);
                            var holder = state.corkedRequestsFree;
                            holder.entry = entry;
                            var count = 0;
                            while (entry) {
                                buffer[count] = entry;
                                entry = entry.next;
                                count += 1;
                            }
                            doWrite(stream, state, true, state.length, buffer, '', holder.finish);
                            state.pendingcb++;
                            state.lastBufferedRequest = null;
                            state.corkedRequestsFree = holder.next;
                            holder.next = null;
                        }
                        else {
                            while (entry) {
                                var chunk = entry.chunk;
                                var encoding = entry.encoding;
                                var cb = entry.callback;
                                var len = state.objectMode ? 1 : chunk.length;
                                doWrite(stream, state, false, len, chunk, encoding, cb);
                                entry = entry.next;
                                if (state.writing) {
                                    break;
                                }
                            }
                            if (entry === null)
                                state.lastBufferedRequest = null;
                        }
                        state.bufferedRequestCount = 0;
                        state.bufferedRequest = entry;
                        state.bufferProcessing = false;
                    }
                    Writable.prototype._write = function (chunk, encoding, cb) {
                        cb(new Error('not implemented'));
                    };
                    Writable.prototype._writev = null;
                    Writable.prototype.end = function (chunk, encoding, cb) {
                        var state = this._writableState;
                        if (typeof chunk === 'function') {
                            cb = chunk;
                            chunk = null;
                            encoding = null;
                        }
                        else if (typeof encoding === 'function') {
                            cb = encoding;
                            encoding = null;
                        }
                        if (chunk !== null && chunk !== undefined)
                            this.write(chunk, encoding);
                        if (state.corked) {
                            state.corked = 1;
                            this.uncork();
                        }
                        if (!state.ending && !state.finished)
                            endWritable(this, state, cb);
                    };
                    function needFinish(state) {
                        return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
                    }
                    function prefinish(stream, state) {
                        if (!state.prefinished) {
                            state.prefinished = true;
                            stream.emit('prefinish');
                        }
                    }
                    function finishMaybe(stream, state) {
                        var need = needFinish(state);
                        if (need) {
                            if (state.pendingcb === 0) {
                                prefinish(stream, state);
                                state.finished = true;
                                stream.emit('finish');
                            }
                            else {
                                prefinish(stream, state);
                            }
                        }
                        return need;
                    }
                    function endWritable(stream, state, cb) {
                        state.ending = true;
                        finishMaybe(stream, state);
                        if (cb) {
                            if (state.finished)
                                processNextTick(cb);
                            else
                                stream.once('finish', cb);
                        }
                        state.ended = true;
                        stream.writable = false;
                    }
                    function CorkedRequest(state) {
                        var _this = this;
                        this.next = null;
                        this.entry = null;
                        this.finish = function (err) {
                            var entry = _this.entry;
                            _this.entry = null;
                            while (entry) {
                                var cb = entry.callback;
                                state.pendingcb--;
                                cb(err);
                                entry = entry.next;
                            }
                            if (state.corkedRequestsFree) {
                                state.corkedRequestsFree.next = _this;
                            }
                            else {
                                state.corkedRequestsFree = _this;
                            }
                        };
                    }
                }).call(this, localRequire('_process'));
            }, { "./_stream_duplex": 190, "_process": 188, "buffer": 60, "core-util-is": 160, "events": 164, "inherits": 167, "process-nextick-args": 187, "util-deprecate": 222 }], 195: [function (localRequire, localModule, localExports) {
                localModule.localExports = localRequire("./lib/_stream_passthrough.js");
            }, { "./lib/_stream_passthrough.js": 191 }], 196: [function (localRequire, localModule, localExports) {
                var Stream = (function () {
                    try {
                        return localRequire('st' + 'ream');
                    }
                    catch (_) { }
                }());
                localExports = localModule.localExports = localRequire('./lib/_stream_readable.js');
                localExports.Stream = Stream || localExports;
                localExports.Readable = localExports;
                localExports.Writable = localRequire('./lib/_stream_writable.js');
                localExports.Duplex = localRequire('./lib/_stream_duplex.js');
                localExports.Transform = localRequire('./lib/_stream_transform.js');
                localExports.PassThrough = localRequire('./lib/_stream_passthrough.js');
            }, { "./lib/_stream_duplex.js": 190, "./lib/_stream_passthrough.js": 191, "./lib/_stream_readable.js": 192, "./lib/_stream_transform.js": 193, "./lib/_stream_writable.js": 194 }], 197: [function (localRequire, localModule, localExports) {
                localModule.localExports = localRequire("./lib/_stream_transform.js");
            }, { "./lib/_stream_transform.js": 193 }], 198: [function (localRequire, localModule, localExports) {
                localModule.localExports = localRequire("./lib/_stream_writable.js");
            }, { "./lib/_stream_writable.js": 194 }], 199: [function (localRequire, localModule, localExports) {
                (function () {
                    var key, val, _ref, _ref1;
                    localExports.EncodeStream = localRequire('./src/EncodeStream');
                    localExports.DecodeStream = localRequire('./src/DecodeStream');
                    localExports.Array = localRequire('./src/Array');
                    localExports.LazyArray = localRequire('./src/LazyArray');
                    localExports.Bitfield = localRequire('./src/Bitfield');
                    localExports.Boolean = localRequire('./src/Boolean');
                    localExports.Buffer = localRequire('./src/Buffer');
                    localExports.Enum = localRequire('./src/Enum');
                    localExports.Optional = localRequire('./src/Optional');
                    localExports.Reserved = localRequire('./src/Reserved');
                    localExports.String = localRequire('./src/String');
                    localExports.Struct = localRequire('./src/Struct');
                    localExports.VersionedStruct = localRequire('./src/VersionedStruct');
                    _ref = localRequire('./src/Number');
                    for (key in _ref) {
                        val = _ref[key];
                        localExports[key] = val;
                    }
                    _ref1 = localRequire('./src/Pointer');
                    for (key in _ref1) {
                        val = _ref1[key];
                        localExports[key] = val;
                    }
                }.call(this));
            }, { "./src/Array": 200, "./src/Bitfield": 201, "./src/Boolean": 202, "./src/Buffer": 203, "./src/DecodeStream": 204, "./src/EncodeStream": 205, "./src/Enum": 206, "./src/LazyArray": 207, "./src/Number": 208, "./src/Optional": 209, "./src/Pointer": 210, "./src/Reserved": 211, "./src/String": 212, "./src/Struct": 213, "./src/VersionedStruct": 214 }], 200: [function (localRequire, localModule, localExports) {
                (function () {
                    var ArrayT, NumberT, utils;
                    NumberT = localRequire('./Number').Number;
                    utils = localRequire('./utils');
                    ArrayT = function () {
                        function ArrayT(type, length, lengthType) {
                            this.type = type;
                            this.length = length;
                            this.lengthType = lengthType != null ? lengthType : 'count';
                        }
                        ArrayT.prototype.decode = function (stream, parent) {
                            var ctx, i, length, pos, res, target, _i;
                            pos = stream.pos;
                            res = [];
                            ctx = parent;
                            if (this.length != null) {
                                length = utils.resolveLength(this.length, stream, parent);
                            }
                            if (this.length instanceof NumberT) {
                                Object.defineProperties(res, {
                                    parent: { value: parent },
                                    _startOffset: { value: pos },
                                    _currentOffset: {
                                        value: 0,
                                        writable: true
                                    },
                                    _length: { value: length }
                                });
                                ctx = res;
                            }
                            if (length == null || this.lengthType === 'bytes') {
                                target = length != null ? stream.pos + length : (parent != null ? parent._length : void 0) ? parent._startOffset + parent._length : stream.length;
                                while (stream.pos < target) {
                                    res.push(this.type.decode(stream, ctx));
                                }
                            }
                            else {
                                for (i = _i = 0; _i < length; i = _i += 1) {
                                    res.push(this.type.decode(stream, ctx));
                                }
                            }
                            return res;
                        };
                        ArrayT.prototype.size = function (array, ctx) {
                            var item, size, _i, _len;
                            if (!array) {
                                return this.type.size(null, ctx) * utils.resolveLength(this.length, null, ctx);
                            }
                            size = 0;
                            if (this.length instanceof NumberT) {
                                size += this.length.size();
                                ctx = { parent: ctx };
                            }
                            for (_i = 0, _len = array.length; _i < _len; _i++) {
                                item = array[_i];
                                size += this.type.size(item, ctx);
                            }
                            return size;
                        };
                        ArrayT.prototype.encode = function (stream, array, parent) {
                            var ctx, i, item, ptr, _i, _len;
                            ctx = parent;
                            if (this.length instanceof NumberT) {
                                ctx = {
                                    pointers: [],
                                    startOffset: stream.pos,
                                    parent: parent
                                };
                                ctx.pointerOffset = stream.pos + this.size(array, ctx);
                                this.length.encode(stream, array.length);
                            }
                            for (_i = 0, _len = array.length; _i < _len; _i++) {
                                item = array[_i];
                                this.type.encode(stream, item, ctx);
                            }
                            if (this.length instanceof NumberT) {
                                i = 0;
                                while (i < ctx.pointers.length) {
                                    ptr = ctx.pointers[i++];
                                    ptr.type.encode(stream, ptr.val);
                                }
                            }
                        };
                        return ArrayT;
                    }();
                    localModule.localExports = ArrayT;
                }.call(this));
            }, { "./Number": 208, "./utils": 215 }], 201: [function (localRequire, localModule, localExports) {
                (function () {
                    var Bitfield;
                    Bitfield = function () {
                        function Bitfield(type, flags) {
                            this.type = type;
                            this.flags = flags != null ? flags : [];
                        }
                        Bitfield.prototype.decode = function (stream) {
                            var flag, i, res, val, _i, _len, _ref;
                            val = this.type.decode(stream);
                            res = {};
                            _ref = this.flags;
                            for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
                                flag = _ref[i];
                                if (flag != null) {
                                    res[flag] = !!(val & 1 << i);
                                }
                            }
                            return res;
                        };
                        Bitfield.prototype.size = function () {
                            return this.type.size();
                        };
                        Bitfield.prototype.encode = function (stream, keys) {
                            var flag, i, val, _i, _len, _ref;
                            val = 0;
                            _ref = this.flags;
                            for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
                                flag = _ref[i];
                                if (flag != null) {
                                    if (keys[flag]) {
                                        val |= 1 << i;
                                    }
                                }
                            }
                            return this.type.encode(stream, val);
                        };
                        return Bitfield;
                    }();
                    localModule.localExports = Bitfield;
                }.call(this));
            }, {}], 202: [function (localRequire, localModule, localExports) {
                (function () {
                    var BooleanT;
                    BooleanT = function () {
                        function BooleanT(type) {
                            this.type = type;
                        }
                        BooleanT.prototype.decode = function (stream, parent) {
                            return !!this.type.decode(stream, parent);
                        };
                        BooleanT.prototype.size = function (val, parent) {
                            return this.type.size(val, parent);
                        };
                        BooleanT.prototype.encode = function (stream, val, parent) {
                            return this.type.encode(stream, +val, parent);
                        };
                        return BooleanT;
                    }();
                    localModule.localExports = BooleanT;
                }.call(this));
            }, {}], 203: [function (localRequire, localModule, localExports) {
                (function () {
                    var BufferT, NumberT, utils;
                    utils = localRequire('./utils');
                    NumberT = localRequire('./Number').Number;
                    BufferT = function () {
                        function BufferT(length) {
                            this.length = length;
                        }
                        BufferT.prototype.decode = function (stream, parent) {
                            var length;
                            length = utils.resolveLength(this.length, stream, parent);
                            return stream.readBuffer(length);
                        };
                        BufferT.prototype.size = function (val, parent) {
                            if (!val) {
                                return utils.resolveLength(this.length, null, parent);
                            }
                            return val.length;
                        };
                        BufferT.prototype.encode = function (stream, buf, parent) {
                            if (this.length instanceof NumberT) {
                                this.length.encode(stream, buf.length);
                            }
                            return stream.writeBuffer(buf);
                        };
                        return BufferT;
                    }();
                    localModule.localExports = BufferT;
                }.call(this));
            }, { "./Number": 208, "./utils": 215 }], 204: [function (localRequire, localModule, localExports) {
                (function (Buffer) {
                    (function () {
                        var DecodeStream, iconv;
                        try {
                            iconv = function () {
                                throw new Error('Cannot find module \'iconv-lite\' from \'/Users/devongovett/projects/PDFKit/node_modules/restructure/src\'');
                            }();
                        }
                        catch (_error) {
                        }
                        DecodeStream = function () {
                            var key;
                            function DecodeStream(buffer) {
                                this.buffer = buffer;
                                this.pos = 0;
                                this.length = this.buffer.length;
                            }
                            DecodeStream.TYPES = {
                                UInt8: 1,
                                UInt16: 2,
                                UInt24: 3,
                                UInt32: 4,
                                Int8: 1,
                                Int16: 2,
                                Int24: 3,
                                Int32: 4,
                                Float: 4,
                                Double: 8
                            };
                            for (key in Buffer.prototype) {
                                if (key.slice(0, 4) === 'read') {
                                    (function (key) {
                                        var bytes;
                                        bytes = DecodeStream.TYPES[key.replace(/read|[BL]E/g, '')];
                                        return DecodeStream.prototype[key] = function () {
                                            var ret;
                                            ret = this.buffer[key](this.pos);
                                            this.pos += bytes;
                                            return ret;
                                        };
                                    }(key));
                                }
                            }
                            DecodeStream.prototype.readString = function (length, encoding) {
                                var buf, byte, i, _i, _ref;
                                if (encoding == null) {
                                    encoding = 'ascii';
                                }
                                switch (encoding) {
                                    case 'utf16le':
                                    case 'ucs2':
                                    case 'utf8':
                                    case 'ascii':
                                        return this.buffer.toString(encoding, this.pos, this.pos += length);
                                    case 'utf16be':
                                        buf = new Buffer(this.readBuffer(length));
                                        for (i = _i = 0, _ref = buf.length - 1; _i < _ref; i = _i += 2) {
                                            byte = buf[i];
                                            buf[i] = buf[i + 1];
                                            buf[i + 1] = byte;
                                        }
                                        return buf.toString('utf16le');
                                    default:
                                        buf = this.readBuffer(length);
                                        if (iconv) {
                                            return iconv.decode(buf, encoding);
                                        }
                                        return buf;
                                }
                            };
                            DecodeStream.prototype.readBuffer = function (length) {
                                return this.buffer.slice(this.pos, this.pos += length);
                            };
                            DecodeStream.prototype.readUInt24BE = function () {
                                return (this.readUInt16BE() << 8) + this.readUInt8();
                            };
                            DecodeStream.prototype.readUInt24LE = function () {
                                return this.readUInt16LE() + (this.readUInt8() << 16);
                            };
                            DecodeStream.prototype.readInt24BE = function () {
                                return (this.readInt16BE() << 8) + this.readUInt8();
                            };
                            DecodeStream.prototype.readInt24LE = function () {
                                return this.readUInt16LE() + (this.readInt8() << 16);
                            };
                            return DecodeStream;
                        }();
                        localModule.localExports = DecodeStream;
                    }.call(this));
                }).call(this, localRequire("buffer").Buffer);
            }, { "buffer": 60 }], 205: [function (localRequire, localModule, localExports) {
                (function (Buffer) {
                    (function () {
                        var DecodeStream, EncodeStream, iconv, stream, __hasProp = {}.hasOwnProperty, __extends = function (child, parent) {
                            for (var key in parent) {
                                if (__hasProp.call(parent, key))
                                    child[key] = parent[key];
                            }
                            function ctor() {
                                this.constructor = child;
                            }
                            ctor.prototype = parent.prototype;
                            child.prototype = new ctor();
                            child.__super__ = parent.prototype;
                            return child;
                        };
                        stream = localRequire('stream');
                        DecodeStream = localRequire('./DecodeStream');
                        try {
                            iconv = function () {
                                throw new Error('Cannot find module \'iconv-lite\' from \'/Users/devongovett/projects/PDFKit/node_modules/restructure/src\'');
                            }();
                        }
                        catch (_error) {
                        }
                        EncodeStream = function (_super) {
                            var key;
                            __extends(EncodeStream, _super);
                            function EncodeStream() {
                                EncodeStream.__super__.constructor.apply(this, arguments);
                                this.pos = 0;
                            }
                            for (key in Buffer.prototype) {
                                if (key.slice(0, 5) === 'write') {
                                    (function (key) {
                                        var bytes;
                                        bytes = DecodeStream.TYPES[key.replace(/write|[BL]E/g, '')];
                                        return EncodeStream.prototype[key] = function (value) {
                                            var buffer;
                                            buffer = new Buffer(+bytes);
                                            buffer[key](value, 0);
                                            return this.writeBuffer(buffer);
                                        };
                                    }(key));
                                }
                            }
                            EncodeStream.prototype._read = function () {
                            };
                            EncodeStream.prototype.writeBuffer = function (buffer) {
                                this.push(buffer);
                                return this.pos += buffer.length;
                            };
                            EncodeStream.prototype.writeString = function (string, encoding) {
                                var buf, byte, i, _i, _ref;
                                if (encoding == null) {
                                    encoding = 'ascii';
                                }
                                switch (encoding) {
                                    case 'utf16le':
                                    case 'ucs2':
                                    case 'utf8':
                                    case 'ascii':
                                        return this.writeBuffer(new Buffer(string, encoding));
                                    case 'utf16be':
                                        buf = new Buffer(string, 'utf16le');
                                        for (i = _i = 0, _ref = buf.length - 1; _i < _ref; i = _i += 2) {
                                            byte = buf[i];
                                            buf[i] = buf[i + 1];
                                            buf[i + 1] = byte;
                                        }
                                        return this.writeBuffer(buf);
                                    default:
                                        if (iconv) {
                                            return this.writeBuffer(iconv.encode(string, encoding));
                                        }
                                        else {
                                            throw new Error('Install iconv-lite to enable additional string encodings.');
                                        }
                                }
                            };
                            EncodeStream.prototype.writeUInt24BE = function (val) {
                                var buf;
                                buf = new Buffer(3);
                                buf[0] = val >>> 16 & 255;
                                buf[1] = val >>> 8 & 255;
                                buf[2] = val & 255;
                                return this.writeBuffer(buf);
                            };
                            EncodeStream.prototype.writeUInt24LE = function (val) {
                                var buf;
                                buf = new Buffer(3);
                                buf[0] = val & 255;
                                buf[1] = val >>> 8 & 255;
                                buf[2] = val >>> 16 & 255;
                                return this.writeBuffer(buf);
                            };
                            EncodeStream.prototype.writeInt24BE = function (val) {
                                if (val >= 0) {
                                    return this.writeUInt24BE(val);
                                }
                                else {
                                    return this.writeUInt24BE(val + 16777215 + 1);
                                }
                            };
                            EncodeStream.prototype.writeInt24LE = function (val) {
                                if (val >= 0) {
                                    return this.writeUInt24LE(val);
                                }
                                else {
                                    return this.writeUInt24LE(val + 16777215 + 1);
                                }
                            };
                            EncodeStream.prototype.fill = function (val, length) {
                                var buf;
                                buf = new Buffer(length);
                                buf.fill(val);
                                return this.writeBuffer(buf);
                            };
                            EncodeStream.prototype.end = function () {
                                return this.push(null);
                            };
                            return EncodeStream;
                        }(stream.Readable);
                        localModule.localExports = EncodeStream;
                    }.call(this));
                }).call(this, localRequire("buffer").Buffer);
            }, { "./DecodeStream": 204, "buffer": 60, "stream": 216 }], 206: [function (localRequire, localModule, localExports) {
                (function () {
                    var Enum;
                    Enum = function () {
                        function Enum(type, options) {
                            this.type = type;
                            this.options = options != null ? options : [];
                        }
                        Enum.prototype.decode = function (stream) {
                            var index;
                            index = this.type.decode(stream);
                            return this.options[index] || index;
                        };
                        Enum.prototype.size = function () {
                            return this.type.size();
                        };
                        Enum.prototype.encode = function (stream, val) {
                            var index;
                            index = this.options.indexOf(val);
                            if (index === -1) {
                                throw new Error('Unknown option in enum: ' + val);
                            }
                            return this.type.encode(stream, index);
                        };
                        return Enum;
                    }();
                    localModule.localExports = Enum;
                }.call(this));
            }, {}], 207: [function (localRequire, localModule, localExports) {
                (function () {
                    var ArrayT, LazyArray, LazyArrayT, NumberT, inspect, utils, __hasProp = {}.hasOwnProperty, __extends = function (child, parent) {
                        for (var key in parent) {
                            if (__hasProp.call(parent, key))
                                child[key] = parent[key];
                        }
                        function ctor() {
                            this.constructor = child;
                        }
                        ctor.prototype = parent.prototype;
                        child.prototype = new ctor();
                        child.__super__ = parent.prototype;
                        return child;
                    };
                    ArrayT = localRequire('./Array');
                    NumberT = localRequire('./Number').Number;
                    utils = localRequire('./utils');
                    inspect = localRequire('util').inspect;
                    LazyArrayT = function (_super) {
                        __extends(LazyArrayT, _super);
                        function LazyArrayT() {
                            return LazyArrayT.__super__.constructor.apply(this, arguments);
                        }
                        LazyArrayT.prototype.decode = function (stream, parent) {
                            var length, pos, res;
                            pos = stream.pos;
                            length = utils.resolveLength(this.length, stream, parent);
                            if (this.length instanceof NumberT) {
                                parent = {
                                    parent: parent,
                                    _startOffset: pos,
                                    _currentOffset: 0,
                                    _length: length
                                };
                            }
                            res = new LazyArray(this.type, length, stream, parent);
                            stream.pos += length * this.type.size(null, parent);
                            return res;
                        };
                        LazyArrayT.prototype.size = function (val, ctx) {
                            if (val instanceof LazyArray) {
                                val = val.toArray();
                            }
                            return LazyArrayT.__super__.size.call(this, val, ctx);
                        };
                        LazyArrayT.prototype.encode = function (stream, val, ctx) {
                            if (val instanceof LazyArray) {
                                val = val.toArray();
                            }
                            return LazyArrayT.__super__.encode.call(this, stream, val, ctx);
                        };
                        return LazyArrayT;
                    }(ArrayT);
                    LazyArray = function () {
                        function LazyArray(type, length, stream, ctx) {
                            this.type = type;
                            this.length = length;
                            this.stream = stream;
                            this.ctx = ctx;
                            this.base = this.stream.pos;
                            this.items = [];
                        }
                        LazyArray.prototype.get = function (index) {
                            var pos;
                            if (index < 0 || index >= this.length) {
                                return void 0;
                            }
                            if (this.items[index] == null) {
                                pos = this.stream.pos;
                                this.stream.pos = this.base + this.type.size(null, this.ctx) * index;
                                this.items[index] = this.type.decode(this.stream, this.ctx);
                                this.stream.pos = pos;
                            }
                            return this.items[index];
                        };
                        LazyArray.prototype.toArray = function () {
                            var i, _i, _ref, _results;
                            _results = [];
                            for (i = _i = 0, _ref = this.length; _i < _ref; i = _i += 1) {
                                _results.push(this.get(i));
                            }
                            return _results;
                        };
                        LazyArray.prototype.inspect = function () {
                            return inspect(this.toArray());
                        };
                        return LazyArray;
                    }();
                    localModule.localExports = LazyArrayT;
                }.call(this));
            }, { "./Array": 200, "./Number": 208, "./utils": 215, "util": 224 }], 208: [function (localRequire, localModule, localExports) {
                (function () {
                    var DecodeStream, Fixed, NumberT, __hasProp = {}.hasOwnProperty, __extends = function (child, parent) {
                        for (var key in parent) {
                            if (__hasProp.call(parent, key))
                                child[key] = parent[key];
                        }
                        function ctor() {
                            this.constructor = child;
                        }
                        ctor.prototype = parent.prototype;
                        child.prototype = new ctor();
                        child.__super__ = parent.prototype;
                        return child;
                    };
                    DecodeStream = localRequire('./DecodeStream');
                    NumberT = function () {
                        function NumberT(type, endian) {
                            this.type = type;
                            this.endian = endian != null ? endian : 'BE';
                            this.fn = this.type;
                            if (this.type[this.type.length - 1] !== '8') {
                                this.fn += this.endian;
                            }
                        }
                        NumberT.prototype.size = function () {
                            return DecodeStream.TYPES[this.type];
                        };
                        NumberT.prototype.decode = function (stream) {
                            return stream['read' + this.fn]();
                        };
                        NumberT.prototype.encode = function (stream, val) {
                            return stream['write' + this.fn](val);
                        };
                        return NumberT;
                    }();
                    localExports.Number = NumberT;
                    localExports.uint8 = new NumberT('UInt8');
                    localExports.uint16be = localExports.uint16 = new NumberT('UInt16', 'BE');
                    localExports.uint16le = new NumberT('UInt16', 'LE');
                    localExports.uint24be = localExports.uint24 = new NumberT('UInt24', 'BE');
                    localExports.uint24le = new NumberT('UInt24', 'LE');
                    localExports.uint32be = localExports.uint32 = new NumberT('UInt32', 'BE');
                    localExports.uint32le = new NumberT('UInt32', 'LE');
                    localExports.int8 = new NumberT('Int8');
                    localExports.int16be = localExports.int16 = new NumberT('Int16', 'BE');
                    localExports.int16le = new NumberT('Int16', 'LE');
                    localExports.int24be = localExports.int24 = new NumberT('Int24', 'BE');
                    localExports.int24le = new NumberT('Int24', 'LE');
                    localExports.int32be = localExports.int32 = new NumberT('Int32', 'BE');
                    localExports.int32le = new NumberT('Int32', 'LE');
                    localExports.floatbe = localExports.float = new NumberT('Float', 'BE');
                    localExports.floatle = new NumberT('Float', 'LE');
                    localExports.doublebe = localExports.double = new NumberT('Double', 'BE');
                    localExports.doublele = new NumberT('Double', 'LE');
                    Fixed = function (_super) {
                        __extends(Fixed, _super);
                        function Fixed(size, endian, fracBits) {
                            if (fracBits == null) {
                                fracBits = size >> 1;
                            }
                            Fixed.__super__.constructor.call(this, 'Int' + size, endian);
                            this._point = 1 << fracBits;
                        }
                        Fixed.prototype.decode = function (stream) {
                            return Fixed.__super__.decode.call(this, stream) / this._point;
                        };
                        Fixed.prototype.encode = function (stream, val) {
                            return Fixed.__super__.encode.call(this, stream, val * this._point | 0);
                        };
                        return Fixed;
                    }(NumberT);
                    localExports.Fixed = Fixed;
                    localExports.fixed16be = localExports.fixed16 = new Fixed(16, 'BE');
                    localExports.fixed16le = new Fixed(16, 'LE');
                    localExports.fixed32be = localExports.fixed32 = new Fixed(32, 'BE');
                    localExports.fixed32le = new Fixed(32, 'LE');
                }.call(this));
            }, { "./DecodeStream": 204 }], 209: [function (localRequire, localModule, localExports) {
                (function () {
                    var Optional;
                    Optional = function () {
                        function Optional(type, condition) {
                            this.type = type;
                            this.condition = condition != null ? condition : true;
                        }
                        Optional.prototype.decode = function (stream, parent) {
                            var condition;
                            condition = this.condition;
                            if (typeof condition === 'function') {
                                condition = condition.call(parent, parent);
                            }
                            if (condition) {
                                return this.type.decode(stream, parent);
                            }
                        };
                        Optional.prototype.size = function (val, parent) {
                            var condition;
                            condition = this.condition;
                            if (typeof condition === 'function') {
                                condition = condition.call(parent, parent);
                            }
                            if (condition) {
                                return this.type.size(val, parent);
                            }
                            else {
                                return 0;
                            }
                        };
                        Optional.prototype.encode = function (stream, val, parent) {
                            var condition;
                            condition = this.condition;
                            if (typeof condition === 'function') {
                                condition = condition.call(parent, parent);
                            }
                            if (condition) {
                                return this.type.encode(stream, val, parent);
                            }
                        };
                        return Optional;
                    }();
                    localModule.localExports = Optional;
                }.call(this));
            }, {}], 210: [function (localRequire, localModule, localExports) {
                (function () {
                    var Pointer, VoidPointer, utils;
                    utils = localRequire('./utils');
                    Pointer = function () {
                        function Pointer(offsetType, type, options) {
                            var _base, _base1, _base2, _base3;
                            this.offsetType = offsetType;
                            this.type = type;
                            this.options = options != null ? options : {};
                            if (this.type === 'void') {
                                this.type = null;
                            }
                            if ((_base = this.options).type == null) {
                                _base.type = 'local';
                            }
                            if ((_base1 = this.options).allowNull == null) {
                                _base1.allowNull = true;
                            }
                            if ((_base2 = this.options).nullValue == null) {
                                _base2.nullValue = 0;
                            }
                            if ((_base3 = this.options).lazy == null) {
                                _base3.lazy = false;
                            }
                            if (this.options.relativeTo) {
                                this.relativeToGetter = new Function('ctx', 'return ctx.' + this.options.relativeTo);
                            }
                        }
                        Pointer.prototype.decode = function (stream, ctx) {
                            var c, decodeValue, offset, ptr, relative, val;
                            offset = this.offsetType.decode(stream);
                            if (offset === this.options.nullValue && this.options.allowNull) {
                                return null;
                            }
                            relative = function () {
                                switch (this.options.type) {
                                    case 'local':
                                        return ctx._startOffset;
                                    case 'immediate':
                                        return stream.pos - this.offsetType.size();
                                    case 'parent':
                                        return ctx.parent._startOffset;
                                    default:
                                        c = ctx;
                                        while (c.parent) {
                                            c = c.parent;
                                        }
                                        return c._startOffset || 0;
                                }
                            }.call(this);
                            if (this.options.relativeTo) {
                                relative += this.relativeToGetter(ctx);
                            }
                            ptr = offset + relative;
                            if (this.type != null) {
                                val = null;
                                decodeValue = function (_this) {
                                    return function () {
                                        var pos;
                                        if (val != null) {
                                            return val;
                                        }
                                        pos = stream.pos;
                                        stream.pos = ptr;
                                        val = _this.type.decode(stream, ctx);
                                        stream.pos = pos;
                                        return val;
                                    };
                                }(this);
                                if (this.options.lazy) {
                                    return new utils.PropertyDescriptor({ get: decodeValue });
                                }
                                return decodeValue();
                            }
                            else {
                                return ptr;
                            }
                        };
                        Pointer.prototype.size = function (val, ctx) {
                            var parent, type;
                            parent = ctx;
                            switch (this.options.type) {
                                case 'local':
                                case 'immediate':
                                    break;
                                case 'parent':
                                    ctx = ctx.parent;
                                    break;
                                default:
                                    while (ctx.parent) {
                                        ctx = ctx.parent;
                                    }
                            }
                            type = this.type;
                            if (type == null) {
                                if (!(val instanceof VoidPointer)) {
                                    throw new Error('Must be a VoidPointer');
                                }
                                type = val.type;
                                val = val.value;
                            }
                            if (val && ctx) {
                                ctx.pointerSize += type.size(val, parent);
                            }
                            return this.offsetType.size();
                        };
                        Pointer.prototype.encode = function (stream, val, ctx) {
                            var parent, relative, type;
                            parent = ctx;
                            if (val == null) {
                                this.offsetType.encode(stream, this.options.nullValue);
                                return;
                            }
                            switch (this.options.type) {
                                case 'local':
                                    relative = ctx.startOffset;
                                    break;
                                case 'immediate':
                                    relative = stream.pos + this.offsetType.size(val, parent);
                                    break;
                                case 'parent':
                                    ctx = ctx.parent;
                                    relative = ctx.startOffset;
                                    break;
                                default:
                                    relative = 0;
                                    while (ctx.parent) {
                                        ctx = ctx.parent;
                                    }
                            }
                            if (this.options.relativeTo) {
                                relative += this.relativeToGetter(parent.val);
                            }
                            this.offsetType.encode(stream, ctx.pointerOffset - relative);
                            type = this.type;
                            if (type == null) {
                                if (!(val instanceof VoidPointer)) {
                                    throw new Error('Must be a VoidPointer');
                                }
                                type = val.type;
                                val = val.value;
                            }
                            ctx.pointers.push({
                                type: type,
                                val: val,
                                parent: parent
                            });
                            return ctx.pointerOffset += type.size(val, parent);
                        };
                        return Pointer;
                    }();
                    VoidPointer = function () {
                        function VoidPointer(type, value) {
                            this.type = type;
                            this.value = value;
                        }
                        return VoidPointer;
                    }();
                    localExports.Pointer = Pointer;
                    localExports.VoidPointer = VoidPointer;
                }.call(this));
            }, { "./utils": 215 }], 211: [function (localRequire, localModule, localExports) {
                (function () {
                    var Reserved, utils;
                    utils = localRequire('./utils');
                    Reserved = function () {
                        function Reserved(type, count) {
                            this.type = type;
                            this.count = count != null ? count : 1;
                        }
                        Reserved.prototype.decode = function (stream, parent) {
                            stream.pos += this.size(null, parent);
                            return void 0;
                        };
                        Reserved.prototype.size = function (data, parent) {
                            var count;
                            count = utils.resolveLength(this.count, null, parent);
                            return this.type.size() * count;
                        };
                        Reserved.prototype.encode = function (stream, val, parent) {
                            return stream.fill(0, this.size(val, parent));
                        };
                        return Reserved;
                    }();
                    localModule.localExports = Reserved;
                }.call(this));
            }, { "./utils": 215 }], 212: [function (localRequire, localModule, localExports) {
                (function (Buffer) {
                    (function () {
                        var NumberT, StringT, utils;
                        NumberT = localRequire('./Number').Number;
                        utils = localRequire('./utils');
                        StringT = function () {
                            function StringT(length, encoding) {
                                this.length = length;
                                this.encoding = encoding != null ? encoding : 'ascii';
                            }
                            StringT.prototype.decode = function (stream, parent) {
                                var buffer, encoding, length, pos, string;
                                length = function () {
                                    if (this.length != null) {
                                        return utils.resolveLength(this.length, stream, parent);
                                    }
                                    else {
                                        buffer = stream.buffer, length = stream.length, pos = stream.pos;
                                        while (pos < length && buffer[pos] !== 0) {
                                            ++pos;
                                        }
                                        return pos - stream.pos;
                                    }
                                }.call(this);
                                encoding = this.encoding;
                                if (typeof encoding === 'function') {
                                    encoding = encoding.call(parent, parent) || 'ascii';
                                }
                                string = stream.readString(length, encoding);
                                if (this.length == null && stream.pos < stream.length) {
                                    stream.pos++;
                                }
                                return string;
                            };
                            StringT.prototype.size = function (val, parent) {
                                var encoding, size;
                                if (!val) {
                                    return utils.resolveLength(this.length, null, parent);
                                }
                                encoding = this.encoding;
                                if (typeof encoding === 'function') {
                                    encoding = encoding.call(parent != null ? parent.val : void 0, parent != null ? parent.val : void 0) || 'ascii';
                                }
                                if (encoding === 'utf16be') {
                                    encoding = 'utf16le';
                                }
                                size = Buffer.byteLength(val, encoding);
                                if (this.length instanceof NumberT) {
                                    size += this.length.size();
                                }
                                if (this.length == null) {
                                    size++;
                                }
                                return size;
                            };
                            StringT.prototype.encode = function (stream, val, parent) {
                                var encoding;
                                encoding = this.encoding;
                                if (typeof encoding === 'function') {
                                    encoding = encoding.call(parent != null ? parent.val : void 0, parent != null ? parent.val : void 0) || 'ascii';
                                }
                                if (this.length instanceof NumberT) {
                                    this.length.encode(stream, Buffer.byteLength(val, encoding));
                                }
                                stream.writeString(val, encoding);
                                if (this.length == null) {
                                    return stream.writeUInt8(0);
                                }
                            };
                            return StringT;
                        }();
                        localModule.localExports = StringT;
                    }.call(this));
                }).call(this, localRequire("buffer").Buffer);
            }, { "./Number": 208, "./utils": 215, "buffer": 60 }], 213: [function (localRequire, localModule, localExports) {
                (function () {
                    var Struct, utils;
                    utils = localRequire('./utils');
                    Struct = function () {
                        function Struct(fields) {
                            this.fields = fields != null ? fields : {};
                        }
                        Struct.prototype.decode = function (stream, parent, length) {
                            var res, _ref;
                            if (length == null) {
                                length = 0;
                            }
                            res = this._setup(stream, parent, length);
                            this._parseFields(stream, res, this.fields);
                            if ((_ref = this.process) != null) {
                                _ref.call(res, stream);
                            }
                            return res;
                        };
                        Struct.prototype._setup = function (stream, parent, length) {
                            var res;
                            res = {};
                            Object.defineProperties(res, {
                                parent: { value: parent },
                                _startOffset: { value: stream.pos },
                                _currentOffset: {
                                    value: 0,
                                    writable: true
                                },
                                _length: { value: length }
                            });
                            return res;
                        };
                        Struct.prototype._parseFields = function (stream, res, fields) {
                            var key, type, val;
                            for (key in fields) {
                                type = fields[key];
                                if (typeof type === 'function') {
                                    val = type.call(res, res);
                                }
                                else {
                                    val = type.decode(stream, res);
                                }
                                if (val !== void 0) {
                                    if (val instanceof utils.PropertyDescriptor) {
                                        Object.defineProperty(res, key, val);
                                    }
                                    else {
                                        res[key] = val;
                                    }
                                }
                                res._currentOffset = stream.pos - res._startOffset;
                            }
                        };
                        Struct.prototype.size = function (val, parent, includePointers) {
                            var ctx, key, size, type, _ref;
                            if (val == null) {
                                val = {};
                            }
                            if (includePointers == null) {
                                includePointers = true;
                            }
                            ctx = {
                                parent: parent,
                                val: val,
                                pointerSize: 0
                            };
                            size = 0;
                            _ref = this.fields;
                            for (key in _ref) {
                                type = _ref[key];
                                if (type.size != null) {
                                    size += type.size(val[key], ctx);
                                }
                            }
                            if (includePointers) {
                                size += ctx.pointerSize;
                            }
                            return size;
                        };
                        Struct.prototype.encode = function (stream, val, parent) {
                            var ctx, i, key, ptr, type, _ref, _ref1;
                            if ((_ref = this.preEncode) != null) {
                                _ref.call(val, stream);
                            }
                            ctx = {
                                pointers: [],
                                startOffset: stream.pos,
                                parent: parent,
                                val: val,
                                pointerSize: 0
                            };
                            ctx.pointerOffset = stream.pos + this.size(val, ctx, false);
                            _ref1 = this.fields;
                            for (key in _ref1) {
                                type = _ref1[key];
                                if (type.encode != null) {
                                    type.encode(stream, val[key], ctx);
                                }
                            }
                            i = 0;
                            while (i < ctx.pointers.length) {
                                ptr = ctx.pointers[i++];
                                ptr.type.encode(stream, ptr.val, ptr.parent);
                            }
                        };
                        return Struct;
                    }();
                    localModule.localExports = Struct;
                }.call(this));
            }, { "./utils": 215 }], 214: [function (localRequire, localModule, localExports) {
                (function () {
                    var Struct, VersionedStruct, __hasProp = {}.hasOwnProperty, __extends = function (child, parent) {
                        for (var key in parent) {
                            if (__hasProp.call(parent, key))
                                child[key] = parent[key];
                        }
                        function ctor() {
                            this.constructor = child;
                        }
                        ctor.prototype = parent.prototype;
                        child.prototype = new ctor();
                        child.__super__ = parent.prototype;
                        return child;
                    };
                    Struct = localRequire('./Struct');
                    VersionedStruct = function (_super) {
                        __extends(VersionedStruct, _super);
                        function VersionedStruct(type, versions) {
                            this.type = type;
                            this.versions = versions != null ? versions : {};
                            if (typeof this.type === 'string') {
                                this.versionGetter = new Function('parent', 'return parent.' + this.type);
                                this.versionSetter = new Function('parent', 'version', 'return parent.' + this.type + ' = version');
                            }
                        }
                        VersionedStruct.prototype.decode = function (stream, parent, length) {
                            var fields, res, _ref;
                            if (length == null) {
                                length = 0;
                            }
                            res = this._setup(stream, parent, length);
                            if (typeof this.type === 'string') {
                                res.version = this.versionGetter(parent);
                            }
                            else {
                                res.version = this.type.decode(stream);
                            }
                            if (this.versions.header) {
                                this._parseFields(stream, res, this.versions.header);
                            }
                            fields = this.versions[res.version];
                            if (fields == null) {
                                throw new Error('Unknown version ' + res.version);
                            }
                            if (fields instanceof VersionedStruct) {
                                return fields.decode(stream, parent);
                            }
                            this._parseFields(stream, res, fields);
                            if ((_ref = this.process) != null) {
                                _ref.call(res, stream);
                            }
                            return res;
                        };
                        VersionedStruct.prototype.size = function (val, parent, includePointers) {
                            var ctx, fields, key, size, type, _ref;
                            if (includePointers == null) {
                                includePointers = true;
                            }
                            if (!val) {
                                throw new Error('Not a fixed size');
                            }
                            ctx = {
                                parent: parent,
                                val: val,
                                pointerSize: 0
                            };
                            size = 0;
                            if (typeof this.type !== 'string') {
                                size += this.type.size(val.version, ctx);
                            }
                            if (this.versions.header) {
                                _ref = this.versions.header;
                                for (key in _ref) {
                                    type = _ref[key];
                                    if (type.size != null) {
                                        size += type.size(val[key], ctx);
                                    }
                                }
                            }
                            fields = this.versions[val.version];
                            if (fields == null) {
                                throw new Error('Unknown version ' + val.version);
                            }
                            for (key in fields) {
                                type = fields[key];
                                if (type.size != null) {
                                    size += type.size(val[key], ctx);
                                }
                            }
                            if (includePointers) {
                                size += ctx.pointerSize;
                            }
                            return size;
                        };
                        VersionedStruct.prototype.encode = function (stream, val, parent) {
                            var ctx, fields, i, key, ptr, type, _ref, _ref1;
                            if ((_ref = this.preEncode) != null) {
                                _ref.call(val, stream);
                            }
                            ctx = {
                                pointers: [],
                                startOffset: stream.pos,
                                parent: parent,
                                val: val,
                                pointerSize: 0
                            };
                            ctx.pointerOffset = stream.pos + this.size(val, ctx, false);
                            if (typeof this.type !== 'string') {
                                this.type.encode(stream, val.version);
                            }
                            if (this.versions.header) {
                                _ref1 = this.versions.header;
                                for (key in _ref1) {
                                    type = _ref1[key];
                                    if (type.encode != null) {
                                        type.encode(stream, val[key], ctx);
                                    }
                                }
                            }
                            fields = this.versions[val.version];
                            for (key in fields) {
                                type = fields[key];
                                if (type.encode != null) {
                                    type.encode(stream, val[key], ctx);
                                }
                            }
                            i = 0;
                            while (i < ctx.pointers.length) {
                                ptr = ctx.pointers[i++];
                                ptr.type.encode(stream, ptr.val, ptr.parent);
                            }
                        };
                        return VersionedStruct;
                    }(Struct);
                    localModule.localExports = VersionedStruct;
                }.call(this));
            }, { "./Struct": 213 }], 215: [function (localRequire, localModule, localExports) {
                (function () {
                    var NumberT, PropertyDescriptor;
                    NumberT = localRequire('./Number').Number;
                    localExports.resolveLength = function (length, stream, parent) {
                        var res;
                        if (typeof length === 'number') {
                            res = length;
                        }
                        else if (typeof length === 'function') {
                            res = length.call(parent, parent);
                        }
                        else if (parent && typeof length === 'string') {
                            res = parent[length];
                        }
                        else if (stream && length instanceof NumberT) {
                            res = length.decode(stream);
                        }
                        if (isNaN(res)) {
                            throw new Error('Not a fixed size');
                        }
                        return res;
                    };
                    PropertyDescriptor = function () {
                        function PropertyDescriptor(opts) {
                            var key, val;
                            if (opts == null) {
                                opts = {};
                            }
                            this.enumerable = true;
                            this.configurable = true;
                            for (key in opts) {
                                val = opts[key];
                                this[key] = val;
                            }
                        }
                        return PropertyDescriptor;
                    }();
                    localExports.PropertyDescriptor = PropertyDescriptor;
                }.call(this));
            }, { "./Number": 208 }], 216: [function (localRequire, localModule, localExports) {
                localModule.localExports = Stream;
                var EE = localRequire('events').EventEmitter;
                var inherits = localRequire('inherits');
                inherits(Stream, EE);
                Stream.Readable = localRequire('readable-stream/readable.js');
                Stream.Writable = localRequire('readable-stream/writable.js');
                Stream.Duplex = localRequire('readable-stream/duplex.js');
                Stream.Transform = localRequire('readable-stream/transform.js');
                Stream.PassThrough = localRequire('readable-stream/passthrough.js');
                Stream.Stream = Stream;
                function Stream() {
                    EE.call(this);
                }
                Stream.prototype.pipe = function (dest, options) {
                    var source = this;
                    function ondata(chunk) {
                        if (dest.writable) {
                            if (false === dest.write(chunk) && source.pause) {
                                source.pause();
                            }
                        }
                    }
                    source.on('data', ondata);
                    function ondrain() {
                        if (source.readable && source.resume) {
                            source.resume();
                        }
                    }
                    dest.on('drain', ondrain);
                    if (!dest._isStdio && (!options || options.end !== false)) {
                        source.on('end', onend);
                        source.on('close', onclose);
                    }
                    var didOnEnd = false;
                    function onend() {
                        if (didOnEnd)
                            return;
                        didOnEnd = true;
                        dest.end();
                    }
                    function onclose() {
                        if (didOnEnd)
                            return;
                        didOnEnd = true;
                        if (typeof dest.destroy === 'function')
                            dest.destroy();
                    }
                    function onerror(er) {
                        cleanup();
                        if (EE.listenerCount(this, 'error') === 0) {
                            throw er;
                        }
                    }
                    source.on('error', onerror);
                    dest.on('error', onerror);
                    function cleanup() {
                        source.removeListener('data', ondata);
                        dest.removeListener('drain', ondrain);
                        source.removeListener('end', onend);
                        source.removeListener('close', onclose);
                        source.removeListener('error', onerror);
                        dest.removeListener('error', onerror);
                        source.removeListener('end', cleanup);
                        source.removeListener('close', cleanup);
                        dest.removeListener('close', cleanup);
                    }
                    source.on('end', cleanup);
                    source.on('close', cleanup);
                    dest.on('close', cleanup);
                    dest.emit('pipe', source);
                    return dest;
                };
            }, { "events": 164, "inherits": 167, "readable-stream/duplex.js": 189, "readable-stream/passthrough.js": 195, "readable-stream/readable.js": 196, "readable-stream/transform.js": 197, "readable-stream/writable.js": 198 }], 217: [function (localRequire, localModule, localExports) {
                var Buffer = localRequire('buffer').Buffer;
                var isBufferEncoding = Buffer.isEncoding
                    || function (encoding) {
                        switch (encoding && encoding.toLowerCase()) {
                            case 'hex':
                            case 'utf8':
                            case 'utf-8':
                            case 'ascii':
                            case 'binary':
                            case 'base64':
                            case 'ucs2':
                            case 'ucs-2':
                            case 'utf16le':
                            case 'utf-16le':
                            case 'raw': return true;
                            default: return false;
                        }
                    };
                function assertEncoding(encoding) {
                    if (encoding && !isBufferEncoding(encoding)) {
                        throw new Error('Unknown encoding: ' + encoding);
                    }
                }
                var StringDecoder = localExports.StringDecoder = function (encoding) {
                    this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
                    assertEncoding(encoding);
                    switch (this.encoding) {
                        case 'utf8':
                            this.surrogateSize = 3;
                            break;
                        case 'ucs2':
                        case 'utf16le':
                            this.surrogateSize = 2;
                            this.detectIncompleteChar = utf16DetectIncompleteChar;
                            break;
                        case 'base64':
                            this.surrogateSize = 3;
                            this.detectIncompleteChar = base64DetectIncompleteChar;
                            break;
                        default:
                            this.write = passThroughWrite;
                            return;
                    }
                    this.charBuffer = new Buffer(6);
                    this.charReceived = 0;
                    this.charLength = 0;
                };
                StringDecoder.prototype.write = function (buffer) {
                    var charStr = '';
                    while (this.charLength) {
                        var available = (buffer.length >= this.charLength - this.charReceived) ?
                            this.charLength - this.charReceived :
                            buffer.length;
                        buffer.copy(this.charBuffer, this.charReceived, 0, available);
                        this.charReceived += available;
                        if (this.charReceived < this.charLength) {
                            return '';
                        }
                        buffer = buffer.slice(available, buffer.length);
                        charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);
                        var charCode = charStr.charCodeAt(charStr.length - 1);
                        if (charCode >= 0xD800 && charCode <= 0xDBFF) {
                            this.charLength += this.surrogateSize;
                            charStr = '';
                            continue;
                        }
                        this.charReceived = this.charLength = 0;
                        if (buffer.length === 0) {
                            return charStr;
                        }
                        break;
                    }
                    this.detectIncompleteChar(buffer);
                    var end = buffer.length;
                    if (this.charLength) {
                        buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
                        end -= this.charReceived;
                    }
                    charStr += buffer.toString(this.encoding, 0, end);
                    var end = charStr.length - 1;
                    var charCode = charStr.charCodeAt(end);
                    if (charCode >= 0xD800 && charCode <= 0xDBFF) {
                        var size = this.surrogateSize;
                        this.charLength += size;
                        this.charReceived += size;
                        this.charBuffer.copy(this.charBuffer, size, 0, size);
                        buffer.copy(this.charBuffer, 0, 0, size);
                        return charStr.substring(0, end);
                    }
                    return charStr;
                };
                StringDecoder.prototype.detectIncompleteChar = function (buffer) {
                    var i = (buffer.length >= 3) ? 3 : buffer.length;
                    for (; i > 0; i--) {
                        var c = buffer[buffer.length - i];
                        if (i == 1 && c >> 5 == 0x06) {
                            this.charLength = 2;
                            break;
                        }
                        if (i <= 2 && c >> 4 == 0x0E) {
                            this.charLength = 3;
                            break;
                        }
                        if (i <= 3 && c >> 3 == 0x1E) {
                            this.charLength = 4;
                            break;
                        }
                    }
                    this.charReceived = i;
                };
                StringDecoder.prototype.end = function (buffer) {
                    var res = '';
                    if (buffer && buffer.length)
                        res = this.write(buffer);
                    if (this.charReceived) {
                        var cr = this.charReceived;
                        var buf = this.charBuffer;
                        var enc = this.encoding;
                        res += buf.slice(0, cr).toString(enc);
                    }
                    return res;
                };
                function passThroughWrite(buffer) {
                    return buffer.toString(this.encoding);
                }
                function utf16DetectIncompleteChar(buffer) {
                    this.charReceived = buffer.length % 2;
                    this.charLength = this.charReceived ? 2 : 0;
                }
                function base64DetectIncompleteChar(buffer) {
                    this.charReceived = buffer.length % 3;
                    this.charLength = this.charReceived ? 3 : 0;
                }
            }, { "buffer": 60 }], 218: [function (localRequire, localModule, localExports) {
                var TINF_OK = 0;
                var TINF_DATA_ERROR = -3;
                function Tree() {
                    this.table = new Uint16Array(16);
                    this.trans = new Uint16Array(288);
                }
                function Data(source, dest) {
                    this.source = source;
                    this.sourceIndex = 0;
                    this.tag = 0;
                    this.bitcount = 0;
                    this.dest = dest;
                    this.destLen = 0;
                    this.ltree = new Tree();
                    this.dtree = new Tree();
                }
                var sltree = new Tree();
                var sdtree = new Tree();
                var length_bits = new Uint8Array(30);
                var length_base = new Uint16Array(30);
                var dist_bits = new Uint8Array(30);
                var dist_base = new Uint16Array(30);
                var clcidx = new Uint8Array([
                    16, 17, 18, 0, 8, 7, 9, 6,
                    10, 5, 11, 4, 12, 3, 13, 2,
                    14, 1, 15
                ]);
                var code_tree = new Tree();
                var lengths = new Uint8Array(288 + 32);
                function tinf_build_bits_base(bits, base, delta, first) {
                    var i, sum;
                    for (i = 0; i < delta; ++i)
                        bits[i] = 0;
                    for (i = 0; i < 30 - delta; ++i)
                        bits[i + delta] = i / delta | 0;
                    for (sum = first, i = 0; i < 30; ++i) {
                        base[i] = sum;
                        sum += 1 << bits[i];
                    }
                }
                function tinf_build_fixed_trees(lt, dt) {
                    var i;
                    for (i = 0; i < 7; ++i)
                        lt.table[i] = 0;
                    lt.table[7] = 24;
                    lt.table[8] = 152;
                    lt.table[9] = 112;
                    for (i = 0; i < 24; ++i)
                        lt.trans[i] = 256 + i;
                    for (i = 0; i < 144; ++i)
                        lt.trans[24 + i] = i;
                    for (i = 0; i < 8; ++i)
                        lt.trans[24 + 144 + i] = 280 + i;
                    for (i = 0; i < 112; ++i)
                        lt.trans[24 + 144 + 8 + i] = 144 + i;
                    for (i = 0; i < 5; ++i)
                        dt.table[i] = 0;
                    dt.table[5] = 32;
                    for (i = 0; i < 32; ++i)
                        dt.trans[i] = i;
                }
                var offs = new Uint16Array(16);
                function tinf_build_tree(t, lengths, off, num) {
                    var i, sum;
                    for (i = 0; i < 16; ++i)
                        t.table[i] = 0;
                    for (i = 0; i < num; ++i)
                        t.table[lengths[off + i]]++;
                    t.table[0] = 0;
                    for (sum = 0, i = 0; i < 16; ++i) {
                        offs[i] = sum;
                        sum += t.table[i];
                    }
                    for (i = 0; i < num; ++i) {
                        if (lengths[off + i])
                            t.trans[offs[lengths[off + i]]++] = i;
                    }
                }
                function tinf_getbit(d) {
                    if (!d.bitcount--) {
                        d.tag = d.source[d.sourceIndex++];
                        d.bitcount = 7;
                    }
                    var bit = d.tag & 1;
                    d.tag >>>= 1;
                    return bit;
                }
                function tinf_read_bits(d, num, base) {
                    if (!num)
                        return base;
                    while (d.bitcount < 24) {
                        d.tag |= d.source[d.sourceIndex++] << d.bitcount;
                        d.bitcount += 8;
                    }
                    var val = d.tag & (0xffff >>> (16 - num));
                    d.tag >>>= num;
                    d.bitcount -= num;
                    return val + base;
                }
                function tinf_decode_symbol(d, t) {
                    while (d.bitcount < 24) {
                        d.tag |= d.source[d.sourceIndex++] << d.bitcount;
                        d.bitcount += 8;
                    }
                    var sum = 0, cur = 0, len = 0;
                    var tag = d.tag;
                    do {
                        cur = 2 * cur + (tag & 1);
                        tag >>>= 1;
                        ++len;
                        sum += t.table[len];
                        cur -= t.table[len];
                    } while (cur >= 0);
                    d.tag = tag;
                    d.bitcount -= len;
                    return t.trans[sum + cur];
                }
                function tinf_decode_trees(d, lt, dt) {
                    var hlit, hdist, hclen;
                    var i, num, length;
                    hlit = tinf_read_bits(d, 5, 257);
                    hdist = tinf_read_bits(d, 5, 1);
                    hclen = tinf_read_bits(d, 4, 4);
                    for (i = 0; i < 19; ++i)
                        lengths[i] = 0;
                    for (i = 0; i < hclen; ++i) {
                        var clen = tinf_read_bits(d, 3, 0);
                        lengths[clcidx[i]] = clen;
                    }
                    tinf_build_tree(code_tree, lengths, 0, 19);
                    for (num = 0; num < hlit + hdist;) {
                        var sym = tinf_decode_symbol(d, code_tree);
                        switch (sym) {
                            case 16:
                                var prev = lengths[num - 1];
                                for (length = tinf_read_bits(d, 2, 3); length; --length) {
                                    lengths[num++] = prev;
                                }
                                break;
                            case 17:
                                for (length = tinf_read_bits(d, 3, 3); length; --length) {
                                    lengths[num++] = 0;
                                }
                                break;
                            case 18:
                                for (length = tinf_read_bits(d, 7, 11); length; --length) {
                                    lengths[num++] = 0;
                                }
                                break;
                            default:
                                lengths[num++] = sym;
                                break;
                        }
                    }
                    tinf_build_tree(lt, lengths, 0, hlit);
                    tinf_build_tree(dt, lengths, hlit, hdist);
                }
                function tinf_inflate_block_data(d, lt, dt) {
                    while (1) {
                        var sym = tinf_decode_symbol(d, lt);
                        if (sym === 256) {
                            return TINF_OK;
                        }
                        if (sym < 256) {
                            d.dest[d.destLen++] = sym;
                        }
                        else {
                            var length, dist, offs;
                            var i;
                            sym -= 257;
                            length = tinf_read_bits(d, length_bits[sym], length_base[sym]);
                            dist = tinf_decode_symbol(d, dt);
                            offs = d.destLen - tinf_read_bits(d, dist_bits[dist], dist_base[dist]);
                            for (i = offs; i < offs + length; ++i) {
                                d.dest[d.destLen++] = d.dest[i];
                            }
                        }
                    }
                }
                function tinf_inflate_uncompressed_block(d) {
                    var length, invlength;
                    var i;
                    while (d.bitcount > 8) {
                        d.sourceIndex--;
                        d.bitcount -= 8;
                    }
                    length = d.source[d.sourceIndex + 1];
                    length = 256 * length + d.source[d.sourceIndex];
                    invlength = d.source[d.sourceIndex + 3];
                    invlength = 256 * invlength + d.source[d.sourceIndex + 2];
                    if (length !== (~invlength & 0x0000ffff))
                        return TINF_DATA_ERROR;
                    d.sourceIndex += 4;
                    for (i = length; i; --i)
                        d.dest[d.destLen++] = d.source[d.sourceIndex++];
                    d.bitcount = 0;
                    return TINF_OK;
                }
                function tinf_uncompress(source, dest) {
                    var d = new Data(source, dest);
                    var bfinal, btype, res;
                    do {
                        bfinal = tinf_getbit(d);
                        btype = tinf_read_bits(d, 2, 0);
                        switch (btype) {
                            case 0:
                                res = tinf_inflate_uncompressed_block(d);
                                break;
                            case 1:
                                res = tinf_inflate_block_data(d, sltree, sdtree);
                                break;
                            case 2:
                                tinf_decode_trees(d, d.ltree, d.dtree);
                                res = tinf_inflate_block_data(d, d.ltree, d.dtree);
                                break;
                            default:
                                res = TINF_DATA_ERROR;
                        }
                        if (res !== TINF_OK)
                            throw new Error('Data error');
                    } while (!bfinal);
                    if (d.destLen < d.dest.length) {
                        if (typeof d.dest.slice === 'function')
                            return d.dest.slice(0, d.destLen);
                        else
                            return d.dest.subarray(0, d.destLen);
                    }
                    return d.dest;
                }
                tinf_build_fixed_trees(sltree, sdtree);
                tinf_build_bits_base(length_bits, length_base, 4, 3);
                tinf_build_bits_base(dist_bits, dist_base, 2, 1);
                length_bits[28] = 0;
                length_base[28] = 258;
                localModule.localExports = tinf_uncompress;
            }, {}], 219: [function (localRequire, localModule, localExports) {
                localModule.localExports = { "categories": ["Cc", "Zs", "Po", "Sc", "Ps", "Pe", "Sm", "Pd", "Nd", "Lu", "Sk", "Pc", "Ll", "So", "Lo", "Pi", "Cf", "No", "Pf", "Lt", "Lm", "Mn", "Me", "Mc", "Nl", "Zl", "Zp", "Cs", "Co"], "combiningClasses": ["Not_Reordered", "Above", "Above_Right", "Below", "Attached_Above_Right", "Attached_Below", "Overlay", "Iota_Subscript", "Double_Below", "Double_Above", "Below_Right", "Above_Left", "CCC10", "CCC11", "CCC12", "CCC13", "CCC14", "CCC15", "CCC16", "CCC17", "CCC18", "CCC19", "CCC20", "CCC21", "CCC22", "CCC23", "CCC24", "CCC25", "CCC30", "CCC31", "CCC32", "CCC27", "CCC28", "CCC29", "CCC33", "CCC34", "CCC35", "CCC36", "Nukta", "Virama", "CCC84", "CCC91", "CCC103", "CCC107", "CCC118", "CCC122", "CCC129", "CCC130", "CCC132", "Attached_Above", "Below_Left", "Left", "Kana_Voicing", "CCC26", "Right"], "scripts": ["Common", "Latin", "Bopomofo", "Inherited", "Greek", "Coptic", "Cyrillic", "Armenian", "Hebrew", "Arabic", "Syriac", "Thaana", "Nko", "Samaritan", "Mandaic", "Devanagari", "Bengali", "Gurmukhi", "Gujarati", "Oriya", "Tamil", "Telugu", "Kannada", "Malayalam", "Sinhala", "Thai", "Lao", "Tibetan", "Myanmar", "Georgian", "Hangul", "Ethiopic", "Cherokee", "Canadian_Aboriginal", "Ogham", "Runic", "Tagalog", "Hanunoo", "Buhid", "Tagbanwa", "Khmer", "Mongolian", "Limbu", "Tai_Le", "New_Tai_Lue", "Buginese", "Tai_Tham", "Balinese", "Sundanese", "Batak", "Lepcha", "Ol_Chiki", "Braille", "Glagolitic", "Tifinagh", "Han", "Hiragana", "Katakana", "Yi", "Lisu", "Vai", "Bamum", "Syloti_Nagri", "Phags_Pa", "Saurashtra", "Kayah_Li", "Rejang", "Javanese", "Cham", "Tai_Viet", "Meetei_Mayek", "null", "Linear_B", "Lycian", "Carian", "Old_Italic", "Gothic", "Old_Permic", "Ugaritic", "Old_Persian", "Deseret", "Shavian", "Osmanya", "Elbasan", "Caucasian_Albanian", "Linear_A", "Cypriot", "Imperial_Aramaic", "Palmyrene", "Nabataean", "Hatran", "Phoenician", "Lydian", "Meroitic_Hieroglyphs", "Meroitic_Cursive", "Kharoshthi", "Old_South_Arabian", "Old_North_Arabian", "Manichaean", "Avestan", "Inscriptional_Parthian", "Inscriptional_Pahlavi", "Psalter_Pahlavi", "Old_Turkic", "Old_Hungarian", "Brahmi", "Kaithi", "Sora_Sompeng", "Chakma", "Mahajani", "Sharada", "Khojki", "Multani", "Khudawadi", "Grantha", "Tirhuta", "Siddham", "Modi", "Takri", "Ahom", "Warang_Citi", "Pau_Cin_Hau", "Cuneiform", "Egyptian_Hieroglyphs", "Anatolian_Hieroglyphs", "Mro", "Bassa_Vah", "Pahawh_Hmong", "Miao", "Duployan", "SignWriting", "Mende_Kikakui"], "eaw": ["N", "Na", "A", "W", "H", "F"] };
            }, {}], 220: [function (localRequire, localModule, localExports) {
                (function (Buffer) {
                    var CATEGORY_BITS, CATEGORY_MASK, CATEGORY_SHIFT, COMBINING_BITS, COMBINING_MASK, COMBINING_SHIFT, EAW_BITS, EAW_MASK, EAW_SHIFT, NUMBER_BITS, NUMBER_MASK, SCRIPT_BITS, SCRIPT_MASK, SCRIPT_SHIFT, UnicodeTrie, bits, data, fs, log2, trie;
                    UnicodeTrie = localRequire('unicode-trie');
                    data = localRequire('./data.json');
                    trie = new UnicodeTrie(Buffer("ABEAAAAAAAAAEKiQ5ZlpWFPX2vd73lPrafWIdQBlirUqKggKIqOkWhVxgGJFZIyCiMgQIUCAQNIjRxEZoqIiQogaBgcGAZkhEZFEQIiMAQKJECHGEEIImciwX2x7TrGnp+u9ng/vl2dfXNlJdvZa6/7t//rf91pMDqHfPNNQBgL8sjccSNRdbRc9uWHX5MnvbXfYXDWY/3CyInqFXvTkQJk/Lf3j549vpiQStB13g03WhrM3LLJscN7NU6x2ssNko8yCPlOg8t3zg2vP9u3mOyqelpehLkSEi6dXxAvXyXP/ue/lhrwz71bdPN6781lk/Pu1a7LueJwcHLCxrq2JjfkS65ywd73fimPmEV8d2npe19PWgS33ZXfjRgxDHDed1T6xK3qZs2mYoe9Fof+2P2uKQq/uVw2QP4czqqdwLsxrV+788+Ykn1sbusdp/9HvD8s6UP/Rc1jwug3rN32z8dvCe3kPCu7nc76nP3/18vWLNmpnU2tLR/Ph6QTJl8lXnA62vtqy+dHDoHM8+RuLBRHi2EjIZHcY5fP7UctXfJ1x7cb1H//JJiN40b90SOf9vkNDPqhD8YeVv7b0wzHXnjfdovuBp874nT0d4M99+25sYnSjXDH7Z0P6CB3+e6CzS1OPvDZhC72I2X3RvzVU/I+fIaXmXLxx9e7l2+lau//67UqLJcZ6douNdKy0zJrM7rkc3Hdk76EDzr8wpCXl/uN6ctalW2mExIyU7KTMtzq9Rn8e0HIeKJ5LoHhUL+ZAEvr6jyMuCpnUz/Eetm/4nPLQ4Zuvd3y5Za3Noo2rLf++zQAW98WBT9SFOEIE0SgB0ch8A6LBB9HY+KeC+0jjGJBGEJBGKpDGCSCNQiANBoDGtfcgGquB2rgKpLERSKMcSGM/iEbpYxAN9x4QDeDM18yxIS+2zvfMhWOZyk74D5v5yXL5nzal/gvbVvrWvfoLEJnLQDI/Asnkg8gw+kFkgB4SBdRJHVAnu4E6IYNosL8D0UA+BNGwmpOKBWw3cuCUHBASFRjSSmBIj4AhAW0RCbTFapAtTv/1v7ie5jlSnYCs+rWrPaf//ucRU4KUVts/6Uo5wXb+fUgqL+5V8nUcgTFI7qS/Q3A9qkrFGxWMWLyAr9qviTL0U9oSr+EIOgNkMpuLYPdUlwqZCoZsQsBXIjWS3VJxVOie6ai051aMv8Sjil9IK9VnbxNxQuJztHTA5a3YshCCpnAWeOhsvwbSTAaHGcZ3UOAI1OTbYEO14q7xYgRqlM7wtpLfpWPJE0VNjIZZsaVsKXkik1hqc2ba0kV19qycUByudLLXjJCZaGUYW1BIQZa0yE19mhkSfSYjaq2CIVk9f14xf142f14yf148f/58/vwZk+ENh+7SkQiUVBXsS07oaBSXKiRSy6ROykTr/EVr6K4wDIEaUgWz6hI6js5f5Eotaa8pE9fnL+6A7mrNXyTP31md0DEyU6oYlFouVpZoNDKfbfI9Gq2D8kRyFLw87beHhXvjooobscJ3/UufOAFmIPejvNijUYmwkIR/7oPLjaZaDA//9nzJGWq4If/jw6PkVg+UhLBPU0YEv6ol6SRfS9Ev3vury40lxSv5t8LcexF4y6ptI1Yy3CuXOZmUwMNtJUJpTQ6filErqmi+u1k7lcOw8y/dYd+7YHdXcnc+gydzo9n2zpBE3BR9Zq4OzjQtQsismOrCe0oDg1xchPr4lMxgRJqA1ZVCa8crqW+TFD4r/qvvqE7DsVAE9NF8Rvv3fpwAc824OX3cRBTql8lWh6z7/WyDv9jx9S8NQleEc/Qm9K0XZZk/C5ndYLTgxxCc3dyO/Sh4Hnr/J3PLHZvEiK7/eRRbcEOsUqLnE9b8JFKsnC0lNvEVYXAyUwnNW8NB4u4XMIVFCSyoZcF0YRelfZyaCqOyiRaOsZ4SPZPT7P/rJOY1gipT0u88FtuLVnM/FN6plP48cniGfvN5wscHwWAMCYkX/WPsuRvlXVj2v6csfI4pKx4umVfMLFozN6+Ynt8XrtmVX/8BcE1VKcWF+dFOxExygppRrZbTULgRHFlgBLE0r99G6Tchx9UbAcP3ApVeD4E5ZBfQcL2AhksAGq4vyHCFwKocDarKp+1AKfUhsA7tBNLQAdJ4AqRxFEgDmH5kwPSDAZVe54Da8AXSQAJp4IE03IE0gFW5DFSVTy8GleXngNr4B4iGZh2IBu4piAZ8H4gGDFiVa4Gq8ukkkG+8B2rjayCNg0AaN4E0PIE0SCAa+D4QDf8/DBa6Uyqur/qtJ5ru3wBIwoFIYoBILgKRuIKQEPNASFxAi5PpQtB0eQ+cLif/IFa4tDBeYxE7tbArTlHGtStyWgKD/hTruaGfeOM6zoh2LKbo11K3Fp4BU1rF0X63Cad65LAERHsnkHYdkPb3QNqPALRPAZ06ELgUrADStgFqzxtIIxdIAwGigQCl8VPALK4D3DJIAZpTC5DGCiAN4CqSAlxFIkBp/FQ3iIY7cDvJGKgNNyCN80AaaUAawM01BCiNnwLaEgO41agH1EYakMYmII0KIA3g5hoblMZPdYFoVAN9gwnUhgGQxn/8J+M/aGQCaXgBaYDS+ClgFpcBfUMJ1IYaSOMvIBrQPRAN3EEQDXgRiAawwsMDfcMRqA1/II1wII1/AmkcA9IAbbaeAlb/LkDfCARqowJIwwZIowFIYw+IBgW42QqsN8yAvpEJ1IYxkIYbkMZdIA0fII37IBrAegMJ9I1qoDaYQBoGQBolQBouQBqlIBrAegMG9A0toDYcgTT8gTSSQTSg4yAauAIQDWC9QQT6hhlQG5lAGsZAGpVAGgeANJ6AaADrDTbQN4RAbWgBaTgCaWQAaXiAaEAPQDSA9QYF6BtsoDaEQBpaQBqFQBqHgTSKATTWyQ2bZBsAQHYDwzUB7ieeAIULzwaFSwQmDfrCpNEB9bDUL63jWLF+RikmN9zCnHJ8kFUZR9e3WWQIOmLQmMRF69ctdrX425vvpPeGP3+3ro362aJJ/a1Wf7WpeVfb21WrOBsn2xswdBn1JLGswP7Vi+826QXfTGt8dX9gZnLfq7gvVlp/98WrPYoZRN9hbY8NfNgTTyKCQ+ImEGUKiGymIPeNfEi0TkW+dNWnVXPsutJ8VdudH8DgacQWM7/lxBZEC8LxUa6GtBZPWu0yFtSwVhCjLXxZ35UMuimMfOzbuyJrT9GGXGp2V3qgyLlBj2B9pVl+QL8lPN6OvHLkfYsWZ8OcqEfuoVr/hchD5aaKuintxu3khD8bc7JPsyIZ0McIMVa24cuTRGnWVzny6Hijuq4UGNVpllMoqpDvXzpWIX8i528WFELnqJxzLRkxusgDdrktdqKwyLF1yzh64au88OcdXjxR/A0uiwmjrHbZxHQx4mX3cMbPO0w8WNE3kObZS/oaUwa7JM3VThVjjREr0aftMyfOOMyHSJqtnumL1KGq4YRZKJJZ6Htl37eUApmaEwLPDYGlzug1465vZrpchjI77av+Xso8YDii26rHsktzrS28dYDc5n+MbPHI7jHF4jWMAUmNBjXW2N2mzNcGopD7RodnrLZkhm/brTmThyqw5Dp9k1B+CudR66fH0Zj1IztuJuwaxEZXUYLmznRE7+JxWy/OtH+AexzTxOdmykTvbtjklLLHxd79kFvP0QmKrU90UcWD1yppxaIo7VteJwI9sqJojVNy7Vtrbb235zbbNHPYW3oRDbtx20Jus4ajymNynvS/C3DO9Ige2eZVIVF6zSoak/n9FMQyYQ1l6lB+ZYNF95285gbqu5Oke3fg9erOvWk2+bWRohizqp5ca2FwLDHb+pwkzNfOFnU51nHJTFLdSv4EooDyPD7LjQM70h0QVRCbv1HRYiuoVXcnORmZhiDJ/Y4Kfdu2hO1Hkxgtrp18hcY6/YCCYJFvr1zW/prW9a5uDSzYeSg2+kTVHWeltXOcT3PNZEwZJZZmdcrNLmWOYEAv3+HgZSzYJPD9xsehoBCVYGIYDMfaOpWOFXoxBh9jv2m8GyjbsHuzRBxr3pu1RpCJtS4TiEbOxvXVMQ2rI9ckhrAde9a8y4i7JuzeT6XZyfqtL/snVGwnJibTOKkyTH63HmpCzNJcCK/1U+zXrrQ6z28WSRc7UXRgLSmbIa1WfDVHLV9HthK5NlyZge2fEFO3d9jE2PGUGYIgRLPg9Iibq0ODnbESmR66vHima1FzYf0JRdAe1JjovecaJCw1oNFU0gS75clOwWvOHUcPSGvYE3nFzcW6DmalXlUWctLw13TxyBrHwakD8KFBoT1cyZp850GRaG5IYnBn64e3VqM/0Sxqu+Xani5xcek3+zNQqNbdO8gU7WG7nmDSsEH2hFY7Ge4eNsz+guESnpqBsWIKUmVbL3d1Bu7HDFBlufie0FdxzyoMSZFdUuWlBoXASrvX63Z6p1eQuVCsqcY1+rhwWR9CT7WiOR82w8Y1yYeO+1udd8UfmGzB3kzvpvWP63p/UDvdpaeVJZ7TjtQx/c5KwLqaGnBgjnKt+lV87UZJJ43dUH561qLfKxNlYZmmyYOiprqO+liaxtNMhnKnXBpfVfjY0Nch7SmTNoE88Zt73pErkswetaoc4hwG4VvuIJL2849Nj8WehqYns1DT1JdHRo5SrRocHOnj43scdEgLSDzKQDcPk9x9Mrs7f5gbsVmrR+0cHS8oC4EKis9j4hrWtFNVGdyMhoyLrKKKXV8FHxuGZhUtGu39ZVMPLLPXco6wx7udMUZbXdNGHu7frVumo3R9CMW8f/YMpRLL7R2SETTkvnSD1HaTKyfmDOyyJmGmkWWsEE15HKPysUBRZsI0FGjRoc1Q3il7KIAfcZrgkIC9PxxQFtKQua/2lhh26yE1rPeBYdpAinpzTr0fLBMf6DC0BR5tPgj3DiIP10lK/NyYLZz2ttwOSy4uB33sTf0pUd2RNp1OXJngyUvFGrry6Lse3OyTT0KWNW2USer8J/PYzhN9Wa8rMmYybUqrY36OGWuSmW7zc1N30EiqIr6TkVfDzqqHzLx6UhTtVJsedG1GxcJxHSQknla72NrRYLRSzk6sIRF9magMprrOOdxNDb5jau6F3YUjlPcIFA37x29LKjbjDHS4GPMuO6ZvvOrdC43rqMrsfP0AdTUp/uYn8VqrT3FjlputVxuYiGJuml4Nm2B3WBdSY5My75pVOBP4NcnSQG68dZas14k3ppsDI7KFJTVQvR3bLIoyo77EjyybHH0dU8ClZH/SbE2kPic6vaczfMimpDO0kCKy7HKhqF/Xw7MwcE7t6/isqA/etE0CM2O7NKwDRIs1shCbejZsMuJGnciB/BrHAyZoQ3pZudXYTtzxB7r1rilxO/3MpP4FaU+o69TLzFlNZ14nPovKUpjze2u1OrmYmF3sMlZqeJaYI1YmzreAaWdIZoJPRcdzE4za5r94uM8ymqQtOffSd5LGS4nX0FLkZ64F/iSXnJrC4K4p4/vu3txq5E8SNGe7pmafF5eTd22p7qy5KmpfJFNFdhyI4x6gxS1pM3lq3ZZvr3Dc+LhMr/Kh47dSP7h2an5tUUd+V5s3rIo1HN0kTMCFdCmMd5PzOqZqNAwKPLhAfXZeY6sWwFlz28BjlWCWkeuN7Il005Tf6c8qrX+tEvkpM9MCTiDD6t9qUeDmJQw74/qQBm5CJI0HhzRFTnoZm/Gsa8YkxL9FxjYdNhInRB1Y9tVdxoUfDhqRWXrZPM6R2gzRwiE6TB1Ph4TyNJkxDdqs4cuRHAoe2uFgWGCDZQXuUDefHrpqdGn2zNj0seaTbhMlHY5cPAXxQWW+tTlWc+pGp2JcFpg249JZjUOtJ64koaxHENaXFwnMdvhSJO3sS6I72r74/Cx+dGvZ4JyOMHGUrbPNlk5Z4+hBT+KceWAV6OqrEolFZd4/fqvzAXYbHwEtHNuxqtqXdf4EOCvbLvrYdjZ1ffuQZy/DNi4/xd+3W8agUxua5givK3Hbu4vt6zMv7zjKJd1hd9jar8o/ZhGE3iR0GXjsENL1063LZZuRrpoHce7FOMSwTMRmiFGIfi65BNLpGLz7rlF6hPXNiYG1x9ONf7OQ8LkHEarYBk3QuLw4xoy8lp0GowUtjVD13Im93ahpWNZfvvMxvebvgXymR8iK4g/Z4X/77Hljf04N1ktw/ttlwoPGua/tNegb9LhD+RO97PfHlTgLsn5wr5ehow35UYskzh9XNUc/q0PKrrMiWe36gKtzfkIifnxfHrT0GPpHsYSqbLye5i+b3tiTbb0lxCyifC8yDHMJp4wvHzF53ymAG+JF1XRIdSSounHlAvWcjJYeg6wl+B//4CWzz6zSvOQ+b7fFSJiAHBs96V369lwvzpiDX5AdghXyns7R3d2Ni/1rPJ74MTle7UJcTaRpcbwmvKuuq7MurL0G8m1qzUlR6NAQJnYI3BhF9bS3MzBMKTPDwqvQWhPS7O/Hu9hypoE6mXp+Ka7vV++MMseH3qEG0PqTSTdxB6ssNRtdHdqiViwYfHjWoPAtyRv9ff42/tmw6k0yb6uPf28HFGpGR8KuXpfaTLrT7Fc8v+b33NrwKtV41Nn2jmx9SNB+lAQpGyPgjLML/ECZaY/zrcBSmQ370LyyoMivIEr/GIQLuz8m6tZylCz2KPUwCpdfULvQjVB3iO6l13DlzzdAbM37bimXDq3jwhdklOt1HYf1i4wYU+uIRqTILMuhrGRP5Hq6dmXzNpstqSTr3L0aIrQ5Vycd/+H24coGeP+M5mS70j/3hwe/2ko32UvWR4nPnd0Qt9JoUWOt/3XJWs/VxZ6oA3YJI2ZGxrMnNt9UZlbAU4LxE3Yk+zmKZ+8BXHChbdyL4jRs38/TuaSSO2Sjh6zNmHNNPj95YNuHriuNA/hjRuPVpPp9qLxnbVc3Y4VLcWHdvFLRiEUmYishlb/NVVfN9OFelkyIL4emDgWtxt/6yt8rAv4ue9rB1vMe3LY/YTpd+2Tp6wn+AMWvkVmmrpxfXmQpI7oq3r3gwKha1NiR1ZKqMzyuG69ZXLsUgnfkh0IYt+5MC58AJidjWQ/pVm7x0xrWztt9dnCsnZqdKXJhnrzN0qjcO5Bug8KiC9AHemcwtvFyFCtLH1N4qmdOh7/Nl5HC6AiQMOwgrkSHQIuiwdOpX3R6bTu68wBk2nbSnyqXXdfLR76sdkTq5ndJVVjxkUdPE3JlPfJBD1yFrs6HW1/xaucvB87QmELnVe0OhFRBq7dm6/zqIB6TGWSS5R7kpFk0PkrRZeiqva6QBkJvpge3PnHUhbNS1KezRPICqhhz7MMyvjCvc5aNZz3EBj3rGxkIsfd95DEQVuSKTWDgKwKneMo5VUUMrqmsWyuwg7u6HT0x5CEXJ/JfNr2cZvMNkVZfxXKVhFbNce5eX/9ncGa/PC626nlTFvWiA57eltozKm7LWCKhK5EdqcGawG8Je3FiDrbuu3AsYa+6MFDwjBoLYabSEC8pyfCORnGQCjmoqZDjHniaGkD8PJwxj46ahNIoje62Grp/YIxw9xbJJw4lO6R2dEIky8jHPmixNkvsnBAbfOqxxhIvHb5WI1HgkuFM/JKfEYFIQWyiDK8ZgXok2WmjlDJsV9MibjBmO5eny0wpsiW/H6pzqhAHHanSC04PHilDJHjzg1Z1Uy/6py0K0OnzuUkxQWriPPpZY8HBsbDMysYQZ34JPQBVb4IjSBk+2e3SUv4mJgLd0V+M85p6TFSG9nGdnuzE9mcXWCk8ogZlL2odecqujQkVvDhkhTAUQWdWdYSbXQ0tpRVwGnkDH2JMGzCOv4R0F33pY0TunMpzVORL9hXKWkQ6Xabd0M6ukGqT9Z52T3N3WiV0HhBGyU6FabWpAl9U0SrOxz8ZPo5zN3AsU0VNVMbY61DcrbZZIaR1Yh+ZfZFXYFRtBzHTNFtWbv5khsusS7as/5JpSC/n4wYtd9Srl+ei3elKBwmllcs6igtDBNqjJQki85onsewj8OLuSTqi/xAj4Qt9jeG+ALlyVZmXpwqDKxyXtIeqh8PCutBjkduqZaja89QfOtbczreypJKG/jK9qFLNxr3VnLt1aAnFvyQ7DOPLRPQoK7RlAfrPpaFKNX8Xix12/mhJ1Vmm2qZ9Z1WC71S79QQNdWtH8Y/ckrGzSkF/7u6THBHasOj0a01CUeAltRsOHUxWPYhLOQLpa2rC0HnfNlrx3jStQAV4NaIyGi7JYh55zIZXR8aTEbzhw6Rw99uvC6+xSw3IvaYp2GK9jsPt3p4QnchupaBRHkWPoXKYkMsaKVBQvkXn7tLRz2b7jncsYoolhcri7nH49569WHRH+BElDuWERXXTR2il5xejx0yVc+vrS7kw8sGprYa3lu0yhyFMLW+wTdakU7Jnn6qeeEKTQnKRc2FC0VbZ2dOY40gj9QJDTuLIE6Vah3BvFNuDzBxM1K0MqOVVTePU/yGJcjT7i6H5dJsZ5G9eWhHrjMOKHmJfbbtDhemrT71z5RHK4tBjFyI15Ls3mVbkqfrBXE9V+qxLBH4Y3TIgpdzX7HeTawZjj9uWzJdy/gIhKdTHwl2taQjNpkbBV2ryIp5aJiv4Bf+q8Yz1vF2sQuSBx5NwhTyJulvkJfKNtyDrwVkwPJ/dvgaKtk/HwTWJcjsRjIpbBYU3aM7zam7NpskPqc6q+qcdBifmzGqQQuZcKafaggpt0ITZJ1eX90NB3ezkUiobj1sObc+lwq9CJiyM5IsJSd9cs6VGNaCx9j0re6v5KR/rZvf5Z//l+MmCT2vSGaqir/xvv/ifHs+PellpnNTT2pHIRz4fv5h6MUnHL/P15O8z4odTojLPpevnL30eV9dlUnMCM06K+2RVFX6CW0BCxGkTFt8xvD1X7NsN095Ji+Wvub0tqnr71NTAGf2RnB9NB3j9yoUrJsdHSjTGv1ZHx8NAOPxgSpca4FXr4FnrsMvFzr1IVp43Uht18ozriGSIotI3YIkU1lZpClUKh+2byij0snZM0pnl/9j4IlpFpAfKdG7VhhutbEwelTal1srzjttqrLEGhaL5VV7E+1Njog0++omzyoigzpNr0zKSmzNftkripfGN2U+69Ldm6goIC8v8Gb4wjdWxGWbaZWJtf9jINSxA9UlWNQ7GVMfpGOQYjyvKbqHeOA8ye5jPnR6pB/H99dGbujrlUF5EDPdqV+sAnfBytFnSw82wyXnd8cQqExdhyi3KED99FB7ZThiGL2hVaFIDFQr0x+O9e1OmbvhbtDneaqCcmNF4Brn/u/wyKYKnkoqYaobX2Bk/kcY2vIwYRY2IkCpiP12ZkV4o4Lq54gd93JhL7SUZiRdHNa3vhmxtjHtC7S+4xHF5b/YgpQMZrJm4lrq0bGiwMz5Hxk6bOAhX8tvFF0ooZRnJEy+nY9DrFXwH2oYvapdp1z7iuPMwnrg+UZ8wV0aTG1TZcf1qSUdZek8MSk5XKIVVR4U81g3BhKrRZ4qrXKgM9WEWvEqk+vL/XYnT5gM75x6hvKbKS+vNYYlUs39pf/FUBfW/3lXzANG3LHbNY+N0oqalpaFt9xqZz2ZkmXDOO469rc455lRBmSD86aDiLv7Eo4regh0HCbFLSDmieOFiTuQ2F6vNXtsFwR5YkbxcsNpzeKXQu/3oSynjs5/cDuUbNbuEEBUMX1omxmAKE+JQSAu/cAK611t/2zF/YqOn6MyzRhPbYlYEYXyuuCwcjnRusNshkD3mtYjocdVv7XFrdNrJtQfg37sYBRBzbZBC0RHYk06or2QJeXMn59ws24xbZ/u7LUyzzCG7hZLbi3FZMl8Q1MxOOqdyu3Necwkx6JsazjGuc6oSZ8uDeINDuxwpnjtGwm7n9msxuk2iGKYY4lLa7tmKttH+Vf5uWdn2vqkitTQmYvfS0tbEiobTOyuIT053Nr2aCz9+4Yfzq/hTBmETW6NKPhQot1ahR6pK67BWbsSkwNM7l5z1K/zFO/81P4JqI+eXP+QfbbHGrBQkFc2hhesm6rv404rPORqlP9BTj4pirpuP5yFfMkXY+OXsFPxlGqfn5qDT3C35iNwz3ljjoToTYz9RcOFpm5FjvoZWtrIyRuiVjzVi4UsTgnPQc03WuOkm+UCKFpWWaaCcTQwfGS0jkFC3bHrmxL5Qf03Hg9PK4taBidU0C5Nshb5Wgi4lPf6Dobe7jSDePDS42TLXQk+HiTlXxlNVI+Ua27QTDjpTnjuGBnHvS1ba6KAVNpgyKBWXEm2LoVVaJ+CE8sZSgY8++7H1ITtG5Fxxo+axeeLprP1dHSIMTygxPblKfXPkcji7o3sdU9YaX1TSM7x2UmIcPudXCsUu9TWpPaFN1VRgSlCllVIt2DPp7SMPhllI4b7f1qvyYDU/tvn9GRPZ4HwnWZmtm8Kf4UYJ4Zz3BS4/ZXbsgkNhH8SyKhLRQXuLIaVoOMFNX6yKT2EmepmnNmFRgU9x3snnc8gDcI39F6L1DmnHeIeTqt+fOlc4m8/5eYUW7qnpFnFdz+cPVxVdIZygGvQNEB628PTWYpaODTFwdpyaLS1S7Y5CgojGY67FLX3Q6zTo9bTHCS4sJK7Zt1HZ1zkcF0XuNTHIV/mcXOXIo2T7M3spASgRO2G+C7zSRiuDYzf4iQw+xBuWQu8O05AtGFGHfMqlk85dRzs8iNxvZxu+auQ9bZ1v3hEbnp4ougEGeykbI42K5DsDom9gN2KtyNrsqzht+FpDPKLgyEYekipsYXC0OEQaTAtPg66HQ/VyaOzwFgg9hh6jXIG2arLlhc07tMqXJZpJOlM3/TiQi+8qw9lugewandQojnm7DMm8JFpGk8PxtPjRAQqGbPHK84BlNGd2f2fU0rGWFEsH9he1SSdqdxoasCoJ3SSOLNowIAx/N//EzNSAM9+V/L3huN0G/3NGwojFwTdrTyMEt4ZwF0bjBoPgbTJHqiaaaphY7chBmlY6R3az289Fp3fkpx+T7jpCH+wi/fwEnOGvalP2NFw5ZhWAbLs4wCuA5h05B2umnuew7xExzmq0/H0gIWVXKgE7sbxvIK0Hb560Jn72/Rwdl5hKaB853zAzOR6er0D7Grb7F84eYtkhWjFcY8UUbjzm2uz+yWdtsTRjrkFpjqw+giVso/1aruiNx7tn4hHQIcUnmxENN5+tFrx/6RpJgtsbwgqLXcZcOD1r/l4kaXOa3cQbPfwQbYkT2QehHinEzLiNXNGtHJp7hCGqhPTL3l4C55cvEK2xr6OWs1OFVDxn5xc2mvVtxe5DQRWEXcz/eGmk/r3K/jIqJLDEf37p/Blh1ezEkZkksQpxGRXqrL+6ilaiS0gdrfJZMe5ckrEg3aJNa53TNVih91wdIm5JjkkrPod7f7ROP8Bn4Y74I0bO/DLdohPzLSPGCrXGS1ibT4zSs0tuXjyVd6/68k1lCmzbucJY135pA2sw6tgU1zZlwcbFqiFCKGVn/K6H+u6/lZycZ942Gntf9iN9ymphixWnXsSxTtuTTrmSVsLeQ0WtDCsvbp+P4quvYm0KE3NKw7Go+xUxkgu1PNH+8RN9PgGkuXZ4pqeN5sK4Db8v4yLLD9pK98Mp4rtm24vdxTmz53MzfDtQ3U9ineMs6U6lEza8PnujxrvcvJ8vYnhzlT2agdZX1sLpY9woHSH7mVsoHT/evSNwGy12vpJ5IVXopjI9GtiadljH61jFUK5JK2Invpas2YN8lFV1Qh+xmjCrfjo/wtvWW/JS2gLtZO5GDGpsfYdr3fo2wjBuYXXhHQEZ5OOT+Hn3rDjxWKPDbQF2wdiblvA2T3auYgc9vTS7IUkwD3JvmXd3ERRT7/G0i65sG/GGFjbiG6GW9bCbrweyi5ixtiO+69hfq3GV03aYs+o5D8qCRyoz86DwqevEdUsqEqRfOW+KWzLDnTF1+OutxZ/8jMZLccfD8c96TKw33/LFVAUQQrdm+gYvtE24c3vpuJpf2YBrvC0rZcxoJJ4sim+7khEcC8VtEyJKfUZlfr7tFtM6zwO6OsM/1gFbDj/oxhYj/l2AGKdva2cnuwlMt1qMIKp9y4Y7hRvVjeO0FOX+HqneJWxBwuptd+kq/QLaVVTWbUWPfKemn8llwvEuYwiX7vv4JQHsuRHGnFA9NVN5R6W6F9u0qUzAXzGVUZ/uPPexUK8pDVuf3r3ss8/80V+PzH3z2fPD3G4u0T4w9HCQXFaI+DQe7dR6m3LB+0BD5oV+CBqqP5cYtTaveLEAJr3dbusdub3QLtD7bMdmrQj1gd/uwm0nY10QDdH2V1w49DE6p0JO8T2imZoOLaKHEsXBjuJrsXql7NbmSEFwoVVhfVnphFLUdVX4ipl6ohOm1XyUQDnKZ7+UoHw16+Ly++kPbOKdre+iGOGfNUT2p4XiUQSbEIw+evL9mbweISHLhgXpBAac9ZabZvXxZk0tQyk9H3x2uk+UdOAD+dz3ziO++vkJ6xm9WV6+4sEBaaXE3GutXX53+CdPLZ9D50gIvy2e0ntOFpZuFE2mR069SrjjwtuYTT8at8uDGHhJ0H1RsF/ZojrK/fHu4UyPqPiueN8qcUVI2uHDM1a74fmYncR2KiJVuYuYKYizgIl3wMRZd6k+rwU8gw5eOfZ1j32HGEtH3Ul/4L21UjzFKtnHGmHGopHckUYCWhb97cwUq7MeoyRnGldmL/7suY6zcKO0vDOKgKqbUlCKwsQX+S8f1Jq0IxhRpB77z7/aVNYTZLjAJUi9NpPbKp2ftSVZaI+PFPjhegRjA7vW0gPEWUhMl61Ju9fNMFtN1JDXcVwGqiKMkO3JfJIr3M9veExkTkK2XVvhBrVx+vbbtRJUZvVHOZvm6sL0mEWUPvEPYTfTk6IXeBzcxF03O+jedXLVaVtaqIRCUPjalzINGWdRAxumJhxij+O7B9z8PGXf1HyQM7KgPn8mMeP5SEzgP0LxX/7EdKtb7B+TRf1yeyShJgzHMGivYqRnVwaFYBrMSEfH6kKRmBKmbzu/qkKgGOlTCeO80asZBvwqbtVIpcpNsPx/vnD8/3jsKncOwaT+7svn7UEZA9KToymv1Iv/8K4L9VWrmblWWkOa3Wv++pnWqxD9UE5X4RsrZsQPH/6i1RvF+ZNVxf+K49QZXabhH7P733JcwJkkQ7D/Cw==", "base64"));
                    log2 = Math.log2 || function (n) {
                        return Math.log(n) / Math.LN2;
                    };
                    bits = function (n) {
                        return (log2(n) + 1) | 0;
                    };
                    CATEGORY_BITS = bits(data.categories.length - 1);
                    COMBINING_BITS = bits(data.combiningClasses.length - 1);
                    SCRIPT_BITS = bits(data.scripts.length - 1);
                    EAW_BITS = bits(data.eaw.length - 1);
                    NUMBER_BITS = 10;
                    CATEGORY_SHIFT = COMBINING_BITS + SCRIPT_BITS + EAW_BITS + NUMBER_BITS;
                    COMBINING_SHIFT = SCRIPT_BITS + EAW_BITS + NUMBER_BITS;
                    SCRIPT_SHIFT = EAW_BITS + NUMBER_BITS;
                    EAW_SHIFT = NUMBER_BITS;
                    CATEGORY_MASK = (1 << CATEGORY_BITS) - 1;
                    COMBINING_MASK = (1 << COMBINING_BITS) - 1;
                    SCRIPT_MASK = (1 << SCRIPT_BITS) - 1;
                    EAW_MASK = (1 << EAW_BITS) - 1;
                    NUMBER_MASK = (1 << NUMBER_BITS) - 1;
                    localExports.getCategory = function (codePoint) {
                        var val;
                        val = trie.get(codePoint);
                        return data.categories[(val >> CATEGORY_SHIFT) & CATEGORY_MASK];
                    };
                    localExports.getCombiningClass = function (codePoint) {
                        var val;
                        val = trie.get(codePoint);
                        return data.combiningClasses[(val >> COMBINING_SHIFT) & COMBINING_MASK];
                    };
                    localExports.getScript = function (codePoint) {
                        var val;
                        val = trie.get(codePoint);
                        return data.scripts[(val >> SCRIPT_SHIFT) & SCRIPT_MASK];
                    };
                    localExports.getEastAsianWidth = function (codePoint) {
                        var val;
                        val = trie.get(codePoint);
                        return data.eaw[(val >> EAW_SHIFT) & EAW_MASK];
                    };
                    localExports.getNumericValue = function (codePoint) {
                        var denominator, exp, num, numerator, val;
                        val = trie.get(codePoint);
                        num = val & NUMBER_MASK;
                        if (num === 0) {
                            return null;
                        }
                        else if (num <= 50) {
                            return num - 1;
                        }
                        else if (num < 0x1e0) {
                            numerator = (num >> 4) - 12;
                            denominator = (num & 0xf) + 1;
                            return numerator / denominator;
                        }
                        else if (num < 0x300) {
                            val = (num >> 5) - 14;
                            exp = (num & 0x1f) + 2;
                            while (exp > 0) {
                                val *= 10;
                                exp--;
                            }
                            return val;
                        }
                        else {
                            val = (num >> 2) - 0xbf;
                            exp = (num & 3) + 1;
                            while (exp > 0) {
                                val *= 60;
                                exp--;
                            }
                            return val;
                        }
                    };
                    localExports.isAlphabetic = function (codePoint) {
                        var ref;
                        return (ref = localExports.getCategory(codePoint)) === 'Lu' || ref === 'Ll' || ref === 'Lt' || ref === 'Lm' || ref === 'Lo' || ref === 'Nl';
                    };
                    localExports.isDigit = function (codePoint) {
                        return localExports.getCategory(codePoint) === 'Nd';
                    };
                    localExports.isPunctuation = function (codePoint) {
                        var ref;
                        return (ref = localExports.getCategory(codePoint)) === 'Pc' || ref === 'Pd' || ref === 'Pe' || ref === 'Pf' || ref === 'Pi' || ref === 'Po' || ref === 'Ps';
                    };
                    localExports.isLowerCase = function (codePoint) {
                        return localExports.getCategory(codePoint) === 'Ll';
                    };
                    localExports.isUpperCase = function (codePoint) {
                        return localExports.getCategory(codePoint) === 'Lu';
                    };
                    localExports.isTitleCase = function (codePoint) {
                        return localExports.getCategory(codePoint) === 'Lt';
                    };
                    localExports.isWhiteSpace = function (codePoint) {
                        var ref;
                        return (ref = localExports.getCategory(codePoint)) === 'Zs' || ref === 'Zl' || ref === 'Zp';
                    };
                    localExports.isBaseForm = function (codePoint) {
                        var ref;
                        return (ref = localExports.getCategory(codePoint)) === 'Nd' || ref === 'No' || ref === 'Nl' || ref === 'Lu' || ref === 'Ll' || ref === 'Lt' || ref === 'Lm' || ref === 'Lo' || ref === 'Me' || ref === 'Mc';
                    };
                    localExports.isMark = function (codePoint) {
                        var ref;
                        return (ref = localExports.getCategory(codePoint)) === 'Mn' || ref === 'Me' || ref === 'Mc';
                    };
                }).call(this, localRequire("buffer").Buffer);
            }, { "./data.json": 219, "buffer": 60, "unicode-trie": 221 }], 221: [function (localRequire, localModule, localExports) {
                var UnicodeTrie, inflate;
                inflate = localRequire('tiny-inflate');
                UnicodeTrie = (function () {
                    var DATA_BLOCK_LENGTH, DATA_GRANULARITY, DATA_MASK, INDEX_1_OFFSET, INDEX_2_BLOCK_LENGTH, INDEX_2_BMP_LENGTH, INDEX_2_MASK, INDEX_SHIFT, LSCP_INDEX_2_LENGTH, LSCP_INDEX_2_OFFSET, OMITTED_BMP_INDEX_1_LENGTH, SHIFT_1, SHIFT_1_2, SHIFT_2, UTF8_2B_INDEX_2_LENGTH, UTF8_2B_INDEX_2_OFFSET;
                    SHIFT_1 = 6 + 5;
                    SHIFT_2 = 5;
                    SHIFT_1_2 = SHIFT_1 - SHIFT_2;
                    OMITTED_BMP_INDEX_1_LENGTH = 0x10000 >> SHIFT_1;
                    INDEX_2_BLOCK_LENGTH = 1 << SHIFT_1_2;
                    INDEX_2_MASK = INDEX_2_BLOCK_LENGTH - 1;
                    INDEX_SHIFT = 2;
                    DATA_BLOCK_LENGTH = 1 << SHIFT_2;
                    DATA_MASK = DATA_BLOCK_LENGTH - 1;
                    LSCP_INDEX_2_OFFSET = 0x10000 >> SHIFT_2;
                    LSCP_INDEX_2_LENGTH = 0x400 >> SHIFT_2;
                    INDEX_2_BMP_LENGTH = LSCP_INDEX_2_OFFSET + LSCP_INDEX_2_LENGTH;
                    UTF8_2B_INDEX_2_OFFSET = INDEX_2_BMP_LENGTH;
                    UTF8_2B_INDEX_2_LENGTH = 0x800 >> 6;
                    INDEX_1_OFFSET = UTF8_2B_INDEX_2_OFFSET + UTF8_2B_INDEX_2_LENGTH;
                    DATA_GRANULARITY = 1 << INDEX_SHIFT;
                    function UnicodeTrie(data) {
                        var isBuffer, uncompressedLength, view;
                        isBuffer = typeof data.readUInt32BE === 'function' && typeof data.slice === 'function';
                        if (isBuffer || data instanceof Uint8Array) {
                            if (isBuffer) {
                                this.highStart = data.readUInt32BE(0);
                                this.errorValue = data.readUInt32BE(4);
                                uncompressedLength = data.readUInt32BE(8);
                                data = data.slice(12);
                            }
                            else {
                                view = new DataView(data.buffer);
                                this.highStart = view.getUint32(0);
                                this.errorValue = view.getUint32(4);
                                uncompressedLength = view.getUint32(8);
                                data = data.subarray(12);
                            }
                            data = inflate(data, new Uint8Array(uncompressedLength));
                            data = inflate(data, new Uint8Array(uncompressedLength));
                            this.data = new Uint32Array(data.buffer);
                        }
                        else {
                            this.data = data.data, this.highStart = data.highStart, this.errorValue = data.errorValue;
                        }
                    }
                    UnicodeTrie.prototype.get = function (codePoint) {
                        var index;
                        if (codePoint < 0 || codePoint > 0x10ffff) {
                            return this.errorValue;
                        }
                        if (codePoint < 0xd800 || (codePoint > 0xdbff && codePoint <= 0xffff)) {
                            index = (this.data[codePoint >> SHIFT_2] << INDEX_SHIFT) + (codePoint & DATA_MASK);
                            return this.data[index];
                        }
                        if (codePoint <= 0xffff) {
                            index = (this.data[LSCP_INDEX_2_OFFSET + ((codePoint - 0xd800) >> SHIFT_2)] << INDEX_SHIFT) + (codePoint & DATA_MASK);
                            return this.data[index];
                        }
                        if (codePoint < this.highStart) {
                            index = this.data[(INDEX_1_OFFSET - OMITTED_BMP_INDEX_1_LENGTH) + (codePoint >> SHIFT_1)];
                            index = this.data[index + ((codePoint >> SHIFT_2) & INDEX_2_MASK)];
                            index = (index << INDEX_SHIFT) + (codePoint & DATA_MASK);
                            return this.data[index];
                        }
                        return this.data[this.data.length - DATA_GRANULARITY];
                    };
                    return UnicodeTrie;
                })();
                localModule.localExports = UnicodeTrie;
            }, { "tiny-inflate": 218 }], 222: [function (localRequire, localModule, localExports) {
                (function (global) {
                    localModule.localExports = deprecate;
                    function deprecate(fn, msg) {
                        if (config('noDeprecation')) {
                            return fn;
                        }
                        var warned = false;
                        function deprecated() {
                            if (!warned) {
                                if (config('throwDeprecation')) {
                                    throw new Error(msg);
                                }
                                else if (config('traceDeprecation')) {
                                    console.trace(msg);
                                }
                                else {
                                    console.warn(msg);
                                }
                                warned = true;
                            }
                            return fn.apply(this, arguments);
                        }
                        return deprecated;
                    }
                    function config(name) {
                        try {
                            if (!global.localStorage)
                                return false;
                        }
                        catch (_) {
                            return false;
                        }
                        var val = global.localStorage[name];
                        if (null == val)
                            return false;
                        return String(val).toLowerCase() === 'true';
                    }
                }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
            }, {}], 223: [function (localRequire, localModule, localExports) {
                localModule.localExports = function isBuffer(arg) {
                    return arg && typeof arg === 'object'
                        && typeof arg.copy === 'function'
                        && typeof arg.fill === 'function'
                        && typeof arg.readUInt8 === 'function';
                };
            }, {}], 224: [function (localRequire, localModule, localExports) {
                (function (process, global) {
                    var formatRegExp = /%[sdj%]/g;
                    localExports.format = function (f) {
                        if (!isString(f)) {
                            var objects = [];
                            for (var i = 0; i < arguments.length; i++) {
                                objects.push(inspect(arguments[i]));
                            }
                            return objects.join(' ');
                        }
                        var i = 1;
                        var args = arguments;
                        var len = args.length;
                        var str = String(f).replace(formatRegExp, function (x) {
                            if (x === '%%')
                                return '%';
                            if (i >= len)
                                return x;
                            switch (x) {
                                case '%s': return String(args[i++]);
                                case '%d': return Number(args[i++]);
                                case '%j':
                                    try {
                                        return JSON.stringify(args[i++]);
                                    }
                                    catch (_) {
                                        return '[Circular]';
                                    }
                                default:
                                    return x;
                            }
                        });
                        for (var x = args[i]; i < len; x = args[++i]) {
                            if (isNull(x) || !isObject(x)) {
                                str += ' ' + x;
                            }
                            else {
                                str += ' ' + inspect(x);
                            }
                        }
                        return str;
                    };
                    localExports.deprecate = function (fn, msg) {
                        if (isUndefined(global.process)) {
                            return function () {
                                return localExports.deprecate(fn, msg).apply(this, arguments);
                            };
                        }
                        if (process.noDeprecation === true) {
                            return fn;
                        }
                        var warned = false;
                        function deprecated() {
                            if (!warned) {
                                if (process.throwDeprecation) {
                                    throw new Error(msg);
                                }
                                else if (process.traceDeprecation) {
                                    console.trace(msg);
                                }
                                else {
                                    console.error(msg);
                                }
                                warned = true;
                            }
                            return fn.apply(this, arguments);
                        }
                        return deprecated;
                    };
                    var debugs = {};
                    var debugEnviron;
                    localExports.debuglog = function (set) {
                        if (isUndefined(debugEnviron))
                            debugEnviron = process.env.NODE_DEBUG || '';
                        set = set.toUpperCase();
                        if (!debugs[set]) {
                            if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
                                var pid = process.pid;
                                debugs[set] = function () {
                                    var msg = localExports.format.apply(localExports, arguments);
                                    console.error('%s %d: %s', set, pid, msg);
                                };
                            }
                            else {
                                debugs[set] = function () { };
                            }
                        }
                        return debugs[set];
                    };
                    function inspect(obj, opts) {
                        var ctx = {
                            seen: [],
                            stylize: stylizeNoColor
                        };
                        if (arguments.length >= 3)
                            ctx.depth = arguments[2];
                        if (arguments.length >= 4)
                            ctx.colors = arguments[3];
                        if (isBoolean(opts)) {
                            ctx.showHidden = opts;
                        }
                        else if (opts) {
                            localExports._extend(ctx, opts);
                        }
                        if (isUndefined(ctx.showHidden))
                            ctx.showHidden = false;
                        if (isUndefined(ctx.depth))
                            ctx.depth = 2;
                        if (isUndefined(ctx.colors))
                            ctx.colors = false;
                        if (isUndefined(ctx.customInspect))
                            ctx.customInspect = true;
                        if (ctx.colors)
                            ctx.stylize = stylizeWithColor;
                        return formatValue(ctx, obj, ctx.depth);
                    }
                    localExports.inspect = inspect;
                    inspect.colors = {
                        'bold': [1, 22],
                        'italic': [3, 23],
                        'underline': [4, 24],
                        'inverse': [7, 27],
                        'white': [37, 39],
                        'grey': [90, 39],
                        'black': [30, 39],
                        'blue': [34, 39],
                        'cyan': [36, 39],
                        'green': [32, 39],
                        'magenta': [35, 39],
                        'red': [31, 39],
                        'yellow': [33, 39]
                    };
                    inspect.styles = {
                        'special': 'cyan',
                        'number': 'yellow',
                        'boolean': 'yellow',
                        'undefined': 'grey',
                        'null': 'bold',
                        'string': 'green',
                        'date': 'magenta',
                        'regexp': 'red'
                    };
                    function stylizeWithColor(str, styleType) {
                        var style = inspect.styles[styleType];
                        if (style) {
                            return '\u001b[' + inspect.colors[style][0] + 'm' + str +
                                '\u001b[' + inspect.colors[style][1] + 'm';
                        }
                        else {
                            return str;
                        }
                    }
                    function stylizeNoColor(str, styleType) {
                        return str;
                    }
                    function arrayToHash(array) {
                        var hash = {};
                        array.forEach(function (val, idx) {
                            hash[val] = true;
                        });
                        return hash;
                    }
                    function formatValue(ctx, value, recurseTimes) {
                        if (ctx.customInspect &&
                            value &&
                            isFunction(value.inspect) &&
                            value.inspect !== localExports.inspect &&
                            !(value.constructor && value.constructor.prototype === value)) {
                            var ret = value.inspect(recurseTimes, ctx);
                            if (!isString(ret)) {
                                ret = formatValue(ctx, ret, recurseTimes);
                            }
                            return ret;
                        }
                        var primitive = formatPrimitive(ctx, value);
                        if (primitive) {
                            return primitive;
                        }
                        var keys = Object.keys(value);
                        var visibleKeys = arrayToHash(keys);
                        if (ctx.showHidden) {
                            keys = Object.getOwnPropertyNames(value);
                        }
                        if (isError(value)
                            && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
                            return formatError(value);
                        }
                        if (keys.length === 0) {
                            if (isFunction(value)) {
                                var name = value.name ? ': ' + value.name : '';
                                return ctx.stylize('[Function' + name + ']', 'special');
                            }
                            if (isRegExp(value)) {
                                return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
                            }
                            if (isDate(value)) {
                                return ctx.stylize(Date.prototype.toString.call(value), 'date');
                            }
                            if (isError(value)) {
                                return formatError(value);
                            }
                        }
                        var base = '', array = false, braces = ['{', '}'];
                        if (isArray(value)) {
                            array = true;
                            braces = ['[', ']'];
                        }
                        if (isFunction(value)) {
                            var n = value.name ? ': ' + value.name : '';
                            base = ' [Function' + n + ']';
                        }
                        if (isRegExp(value)) {
                            base = ' ' + RegExp.prototype.toString.call(value);
                        }
                        if (isDate(value)) {
                            base = ' ' + Date.prototype.toUTCString.call(value);
                        }
                        if (isError(value)) {
                            base = ' ' + formatError(value);
                        }
                        if (keys.length === 0 && (!array || value.length == 0)) {
                            return braces[0] + base + braces[1];
                        }
                        if (recurseTimes < 0) {
                            if (isRegExp(value)) {
                                return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
                            }
                            else {
                                return ctx.stylize('[Object]', 'special');
                            }
                        }
                        ctx.seen.push(value);
                        var output;
                        if (array) {
                            output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
                        }
                        else {
                            output = keys.map(function (key) {
                                return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
                            });
                        }
                        ctx.seen.pop();
                        return reduceToSingleString(output, base, braces);
                    }
                    function formatPrimitive(ctx, value) {
                        if (isUndefined(value))
                            return ctx.stylize('undefined', 'undefined');
                        if (isString(value)) {
                            var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                .replace(/'/g, "\\'")
                                .replace(/\\"/g, '"') + '\'';
                            return ctx.stylize(simple, 'string');
                        }
                        if (isNumber(value))
                            return ctx.stylize('' + value, 'number');
                        if (isBoolean(value))
                            return ctx.stylize('' + value, 'boolean');
                        if (isNull(value))
                            return ctx.stylize('null', 'null');
                    }
                    function formatError(value) {
                        return '[' + Error.prototype.toString.call(value) + ']';
                    }
                    function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
                        var output = [];
                        for (var i = 0, l = value.length; i < l; ++i) {
                            if (hasOwnProperty(value, String(i))) {
                                output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
                            }
                            else {
                                output.push('');
                            }
                        }
                        keys.forEach(function (key) {
                            if (!key.match(/^\d+$/)) {
                                output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
                            }
                        });
                        return output;
                    }
                    function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
                        var name, str, desc;
                        desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
                        if (desc.get) {
                            if (desc.set) {
                                str = ctx.stylize('[Getter/Setter]', 'special');
                            }
                            else {
                                str = ctx.stylize('[Getter]', 'special');
                            }
                        }
                        else {
                            if (desc.set) {
                                str = ctx.stylize('[Setter]', 'special');
                            }
                        }
                        if (!hasOwnProperty(visibleKeys, key)) {
                            name = '[' + key + ']';
                        }
                        if (!str) {
                            if (ctx.seen.indexOf(desc.value) < 0) {
                                if (isNull(recurseTimes)) {
                                    str = formatValue(ctx, desc.value, null);
                                }
                                else {
                                    str = formatValue(ctx, desc.value, recurseTimes - 1);
                                }
                                if (str.indexOf('\n') > -1) {
                                    if (array) {
                                        str = str.split('\n').map(function (line) {
                                            return '  ' + line;
                                        }).join('\n').substr(2);
                                    }
                                    else {
                                        str = '\n' + str.split('\n').map(function (line) {
                                            return '   ' + line;
                                        }).join('\n');
                                    }
                                }
                            }
                            else {
                                str = ctx.stylize('[Circular]', 'special');
                            }
                        }
                        if (isUndefined(name)) {
                            if (array && key.match(/^\d+$/)) {
                                return str;
                            }
                            name = JSON.stringify('' + key);
                            if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
                                name = name.substr(1, name.length - 2);
                                name = ctx.stylize(name, 'name');
                            }
                            else {
                                name = name.replace(/'/g, "\\'")
                                    .replace(/\\"/g, '"')
                                    .replace(/(^"|"$)/g, "'");
                                name = ctx.stylize(name, 'string');
                            }
                        }
                        return name + ': ' + str;
                    }
                    function reduceToSingleString(output, base, braces) {
                        var numLinesEst = 0;
                        var length = output.reduce(function (prev, cur) {
                            numLinesEst++;
                            if (cur.indexOf('\n') >= 0)
                                numLinesEst++;
                            return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
                        }, 0);
                        if (length > 60) {
                            return braces[0] +
                                (base === '' ? '' : base + '\n ') +
                                ' ' +
                                output.join(',\n  ') +
                                ' ' +
                                braces[1];
                        }
                        return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
                    }
                    function isArray(ar) {
                        return Array.isArray(ar);
                    }
                    localExports.isArray = isArray;
                    function isBoolean(arg) {
                        return typeof arg === 'boolean';
                    }
                    localExports.isBoolean = isBoolean;
                    function isNull(arg) {
                        return arg === null;
                    }
                    localExports.isNull = isNull;
                    function isNullOrUndefined(arg) {
                        return arg == null;
                    }
                    localExports.isNullOrUndefined = isNullOrUndefined;
                    function isNumber(arg) {
                        return typeof arg === 'number';
                    }
                    localExports.isNumber = isNumber;
                    function isString(arg) {
                        return typeof arg === 'string';
                    }
                    localExports.isString = isString;
                    function isSymbol(arg) {
                        return typeof arg === 'symbol';
                    }
                    localExports.isSymbol = isSymbol;
                    function isUndefined(arg) {
                        return arg === void 0;
                    }
                    localExports.isUndefined = isUndefined;
                    function isRegExp(re) {
                        return isObject(re) && objectToString(re) === '[object RegExp]';
                    }
                    localExports.isRegExp = isRegExp;
                    function isObject(arg) {
                        return typeof arg === 'object' && arg !== null;
                    }
                    localExports.isObject = isObject;
                    function isDate(d) {
                        return isObject(d) && objectToString(d) === '[object Date]';
                    }
                    localExports.isDate = isDate;
                    function isError(e) {
                        return isObject(e) &&
                            (objectToString(e) === '[object Error]' || e instanceof Error);
                    }
                    localExports.isError = isError;
                    function isFunction(arg) {
                        return typeof arg === 'function';
                    }
                    localExports.isFunction = isFunction;
                    function isPrimitive(arg) {
                        return arg === null ||
                            typeof arg === 'boolean' ||
                            typeof arg === 'number' ||
                            typeof arg === 'string' ||
                            typeof arg === 'symbol' ||
                            typeof arg === 'undefined';
                    }
                    localExports.isPrimitive = isPrimitive;
                    localExports.isBuffer = localRequire('./support/isBuffer');
                    function objectToString(o) {
                        return Object.prototype.toString.call(o);
                    }
                    function pad(n) {
                        return n < 10 ? '0' + n.toString(10) : n.toString(10);
                    }
                    var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
                        'Oct', 'Nov', 'Dec'];
                    function timestamp() {
                        var d = new Date();
                        var time = [pad(d.getHours()),
                            pad(d.getMinutes()),
                            pad(d.getSeconds())].join(':');
                        return [d.getDate(), months[d.getMonth()], time].join(' ');
                    }
                    localExports.log = function () {
                        console.log('%s - %s', timestamp(), localExports.format.apply(localExports, arguments));
                    };
                    localExports.inherits = localRequire('inherits');
                    localExports._extend = function (origin, add) {
                        if (!add || !isObject(add))
                            return origin;
                        var keys = Object.keys(add);
                        var i = keys.length;
                        while (i--) {
                            origin[keys[i]] = add[keys[i]];
                        }
                        return origin;
                    };
                    function hasOwnProperty(obj, prop) {
                        return Object.prototype.hasOwnProperty.call(obj, prop);
                    }
                }).call(this, localRequire('_process'), typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
            }, { "./support/isBuffer": 223, "_process": 188, "inherits": 167 }]
    }, {}, [2])(2);
});
'use strict';
var PdfLineCapStyle;
(function (PdfLineCapStyle) {
    PdfLineCapStyle[PdfLineCapStyle["Butt"] = 0] = "Butt";
    PdfLineCapStyle[PdfLineCapStyle["Round"] = 1] = "Round";
    PdfLineCapStyle[PdfLineCapStyle["Square"] = 2] = "Square";
})(PdfLineCapStyle = exports.PdfLineCapStyle || (exports.PdfLineCapStyle = {}));
var PdfLineJoinStyle;
(function (PdfLineJoinStyle) {
    PdfLineJoinStyle[PdfLineJoinStyle["Miter"] = 0] = "Miter";
    PdfLineJoinStyle[PdfLineJoinStyle["Round"] = 1] = "Round";
    PdfLineJoinStyle[PdfLineJoinStyle["Bevel"] = 2] = "Bevel";
})(PdfLineJoinStyle = exports.PdfLineJoinStyle || (exports.PdfLineJoinStyle = {}));
var PdfFillRule;
(function (PdfFillRule) {
    PdfFillRule[PdfFillRule["NonZero"] = 0] = "NonZero";
    PdfFillRule[PdfFillRule["EvenOdd"] = 1] = "EvenOdd";
})(PdfFillRule = exports.PdfFillRule || (exports.PdfFillRule = {}));
var PdfPageOrientation;
(function (PdfPageOrientation) {
    PdfPageOrientation[PdfPageOrientation["Portrait"] = 0] = "Portrait";
    PdfPageOrientation[PdfPageOrientation["Landscape"] = 1] = "Landscape";
})(PdfPageOrientation = exports.PdfPageOrientation || (exports.PdfPageOrientation = {}));
var PdfImageHorizontalAlign;
(function (PdfImageHorizontalAlign) {
    PdfImageHorizontalAlign[PdfImageHorizontalAlign["Left"] = 0] = "Left";
    PdfImageHorizontalAlign[PdfImageHorizontalAlign["Center"] = 1] = "Center";
    PdfImageHorizontalAlign[PdfImageHorizontalAlign["Right"] = 2] = "Right";
})(PdfImageHorizontalAlign = exports.PdfImageHorizontalAlign || (exports.PdfImageHorizontalAlign = {}));
var PdfImageVerticalAlign;
(function (PdfImageVerticalAlign) {
    PdfImageVerticalAlign[PdfImageVerticalAlign["Top"] = 0] = "Top";
    PdfImageVerticalAlign[PdfImageVerticalAlign["Center"] = 1] = "Center";
    PdfImageVerticalAlign[PdfImageVerticalAlign["Bottom"] = 2] = "Bottom";
})(PdfImageVerticalAlign = exports.PdfImageVerticalAlign || (exports.PdfImageVerticalAlign = {}));
var PdfTextHorizontalAlign;
(function (PdfTextHorizontalAlign) {
    PdfTextHorizontalAlign[PdfTextHorizontalAlign["Left"] = 0] = "Left";
    PdfTextHorizontalAlign[PdfTextHorizontalAlign["Center"] = 1] = "Center";
    PdfTextHorizontalAlign[PdfTextHorizontalAlign["Right"] = 2] = "Right";
    PdfTextHorizontalAlign[PdfTextHorizontalAlign["Justify"] = 3] = "Justify";
})(PdfTextHorizontalAlign = exports.PdfTextHorizontalAlign || (exports.PdfTextHorizontalAlign = {}));
var _PdfTextBaseline;
(function (_PdfTextBaseline) {
    _PdfTextBaseline[_PdfTextBaseline["Top"] = 0] = "Top";
    _PdfTextBaseline[_PdfTextBaseline["Alphabetic"] = 1] = "Alphabetic";
})(_PdfTextBaseline = exports._PdfTextBaseline || (exports._PdfTextBaseline = {}));
var PdfPageSize;
(function (PdfPageSize) {
    PdfPageSize[PdfPageSize["A0"] = 0] = "A0";
    PdfPageSize[PdfPageSize["A1"] = 1] = "A1";
    PdfPageSize[PdfPageSize["A2"] = 2] = "A2";
    PdfPageSize[PdfPageSize["A3"] = 3] = "A3";
    PdfPageSize[PdfPageSize["A4"] = 4] = "A4";
    PdfPageSize[PdfPageSize["A5"] = 5] = "A5";
    PdfPageSize[PdfPageSize["A6"] = 6] = "A6";
    PdfPageSize[PdfPageSize["A7"] = 7] = "A7";
    PdfPageSize[PdfPageSize["A8"] = 8] = "A8";
    PdfPageSize[PdfPageSize["A9"] = 9] = "A9";
    PdfPageSize[PdfPageSize["A10"] = 10] = "A10";
    PdfPageSize[PdfPageSize["B0"] = 11] = "B0";
    PdfPageSize[PdfPageSize["B1"] = 12] = "B1";
    PdfPageSize[PdfPageSize["B2"] = 13] = "B2";
    PdfPageSize[PdfPageSize["B3"] = 14] = "B3";
    PdfPageSize[PdfPageSize["B4"] = 15] = "B4";
    PdfPageSize[PdfPageSize["B5"] = 16] = "B5";
    PdfPageSize[PdfPageSize["B6"] = 17] = "B6";
    PdfPageSize[PdfPageSize["B7"] = 18] = "B7";
    PdfPageSize[PdfPageSize["B8"] = 19] = "B8";
    PdfPageSize[PdfPageSize["B9"] = 20] = "B9";
    PdfPageSize[PdfPageSize["B10"] = 21] = "B10";
    PdfPageSize[PdfPageSize["C0"] = 22] = "C0";
    PdfPageSize[PdfPageSize["C1"] = 23] = "C1";
    PdfPageSize[PdfPageSize["C2"] = 24] = "C2";
    PdfPageSize[PdfPageSize["C3"] = 25] = "C3";
    PdfPageSize[PdfPageSize["C4"] = 26] = "C4";
    PdfPageSize[PdfPageSize["C5"] = 27] = "C5";
    PdfPageSize[PdfPageSize["C6"] = 28] = "C6";
    PdfPageSize[PdfPageSize["C7"] = 29] = "C7";
    PdfPageSize[PdfPageSize["C8"] = 30] = "C8";
    PdfPageSize[PdfPageSize["C9"] = 31] = "C9";
    PdfPageSize[PdfPageSize["C10"] = 32] = "C10";
    PdfPageSize[PdfPageSize["RA0"] = 33] = "RA0";
    PdfPageSize[PdfPageSize["RA1"] = 34] = "RA1";
    PdfPageSize[PdfPageSize["RA2"] = 35] = "RA2";
    PdfPageSize[PdfPageSize["RA3"] = 36] = "RA3";
    PdfPageSize[PdfPageSize["RA4"] = 37] = "RA4";
    PdfPageSize[PdfPageSize["SRA0"] = 38] = "SRA0";
    PdfPageSize[PdfPageSize["SRA1"] = 39] = "SRA1";
    PdfPageSize[PdfPageSize["SRA2"] = 40] = "SRA2";
    PdfPageSize[PdfPageSize["SRA3"] = 41] = "SRA3";
    PdfPageSize[PdfPageSize["SRA4"] = 42] = "SRA4";
    PdfPageSize[PdfPageSize["Executive"] = 43] = "Executive";
    PdfPageSize[PdfPageSize["Folio"] = 44] = "Folio";
    PdfPageSize[PdfPageSize["Legal"] = 45] = "Legal";
    PdfPageSize[PdfPageSize["Letter"] = 46] = "Letter";
    PdfPageSize[PdfPageSize["Tabloid"] = 47] = "Tabloid";
})(PdfPageSize = exports.PdfPageSize || (exports.PdfPageSize = {}));
'use strict';
exports._Errors = {
    InvalidArg: function (name) {
        return 'Invalid argument: "' + name + '".';
    },
    InvalidFormat: function (value) {
        return '"' + value + '" is not in the correct format.';
    },
    ValueCannotBeEmpty: function (name) {
        return 'Value cannot be empty: "' + name + '".';
    },
    PathStarted: 'This method can not be used until the current path is finished.',
    BufferPagesMustBeEnabled: 'The bufferPages property must be enabled to render headers and footers.',
    AbstractMethod: 'This is an abstract method, it should not be called.',
    FontNameMustBeSet: 'The font name must be set.',
    FontSourceMustBeStringArrayBuffer: 'The font source must be of type string or ArrayBuffer.',
    FontSourceMustBeString: 'The font source must be of type string.',
    FontSourceMustBeArrayBuffer: 'The font source must be of type ArrayBuffer.',
    EmptyUrl: 'URL can not be empty.',
    UndefinedMimeType: 'MIME-type must be set.',
    InvalidImageDataUri: 'Invalid Data URI. It should be base64 encoded string that represents JPG or PNG image.',
    InvalidImageFormat: 'Invalid image format. Only JPG and PNG formats are supported.'
};
'use strict';
exports._IE = 'ActiveXObject' in window;
var _FontSizePt = {
    'xx-small': 7,
    'x-small': 7.5,
    small: 10,
    medium: 12,
    large: 13.5,
    'x-large': 18,
    'xx-large': 24
};
function saveBlob(blob, fileName) {
    if (!blob || !(blob instanceof Blob) || !fileName) {
        return;
    }
    if (navigator.msSaveBlob) {
        navigator.msSaveBlob(blob, fileName);
    }
    else {
        var link = document.createElement('a'), click = function (element) {
            var evnt = document.createEvent('MouseEvents');
            evnt.initMouseEvent('click', true, false, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);
            element.dispatchEvent(evnt);
        };
        if ("download" in link) {
            var url = window.URL || window.webkitURL || window, objUrl = url.createObjectURL(blob);
            link.href = objUrl;
            link.download = fileName;
            click(link);
            link = null;
            window.setTimeout(function () {
                url.revokeObjectURL(objUrl);
            }, 30000);
        }
        else {
            var fr = new FileReader();
            fr.onloadend = function (e) {
                link.download = fileName;
                link.href = fr.result;
                click(link);
                link = null;
            };
            fr.readAsDataURL(blob);
        }
    }
}
exports.saveBlob = saveBlob;
function ptToPx(value) {
    return wjcCore.asNumber(value) / 0.75;
}
exports.ptToPx = ptToPx;
function pxToPt(value) {
    return wjcCore.asNumber(value) * 0.75;
}
exports.pxToPt = pxToPt;
function _asColor(colorOrString, clone) {
    if (clone === void 0) { clone = true; }
    var res;
    if (!colorOrString) {
        res = wjcCore.Color.fromRgba(0, 0, 0);
    }
    else {
        if (colorOrString instanceof wjcCore.Color) {
            res = clone
                ? wjcCore.Color.fromRgba(colorOrString.r, colorOrString.g, colorOrString.b, colorOrString.a)
                : colorOrString;
        }
        else {
            res = wjcCore.Color.fromString(colorOrString);
        }
    }
    wjcCore.assert(res instanceof wjcCore.Color, exports._Errors.InvalidArg('colorOrString'));
    return res;
}
exports._asColor = _asColor;
function _asPdfPen(penOrColor, nullOK) {
    if (nullOK === void 0) { nullOK = true; }
    if (wjcCore.isString(penOrColor) || (penOrColor instanceof wjcCore.Color)) {
        penOrColor = new PdfPen(penOrColor);
    }
    wjcCore.assert((penOrColor == null && nullOK) || penOrColor instanceof PdfPen, exports._Errors.InvalidArg('penOrColor'));
    return penOrColor;
}
exports._asPdfPen = _asPdfPen;
function _asPdfBrush(brushOrColor, nullOK) {
    if (nullOK === void 0) { nullOK = true; }
    if (wjcCore.isString(brushOrColor) || (brushOrColor instanceof wjcCore.Color)) {
        brushOrColor = new PdfSolidBrush(brushOrColor);
    }
    wjcCore.assert((brushOrColor == null && nullOK) || brushOrColor instanceof PdfBrush, exports._Errors.InvalidArg('brushOrColor'));
    return brushOrColor;
}
exports._asPdfBrush = _asPdfBrush;
function _asPdfFont(font, nullOK) {
    if (nullOK === void 0) { nullOK = true; }
    wjcCore.assert((font == null && nullOK) || font instanceof PdfFont, exports._Errors.InvalidArg('font'));
    return font;
}
exports._asPdfFont = _asPdfFont;
function _asPt(value, emptyOK, emptyValue) {
    if (emptyOK === void 0) { emptyOK = true; }
    if (emptyValue === void 0) { emptyValue = 0; }
    var isEmpty = !value && value !== 0;
    wjcCore.assert(!isEmpty || emptyOK, exports._Errors.ValueCannotBeEmpty('value'));
    if (isEmpty) {
        return emptyValue;
    }
    if (wjcCore.isNumber(value)) {
        if (value === value) {
            return value;
        }
    }
    else {
        if (wjcCore.isString(value)) {
            if (_FontSizePt[value]) {
                return _FontSizePt[value];
            }
            var num = parseFloat(value);
            if (num === num) {
                if (value.match(/(px)$/i)) {
                    return pxToPt(num);
                }
                if (value == num || value.match(/(pt)$/i)) {
                    return num;
                }
            }
        }
    }
    wjcCore.assert(false, exports._Errors.InvalidFormat(value));
}
exports._asPt = _asPt;
function _formatMacros(str, dict) {
    var amps = {}, ampsCnt = 0;
    str = str.replace(/&&/g, function (match, offset, str) {
        amps[offset - (ampsCnt * 2) + ampsCnt] = true;
        ampsCnt++;
        return '&';
    });
    str = str.replace(/&\[(\S+?)\]/g, function (match, p1, offset, str) {
        var macros = dict[p1];
        return macros && !amps[offset]
            ? macros
            : match;
    });
    return str;
}
exports._formatMacros = _formatMacros;
function _compare(a, b) {
    if (wjcCore.isObject(a) && wjcCore.isObject(b)) {
        for (var key in a) {
            if (key && (key[0] === '_')) {
                continue;
            }
            var val = a[key], cmp = val && wjcCore.isFunction(val.equals) ? val.equals(b[key]) : _compare(val, b[key]);
            if (!cmp) {
                return false;
            }
        }
        return true;
    }
    else {
        if (wjcCore.isArray(a) && wjcCore.isArray(b)) {
            if (a.length !== b.length) {
                return false;
            }
            for (var i = 0; i < a.length; i++) {
                if (!_compare(a[i], b[i])) {
                    return false;
                }
            }
            return true;
        }
    }
    return a === b;
}
exports._compare = _compare;
function _shallowCopy(src) {
    var dst = {};
    if (src) {
        for (var key in src) {
            dst[key] = src[key];
        }
    }
    return dst;
}
exports._shallowCopy = _shallowCopy;
function _toTitleCase(value) {
    if (value) {
        return value.charAt(0).toUpperCase() + value.slice(1).toLowerCase();
    }
    return value;
}
exports._toTitleCase = _toTitleCase;
'use strict';
var PdfDashPattern = (function () {
    function PdfDashPattern(dash, gap, phase) {
        if (dash === void 0) { dash = null; }
        if (gap === void 0) { gap = dash; }
        if (phase === void 0) { phase = 0; }
        this.dash = dash;
        this.gap = gap;
        this.phase = phase;
    }
    Object.defineProperty(PdfDashPattern.prototype, "dash", {
        get: function () {
            return this._dash;
        },
        set: function (value) {
            this._dash = wjcCore.asNumber(value, true, true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfDashPattern.prototype, "gap", {
        get: function () {
            return this._gap;
        },
        set: function (value) {
            this._gap = wjcCore.asNumber(value, true, true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfDashPattern.prototype, "phase", {
        get: function () {
            return this._phase;
        },
        set: function (value) {
            this._phase = wjcCore.asNumber(value, false, true);
        },
        enumerable: true,
        configurable: true
    });
    PdfDashPattern.prototype.clone = function () {
        return new PdfDashPattern(this._dash, this._gap, this._phase);
    };
    PdfDashPattern.prototype.equals = function (value) {
        return ((value instanceof PdfDashPattern)
            && (this._dash === value.dash)
            && (this._gap === value.gap)
            && (this._phase === value.phase));
    };
    return PdfDashPattern;
}());
exports.PdfDashPattern = PdfDashPattern;
'use strict';
var PdfBrush = (function () {
    function PdfBrush() {
    }
    PdfBrush.prototype.clone = function () {
        throw exports._Errors.AbstractMethod;
    };
    PdfBrush.prototype.equals = function (value) {
        throw exports._Errors.AbstractMethod;
    };
    PdfBrush.prototype._getBrushObject = function (area) {
        throw exports._Errors.AbstractMethod;
    };
    return PdfBrush;
}());
exports.PdfBrush = PdfBrush;
'use strict';
var PdfGradientStop = (function () {
    function PdfGradientStop(offset, color, opacity) {
        this.offset = offset || 0;
        this.color = color || wjcCore.Color.fromRgba(0, 0, 0);
        this.opacity = opacity == null ? 1 : opacity;
    }
    Object.defineProperty(PdfGradientStop.prototype, "offset", {
        get: function () {
            return this._offset;
        },
        set: function (value) {
            this._offset = wjcCore.clamp(wjcCore.asNumber(value, false, true), 0, 1);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfGradientStop.prototype, "color", {
        get: function () {
            return this._color;
        },
        set: function (value) {
            this._color = _asColor(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfGradientStop.prototype, "opacity", {
        get: function () {
            return this._opacity;
        },
        set: function (value) {
            this._opacity = wjcCore.clamp(wjcCore.asNumber(value, false, true), 0, 1);
        },
        enumerable: true,
        configurable: true
    });
    PdfGradientStop.prototype.clone = function () {
        return new PdfGradientStop(this.offset, this.color, this.opacity);
    };
    PdfGradientStop.prototype.equals = function (value) {
        return ((value instanceof PdfGradientStop)
            && (this._offset === value._offset)
            && this._color.equals(value._color)
            && (this._opacity === value._opacity));
    };
    return PdfGradientStop;
}());
exports.PdfGradientStop = PdfGradientStop;
'use strict';
var PdfGradientBrush = (function (_super) {
    __extends(PdfGradientBrush, _super);
    function PdfGradientBrush(stops, opacity) {
        var _this = _super.call(this) || this;
        _this.stops = stops || [];
        _this.opacity = opacity == null ? 1 : opacity;
        return _this;
    }
    Object.defineProperty(PdfGradientBrush.prototype, "opacity", {
        get: function () {
            return this._opacity;
        },
        set: function (value) {
            this._opacity = wjcCore.clamp(wjcCore.asNumber(value, false, true), 0, 1);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfGradientBrush.prototype, "stops", {
        get: function () {
            return this._stops;
        },
        set: function (value) {
            wjcCore.assert(wjcCore.isArray(value), exports._Errors.InvalidArg('value'));
            this._stops = this._cloneStopsArray(value);
        },
        enumerable: true,
        configurable: true
    });
    PdfGradientBrush.prototype.equals = function (value) {
        return (value instanceof PdfGradientBrush)
            && (this._opacity === value.opacity)
            && _compare(this._stops, value._stops);
    };
    PdfGradientBrush.prototype._cloneStopsArray = function (value) {
        var res = [];
        for (var i = 0; i < value.length; i++) {
            var stop = value[i];
            wjcCore.assert(stop instanceof PdfGradientStop, exports._Errors.InvalidArg('stops[' + i + ']'));
            res.push(value[i].clone());
        }
        return res;
    };
    return PdfGradientBrush;
}(PdfBrush));
exports.PdfGradientBrush = PdfGradientBrush;
'use strict';
var PdfLinearGradientBrush = (function (_super) {
    __extends(PdfLinearGradientBrush, _super);
    function PdfLinearGradientBrush(x1, y1, x2, y2, stops, opacity) {
        var _this = _super.call(this, stops, opacity) || this;
        _this.x1 = x1;
        _this.y1 = y1;
        _this.x2 = x2;
        _this.y2 = y2;
        return _this;
    }
    Object.defineProperty(PdfLinearGradientBrush.prototype, "x1", {
        get: function () {
            return this._x1;
        },
        set: function (value) {
            this._x1 = wjcCore.asNumber(value, false, true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfLinearGradientBrush.prototype, "y1", {
        get: function () {
            return this._y1;
        },
        set: function (value) {
            this._y1 = wjcCore.asNumber(value, false, true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfLinearGradientBrush.prototype, "x2", {
        get: function () {
            return this._x2;
        },
        set: function (value) {
            this._x2 = wjcCore.asNumber(value, false, true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfLinearGradientBrush.prototype, "y2", {
        get: function () {
            return this._y2;
        },
        set: function (value) {
            this._y2 = wjcCore.asNumber(value, false, true);
        },
        enumerable: true,
        configurable: true
    });
    PdfLinearGradientBrush.prototype.clone = function () {
        return new PdfLinearGradientBrush(this._x1, this._y1, this._x2, this._y2, this.stops, this.opacity);
    };
    PdfLinearGradientBrush.prototype.equals = function (value) {
        return (value instanceof PdfLinearGradientBrush)
            && (this._x1 === value._x1)
            && (this._y1 === value._y1)
            && (this._x2 === value._x2)
            && (this._y2 === value._y2)
            && _super.prototype.equals.call(this, value);
    };
    PdfLinearGradientBrush.prototype._getBrushObject = function (area) {
        var g = area._pdfdoc._document.linearGradient(this._x1 + area._offset.x, this._y1 + area._offset.y, this._x2 + area._offset.x, this._y2 + area._offset.y), stops = this.stops;
        for (var i = 0; i < stops.length; i++) {
            var s = stops[i];
            if (s) {
                g.stop(s.offset, [s.color.r, s.color.g, s.color.b], s.color.a);
            }
        }
        return g;
    };
    return PdfLinearGradientBrush;
}(PdfGradientBrush));
exports.PdfLinearGradientBrush = PdfLinearGradientBrush;
'use strict';
var PdfRadialGradientBrush = (function (_super) {
    __extends(PdfRadialGradientBrush, _super);
    function PdfRadialGradientBrush(x1, y1, r1, x2, y2, r2, stops, opacity) {
        var _this = _super.call(this, stops, opacity) || this;
        _this.x1 = x1;
        _this.y1 = y1;
        _this.r1 = r1;
        _this.x2 = x2;
        _this.y2 = y2;
        _this.r2 = r2;
        return _this;
    }
    Object.defineProperty(PdfRadialGradientBrush.prototype, "x1", {
        get: function () {
            return this._x1;
        },
        set: function (value) {
            this._x1 = wjcCore.asNumber(value, false, true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfRadialGradientBrush.prototype, "y1", {
        get: function () {
            return this._y1;
        },
        set: function (value) {
            this._y1 = wjcCore.asNumber(value, false, true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfRadialGradientBrush.prototype, "r1", {
        get: function () {
            return this._r1;
        },
        set: function (value) {
            this._r1 = wjcCore.asNumber(value, false, true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfRadialGradientBrush.prototype, "x2", {
        get: function () {
            return this._x2;
        },
        set: function (value) {
            this._x2 = wjcCore.asNumber(value, false, true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfRadialGradientBrush.prototype, "y2", {
        get: function () {
            return this._y2;
        },
        set: function (value) {
            this._y2 = wjcCore.asNumber(value, false, true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfRadialGradientBrush.prototype, "r2", {
        get: function () {
            return this._r2;
        },
        set: function (value) {
            this._r2 = wjcCore.asNumber(value, false, true);
        },
        enumerable: true,
        configurable: true
    });
    PdfRadialGradientBrush.prototype.clone = function () {
        return new PdfRadialGradientBrush(this._x1, this._y1, this._r1, this._x2, this._y2, this._r2, this.stops, this.opacity);
    };
    PdfRadialGradientBrush.prototype.equals = function (value) {
        return (value instanceof PdfRadialGradientBrush)
            && (this._x1 === value._x1)
            && (this._y1 === value._y1)
            && (this._r1 === value._r1)
            && (this._x2 === value._x2)
            && (this._y2 === value._y2)
            && (this._r2 === value._r2)
            && _super.prototype.equals.call(this, value);
    };
    PdfRadialGradientBrush.prototype._getBrushObject = function (area) {
        var g = area._pdfdoc._document.radialGradient(this._x1 + area._offset.x, this._y2 + area._offset.y, this._r1, this._x2 + area._offset.x, this._y2 + area._offset.y, this._r2), stops = this.stops;
        for (var i = 0; i < stops.length; i++) {
            var s = stops[i];
            if (s) {
                g.stop(s.offset, [s.color.r, s.color.g, s.color.b], s.color.a);
            }
        }
        return g;
    };
    return PdfRadialGradientBrush;
}(PdfGradientBrush));
exports.PdfRadialGradientBrush = PdfRadialGradientBrush;
'use strict';
var PdfSolidBrush = (function (_super) {
    __extends(PdfSolidBrush, _super);
    function PdfSolidBrush(color) {
        var _this = _super.call(this) || this;
        _this.color = color || wjcCore.Color.fromRgba(0, 0, 0);
        return _this;
    }
    Object.defineProperty(PdfSolidBrush.prototype, "color", {
        get: function () {
            return this._color;
        },
        set: function (value) {
            this._color = _asColor(value);
        },
        enumerable: true,
        configurable: true
    });
    PdfSolidBrush.prototype.clone = function () {
        return new PdfSolidBrush(this._color);
    };
    PdfSolidBrush.prototype.equals = function (value) {
        return ((value instanceof PdfSolidBrush)
            && this._color.equals(value._color));
    };
    PdfSolidBrush.prototype._getBrushObject = function (area) {
        return this._color;
    };
    return PdfSolidBrush;
}(PdfBrush));
exports.PdfSolidBrush = PdfSolidBrush;
'use strict';
var PdfPen = (function () {
    function PdfPen(colorOrBrushOrOptions, width, dashPattern, cap, join, miterLimit) {
        if (colorOrBrushOrOptions == null) {
            colorOrBrushOrOptions = wjcCore.Color.fromRgba(0, 0, 0);
        }
        if (width == null) {
            width = 1;
        }
        if (dashPattern == null) {
            dashPattern = new PdfDashPattern(null, null, 0);
        }
        if (cap == null) {
            cap = PdfLineCapStyle.Butt;
        }
        if (join == null) {
            join = PdfLineJoinStyle.Miter;
        }
        if (miterLimit == null) {
            miterLimit = 10;
        }
        if (wjcCore.isObject(colorOrBrushOrOptions) && !(colorOrBrushOrOptions instanceof wjcCore.Color) && !(colorOrBrushOrOptions instanceof PdfBrush)) {
            var foo = colorOrBrushOrOptions;
            this.color = foo.color;
            this.brush = foo.brush;
            this.width = foo.width != null ? foo.width : width;
            this.cap = foo.cap != null ? foo.cap : cap;
            this.join = foo.join != null ? foo.join : join;
            this.miterLimit = foo.miterLimit != null ? foo.miterLimit : miterLimit;
            this.dashPattern = foo.dashPattern || dashPattern;
        }
        else {
            if (colorOrBrushOrOptions instanceof PdfBrush) {
                this.brush = colorOrBrushOrOptions;
            }
            else {
                this.color = colorOrBrushOrOptions;
            }
            this.width = width;
            this.cap = cap;
            this.join = join;
            this.miterLimit = miterLimit;
            this.dashPattern = dashPattern;
        }
        this._color = this._color || wjcCore.Color.fromRgba(0, 0, 0);
    }
    Object.defineProperty(PdfPen.prototype, "color", {
        get: function () {
            return this._color;
        },
        set: function (value) {
            this._color = _asColor(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfPen.prototype, "brush", {
        get: function () {
            return this._brush;
        },
        set: function (value) {
            value = _asPdfBrush(value, true);
            this._brush = value ? value.clone() : null;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfPen.prototype, "width", {
        get: function () {
            return this._width;
        },
        set: function (value) {
            this._width = wjcCore.asNumber(value, false, true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfPen.prototype, "cap", {
        get: function () {
            return this._cap;
        },
        set: function (value) {
            this._cap = wjcCore.asEnum(value, PdfLineCapStyle);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfPen.prototype, "join", {
        get: function () {
            return this._join;
        },
        set: function (value) {
            this._join = wjcCore.asEnum(value, PdfLineJoinStyle);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfPen.prototype, "miterLimit", {
        get: function () {
            return this._miterLimit;
        },
        set: function (value) {
            this._miterLimit = wjcCore.asNumber(value, false, true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfPen.prototype, "dashPattern", {
        get: function () {
            return this._dashPattern;
        },
        set: function (value) {
            wjcCore.assert(value instanceof PdfDashPattern, exports._Errors.InvalidArg('value'));
            this._dashPattern = value.clone();
        },
        enumerable: true,
        configurable: true
    });
    PdfPen.prototype.clone = function () {
        var pen = new PdfPen(this._color, this._width, this._dashPattern, this._cap, this._join, this._miterLimit);
        pen.brush = this._brush;
        return pen;
    };
    PdfPen.prototype.equals = function (value) {
        return ((value instanceof PdfPen)
            && this._color.equals(value._color)
            && (this._brush ? this._brush.equals(value._brush) : this._brush === value._brush)
            && (this._width === value._width)
            && (this._cap === value._cap)
            && (this._join === value._join)
            && (this._miterLimit === value._miterLimit)
            && this._dashPattern.equals(value._dashPattern));
    };
    return PdfPen;
}());
exports.PdfPen = PdfPen;
'use strict';
var PdfFont = (function () {
    function PdfFont(family, size, style, weight) {
        if (family === void 0) { family = 'times'; }
        if (size === void 0) { size = 10; }
        if (style === void 0) { style = 'normal'; }
        if (weight === void 0) { weight = 'normal'; }
        this.family = family;
        this.size = size;
        this.style = style;
        this.weight = weight;
    }
    Object.defineProperty(PdfFont.prototype, "family", {
        get: function () {
            return this._family;
        },
        set: function (value) {
            this._family = wjcCore.asString(value, false);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfFont.prototype, "size", {
        get: function () {
            return this._size;
        },
        set: function (value) {
            this._size = wjcCore.asNumber(value, false, true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfFont.prototype, "style", {
        get: function () {
            return this._style;
        },
        set: function (value) {
            value = wjcCore.asString(value, false);
            if (value) {
                wjcCore.assert(!!PdfFont._KNOWN_STYLES[(value || '').toLowerCase()], exports._Errors.InvalidArg('value'));
            }
            this._style = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfFont.prototype, "weight", {
        get: function () {
            return this._weight;
        },
        set: function (value) {
            value = wjcCore.asString(value, false);
            if (value) {
                wjcCore.assert(!!PdfFont._KNOWN_WEIGHTS[(value || '').toLowerCase()], exports._Errors.InvalidArg('value'));
            }
            this._weight = value;
        },
        enumerable: true,
        configurable: true
    });
    PdfFont.prototype.clone = function () {
        return new PdfFont(this.family, this.size, this.style, this.weight);
    };
    PdfFont.prototype.equals = function (value) {
        return (value instanceof PdfFont)
            && (this._family === value._family)
            && (this._size === value._size)
            && (this._style === value._style)
            && (this._weight === value._weight);
    };
    PdfFont._DEF_NATIVE_NAME = 'Times-Roman';
    PdfFont._DEF_FAMILY_NAME = 'times';
    PdfFont._KNOWN_WEIGHTS = {
        'normal': 1, 'bold': 1, '100': 1, '200': 1, '300': 1, '400': 1, '500': 1, '600': 1, '700': 1, '800': 1, '900': 1
    };
    PdfFont._KNOWN_STYLES = {
        'normal': 1, 'italic': 1, 'oblique': 1
    };
    PdfFont._DEF_PDFKIT_FONT = new PdfFont('helvetica', 12);
    PdfFont._DEF_FONT = new PdfFont();
    return PdfFont;
}());
exports.PdfFont = PdfFont;
'use strict';
var _OrderedDictionary = (function () {
    function _OrderedDictionary(values) {
        this._values = [];
        this._keys = {};
        if (values) {
            for (var i = 0; i < values.length; i++) {
                var val = values[i];
                this._keys[val.key] = i;
                this._values.push({ key: val.key, value: val.value });
            }
        }
    }
    _OrderedDictionary.prototype.hasKey = function (key) {
        var idx = this._keys[key];
        if (idx !== undefined) {
            return this._values[idx].value;
        }
        return null;
    };
    _OrderedDictionary.prototype.add = function (key, value) {
        if (!this.hasKey(key)) {
            this._keys[key] = this._values.length;
            this._values.push({ key: key, value: value });
            return value;
        }
        return null;
    };
    _OrderedDictionary.prototype.each = function (fn) {
        if (fn) {
            for (var i = 0; i < this._values.length; i++) {
                var val = this._values[i];
                if (fn(val.key, val.value) === false) {
                    break;
                }
            }
        }
    };
    _OrderedDictionary.prototype.eachReverse = function (fn) {
        if (fn) {
            for (var i = this._values.length - 1; i >= 0; i--) {
                var val = this._values[i];
                if (fn(val.key, val.value) === false) {
                    break;
                }
            }
        }
    };
    return _OrderedDictionary;
}());
var _PdfFontRegistrar = (function () {
    function _PdfFontRegistrar(doc) {
        var _this = this;
        this._fonts = new _OrderedDictionary([
            {
                key: 'zapfdingbats',
                value: {
                    attributes: {
                        fantasy: true
                    },
                    normal: {
                        400: 'ZapfDingbats'
                    }
                }
            },
            {
                key: 'symbol',
                value: {
                    attributes: {
                        serif: true
                    },
                    normal: {
                        400: 'Symbol'
                    }
                }
            },
            {
                key: 'courier',
                value: {
                    attributes: {
                        serif: true,
                        monospace: true
                    },
                    normal: {
                        400: 'Courier',
                        700: 'Courier-Bold'
                    },
                    oblique: {
                        400: 'Courier-Oblique',
                        700: 'Courier-BoldOblique'
                    }
                }
            },
            {
                key: 'helvetica',
                value: {
                    attributes: {
                        sansSerif: true
                    },
                    normal: {
                        400: 'Helvetica',
                        700: 'Helvetica-Bold'
                    },
                    oblique: {
                        400: 'Helvetica-Oblique',
                        700: 'Helvetica-BoldOblique'
                    }
                }
            },
            {
                key: 'times',
                value: {
                    attributes: {
                        serif: true
                    },
                    normal: {
                        400: 'Times-Roman',
                        700: 'Times-Bold'
                    },
                    italic: {
                        400: 'Times-Italic',
                        700: 'Times-BoldItalic'
                    }
                }
            }
        ]);
        this._weightNameToNum = {
            'normal': 400,
            'bold': 700
        };
        this._findFontCache = {};
        this._internalFontNames = {};
        this._doc = doc;
        this._fonts.each(function (key, value) {
            var facesIterator = function (descr) {
                for (var key in descr) {
                    _this._internalFontNames[descr[key]] = 1;
                }
            };
            facesIterator(value.normal) || facesIterator(value.italic) || facesIterator(value.oblique);
        });
    }
    _PdfFontRegistrar.prototype.registerFont = function (font) {
        wjcCore.assert(!!font, exports._Errors.ValueCannotBeEmpty('font'));
        wjcCore.asString(font.name);
        wjcCore.assert(font.source instanceof ArrayBuffer, exports._Errors.FontSourceMustBeArrayBuffer);
        font = _shallowCopy(font);
        var ns = this._normalizeFontSelector(font.name, font.style, font.weight), fntDscr = this._fonts.hasKey(ns.name);
        if (!fntDscr) {
            fntDscr = this._fonts.add(ns.name, { attributes: font });
        }
        var face = fntDscr[ns.style];
        if (!face) {
            face = fntDscr[ns.style] = {};
        }
        var internalName = this._makeInternalName(ns);
        if (!face[ns.weight]) {
            this._doc.registerFont(internalName, font.source, font.family);
            this._findFontCache = {};
            face[ns.weight] = internalName;
            this._internalFontNames[internalName] = 1;
        }
        return internalName;
    };
    _PdfFontRegistrar.prototype.findFont = function (name, style, weight) {
        var ns = this._normalizeFontSelector(name, style, weight), internalName = this._makeInternalName(ns);
        if (this._findFontCache[internalName]) {
            return this._findFontCache[internalName];
        }
        ns.name += ',' + PdfFont._DEF_FAMILY_NAME;
        for (var i = 0, names = ns.name.split(','); i < names.length; i++) {
            var tmp = this._findFont(names[i].replace(/["']/g, '').trim(), ns.style, ns.weight);
            if (tmp) {
                return this._findFontCache[internalName] = tmp;
            }
        }
        return this._findFontCache[internalName] = this._internalFontNames[name]
            ? name
            : PdfFont._DEF_NATIVE_NAME;
    };
    _PdfFontRegistrar.prototype._normalizeFontSelector = function (name, style, weight) {
        return {
            name: (name || '').toLowerCase(),
            style: (style || PdfFont._DEF_FONT.style).toLowerCase(),
            weight: parseInt(this._weightNameToNum[weight] || weight) || parseInt(this._weightNameToNum[PdfFont._DEF_FONT.weight])
        };
    };
    _PdfFontRegistrar.prototype._findFont = function (name, style, weight) {
        var _this = this;
        var facesToTest = [], res;
        switch (style) {
            case 'italic':
                facesToTest = ['italic', 'oblique', 'normal'];
                break;
            case 'oblique':
                facesToTest = ['oblique', 'italic', 'normal'];
                break;
            default:
                facesToTest = ['normal', 'oblique', 'italic'];
                break;
        }
        switch (name) {
            case 'cursive':
            case 'fantasy':
            case 'monospace':
            case 'serif':
            case 'sans-serif':
                this._fonts.eachReverse(function (key, font) {
                    var propName = (name === 'sans-serif') ? 'sansSerif' : name;
                    if (font.attributes[propName]) {
                        for (var i = 0; i < facesToTest.length; i++) {
                            res = _this._findFontWeightFallback(key, facesToTest[i], weight);
                            if (res) {
                                return false;
                            }
                        }
                    }
                });
                break;
            default:
                if (this._fonts.hasKey(name)) {
                    for (var i = 0; i < facesToTest.length && !res; i++) {
                        res = this._findFontWeightFallback(name, facesToTest[i], weight);
                    }
                }
        }
        return res;
    };
    _PdfFontRegistrar.prototype._findFontWeightFallback = function (name, style, weight, availableWeights) {
        var font = this._fonts.hasKey(name);
        if (font && font[style]) {
            var weights = font[style];
            if (weights[weight]) {
                return weights[weight];
            }
            else {
                if (!availableWeights) {
                    availableWeights = [];
                    for (var key in weights) {
                        availableWeights.push(parseFloat(key));
                    }
                    availableWeights.sort(function (a, b) { return a - b; });
                }
                if (weight > 500) {
                    var less = 0;
                    for (var i = 0; i < availableWeights.length; i++) {
                        var cur = availableWeights[i];
                        if (cur > weight) {
                            return weights[cur];
                        }
                        else {
                            less = cur;
                        }
                    }
                    if (less) {
                        return weights[less];
                    }
                }
                else {
                    if (weight < 400) {
                        var greater = 0;
                        for (var i = availableWeights.length - 1; i >= 0; i--) {
                            var cur = availableWeights[i];
                            if (cur < weight) {
                                return weights[cur];
                            }
                            else {
                                greater = cur;
                            }
                        }
                        if (greater) {
                            return weights[greater];
                        }
                    }
                    else {
                        if (weight == 400) {
                            if (weights[500]) {
                                return weights[500];
                            }
                            else {
                                return this._findFontWeightFallback(name, style, 300, availableWeights);
                            }
                        }
                        else {
                            if (weights[400]) {
                                return weights[400];
                            }
                            else {
                                return this._findFontWeightFallback(name, style, 300, availableWeights);
                            }
                        }
                    }
                }
            }
        }
        return null;
    };
    _PdfFontRegistrar.prototype._makeInternalName = function (ns) {
        return ns.name + '-' + ns.style + '-' + ns.weight;
    };
    return _PdfFontRegistrar;
}());
exports._PdfFontRegistrar = _PdfFontRegistrar;
'use strict';
var PdfPageArea = (function () {
    function PdfPageArea() {
        this._ctxProps = {
            xo: 0,
            yo: 0,
            lineGap: 0
        };
    }
    Object.defineProperty(PdfPageArea.prototype, "x", {
        get: function () {
            this._switchCtx();
            var x = this._pdfdoc._document.x - this._offset.x;
            this._saveCtx();
            return x;
        },
        set: function (value) {
            value = wjcCore.asNumber(value);
            this._switchCtx();
            this._pdfdoc._document.x = value + this._offset.x;
            this._saveCtx();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfPageArea.prototype, "y", {
        get: function () {
            this._switchCtx();
            var y = this._pdfdoc._document.y - this._offset.y;
            this._saveCtx();
            return y;
        },
        set: function (value) {
            value = wjcCore.asNumber(value);
            this._switchCtx();
            this._pdfdoc._document.y = value + this._offset.y;
            this._saveCtx();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfPageArea.prototype, "lineGap", {
        get: function () {
            return this._ctxProps.lineGap;
        },
        set: function (value) {
            this._ctxProps.lineGap = value = wjcCore.asNumber(value, false, true);
            if (this._pdfdoc && this._pdfdoc._document) {
                this._switchCtx();
                this._pdfdoc._document.lineGap(value);
                this._saveCtx();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfPageArea.prototype, "height", {
        get: function () {
            var page = this._pdfdoc._document.page;
            return Math.max(0, page.height - page.margins.top - page.margins.bottom);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfPageArea.prototype, "width", {
        get: function () {
            var page = this._pdfdoc._document.page;
            return Math.max(page.width - page.margins.left - page.margins.right);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfPageArea.prototype, "paths", {
        get: function () {
            return this._graphics;
        },
        enumerable: true,
        configurable: true
    });
    PdfPageArea.prototype.drawText = function (text, x, y, options) {
        this._assertPathStarted();
        if (!(text = wjcCore.asString(text))) {
            return;
        }
        options = options || {};
        var doc = this._pdfdoc, natDoc = doc._document, sz, drawMode = options.stroke && options.fill ? 2 : options.stroke ? 1 : 0;
        if ((options.strike || options.underline) && !options.stroke) {
            drawMode = 2;
        }
        this._switchCtx();
        try {
            this._drawingText = true;
            if (!(drawMode & 1)) {
                doc._toggleBrush(_asPdfBrush(options.brush));
            }
            if (drawMode & 3) {
                doc._togglePen(_asPdfPen(options.pen));
            }
            doc._toggleFont(_asPdfFont(options.font));
            var native = this._textOptionsToNative(options), baselineOffset = options._baseline === _PdfTextBaseline.Alphabetic ? natDoc.currentFontAscender() : 0;
            if (x == null) {
                natDoc.y -= baselineOffset;
                sz = natDoc.textAndMeasure(text, null, null, native);
            }
            else {
                sz = natDoc.textAndMeasure(text, wjcCore.asNumber(x) + this._offset.x, wjcCore.asNumber(y) + this._offset.y - baselineOffset, native);
            }
        }
        finally {
            this._drawingText = false;
            this._saveCtx();
        }
        return {
            charCount: sz.charCount || 0,
            size: new wjcCore.Size(sz.width || 0, sz.height || 0)
        };
    };
    PdfPageArea.prototype.drawImage = function (url, x, y, options) {
        this._assertPathStarted();
        if (!(url = wjcCore.asString(url))) {
            return this;
        }
        var dataUrl = _PdfImageHelper.getDataUri(url);
        this._switchCtx();
        try {
            var o = {};
            if (options) {
                switch (wjcCore.asEnum(options.align, PdfImageHorizontalAlign, true)) {
                    case PdfImageHorizontalAlign.Center:
                        o.align = 'center';
                        break;
                    case PdfImageHorizontalAlign.Right:
                        o.align = 'right';
                        break;
                    default:
                        o.align = 'left';
                }
                switch (wjcCore.asEnum(options.vAlign, PdfImageVerticalAlign, true)) {
                    case PdfImageVerticalAlign.Center:
                        o.valign = 'center';
                        break;
                    case PdfImageVerticalAlign.Bottom:
                        o.valign = 'bottom';
                        break;
                    default:
                        o.valign = 'top';
                }
                var width = wjcCore.asNumber(options.width, true, true), height = wjcCore.asNumber(options.height, true, true);
                if (width && height && wjcCore.asBoolean(options.stretchProportionally, true)) {
                    o.fit = [width, height];
                }
                else {
                    o.width = width;
                    o.height = height;
                }
            }
            if (x == null) {
                this._pdfdoc._document.image(dataUrl, o);
            }
            else {
                this._pdfdoc._document.image(dataUrl, wjcCore.asNumber(x) + this._offset.x, wjcCore.asNumber(y) + this._offset.y, o);
            }
        }
        finally {
            this._saveCtx();
        }
        return this;
    };
    PdfPageArea.prototype.drawSvg = function (url, x, y, options) {
        var base64Decode = function (value) {
            return decodeURIComponent(Array.prototype.map.call(atob(value), function (c) {
                return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);
            }).join(''));
        };
        options = options || {};
        this._assertPathStarted();
        if (!(url = wjcCore.asString(url))) {
            return this;
        }
        var svg;
        if (url.indexOf('data:image/svg') >= 0) {
            svg = base64Decode(url.substring(url.indexOf(',') + 1));
        }
        else {
            var xhrError;
            svg = _XhrHelper.text(url, function (xhr) { return xhrError = xhr.statusText; });
            wjcCore.assert(xhrError == null, xhrError);
        }
        if (!svg) {
            return this;
        }
        var renderer = new _SvgRenderer(svg, this, wjcCore.asFunction(options.urlResolver)), textFlow = (y == null), x = x != null ? x : this.x, y = y != null ? y : this.y, oldY = this.y, oldX = this.x, scaleX, scaleY, optWidth = wjcCore.asNumber(options.width, true, true), optHeight = wjcCore.asNumber(options.height, true, true), svgWidth = renderer.root.width.hasVal ? renderer.root.width.val : undefined, svgHeight = renderer.root.height.hasVal ? renderer.root.height.val : undefined;
        if ((optWidth || optHeight) && (svgWidth && svgHeight)) {
            scaleX = optWidth / svgWidth;
            scaleY = optHeight / svgHeight;
            if (optWidth && optHeight) {
                if (options.stretchProportionally) {
                    var scaleMin = Math.min(scaleX, scaleY);
                    if (scaleX === scaleMin) {
                        switch (wjcCore.asEnum(options.vAlign, PdfImageVerticalAlign, true)) {
                            case PdfImageVerticalAlign.Center:
                                y += optHeight / 2 - (svgHeight * scaleX) / 2;
                                break;
                            case PdfImageVerticalAlign.Bottom:
                                y += optHeight - svgHeight * scaleX;
                                break;
                        }
                    }
                    if (scaleY === scaleMin) {
                        switch (wjcCore.asEnum(options.align, PdfImageHorizontalAlign, true)) {
                            case PdfImageHorizontalAlign.Center:
                                x += optWidth / 2 - (svgWidth * scaleY) / 2;
                                break;
                            case PdfImageHorizontalAlign.Right:
                                x += optWidth - svgWidth * scaleY;
                                break;
                        }
                    }
                    scaleX = scaleY = scaleMin;
                }
            }
            else {
                if (options.width) {
                    scaleY = scaleX;
                }
                else {
                    scaleX = scaleY;
                }
            }
        }
        scaleX = scaleX || 1;
        scaleY = scaleY || 1;
        this._switchCtx();
        this._pdfdoc.saveState();
        try {
            this.translate(x, y);
            this.scale(scaleX, scaleY);
            renderer.render();
        }
        finally {
            this._pdfdoc.restoreState();
            this._saveCtx();
        }
        this.x = oldX;
        this.y = oldY;
        if (textFlow) {
            var imgHeight = optHeight != null ? optHeight : (svgHeight != null ? svgHeight * scaleY : undefined);
            this.y += (imgHeight || 0);
        }
        return this;
    };
    PdfPageArea.prototype.lineHeight = function (font) {
        var doc = this._pdfdoc;
        doc._toggleFont(_asPdfFont(font));
        this._switchCtx();
        var value = doc._document.currentLineHeight();
        this._saveCtx();
        return value;
    };
    PdfPageArea.prototype.measureText = function (text, font, options) {
        var sz = {};
        if (text = wjcCore.asString(text)) {
            var doc = this._pdfdoc;
            doc._toggleFont(_asPdfFont(font));
            this._switchCtx();
            try {
                sz = doc._document.textAndMeasure(text, null, null, this._textOptionsToNative(options), true);
            }
            finally {
                this._saveCtx();
            }
        }
        return {
            charCount: sz.charCount || 0,
            size: new wjcCore.Size(sz.width || 0, sz.height || 0)
        };
    };
    PdfPageArea.prototype.moveDown = function (lines, font) {
        if (lines === void 0) { lines = 1; }
        if (lines = wjcCore.asNumber(lines, false, true)) {
            var doc = this._pdfdoc;
            doc._toggleFont(_asPdfFont(font));
            this._switchCtx();
            try {
                doc._document.moveDown(lines);
            }
            finally {
                this._saveCtx();
            }
        }
        return this;
    };
    PdfPageArea.prototype.moveUp = function (lines, font) {
        if (lines === void 0) { lines = 1; }
        if (lines = wjcCore.asNumber(lines, false, true)) {
            var doc = this._pdfdoc;
            doc._toggleFont(_asPdfFont(font));
            this._switchCtx();
            try {
                doc._document.moveUp(lines);
            }
            finally {
                this._saveCtx();
            }
        }
        return this;
    };
    PdfPageArea.prototype.scale = function (xFactor, yFactor, origin) {
        if (yFactor === void 0) { yFactor = xFactor; }
        this._assertPathStarted();
        origin = origin || new wjcCore.Point(0, 0);
        var ox = wjcCore.asNumber(origin.x) + this._offset.x, oy = wjcCore.asNumber(origin.y) + this._offset.y;
        xFactor = wjcCore.asNumber(xFactor, false);
        yFactor = wjcCore.asNumber(yFactor, false);
        this._pdfdoc._document.scale(xFactor, yFactor, {
            origin: [ox, oy]
        });
        return this;
    };
    PdfPageArea.prototype.translate = function (x, y) {
        this._assertPathStarted();
        x = wjcCore.asNumber(x);
        y = wjcCore.asNumber(y);
        this._pdfdoc._document.translate(x, y);
        return this;
    };
    PdfPageArea.prototype.transform = function (a, b, c, d, e, f) {
        this._assertPathStarted();
        a = wjcCore.asNumber(a);
        b = wjcCore.asNumber(b);
        c = wjcCore.asNumber(c);
        d = wjcCore.asNumber(d);
        e = wjcCore.asNumber(e);
        f = wjcCore.asNumber(f);
        var x = this._offset.x, y = this._offset.y;
        this._pdfdoc._document.transform(a, b, c, d, e - a * x + x - c * y, f - b * x - d * y + y);
        return this;
    };
    PdfPageArea.prototype.rotate = function (angle, origin) {
        this._assertPathStarted();
        origin = origin || new wjcCore.Point(0, 0);
        var ox = wjcCore.asNumber(origin.x) + this._offset.x, oy = wjcCore.asNumber(origin.y) + this._offset.y;
        angle = wjcCore.asNumber(angle);
        this._pdfdoc._document.rotate(angle, {
            origin: [ox, oy]
        });
        return this;
    };
    PdfPageArea.prototype._assertPathStarted = function () {
        wjcCore.assert(!this.paths._hasPathBuffer(), exports._Errors.PathStarted);
    };
    PdfPageArea.prototype._initialize = function (doc, xo, yo) {
        this._pdfdoc = doc;
        this._offset = new wjcCore.Point(xo, yo);
        this._ctxProps = {
            xo: xo,
            yo: yo,
            lineGap: this._ctxProps.lineGap
        };
        this._graphics = new PdfPaths(this._pdfdoc, this._offset);
    };
    PdfPageArea.prototype._isDrawingText = function () {
        return this._drawingText;
    };
    PdfPageArea.prototype._switchCtx = function () {
        this._pdfdoc._switchTextFlowCtx(this._ctxProps);
    };
    PdfPageArea.prototype._saveCtx = function () {
        this._ctxProps = this._pdfdoc._getTextFlowCtxState();
    };
    PdfPageArea.prototype._textOptionsToNative = function (value) {
        value = value || {};
        var res = _shallowCopy(value);
        if (value.align != null) {
            res.align = (PdfTextHorizontalAlign[wjcCore.asEnum(value.align, PdfTextHorizontalAlign)] || '').toLowerCase();
        }
        return res;
    };
    return PdfPageArea;
}());
exports.PdfPageArea = PdfPageArea;
'use strict';
var PdfRunningTitleDeclarativeContent = (function () {
    function PdfRunningTitleDeclarativeContent(text, font, brushOrColor) {
        this.text = text || '';
        this.font = font || new PdfFont();
        this.brush = brushOrColor || new PdfSolidBrush();
    }
    Object.defineProperty(PdfRunningTitleDeclarativeContent.prototype, "font", {
        get: function () {
            return this._font;
        },
        set: function (value) {
            value = _asPdfFont(value, true);
            this._font = value ? value.clone() : value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfRunningTitleDeclarativeContent.prototype, "text", {
        get: function () {
            return this._text;
        },
        set: function (value) {
            this._text = wjcCore.asString(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfRunningTitleDeclarativeContent.prototype, "brush", {
        get: function () {
            return this._brush;
        },
        set: function (value) {
            value = _asPdfBrush(value);
            this._brush = value ? value.clone() : value;
        },
        enumerable: true,
        configurable: true
    });
    PdfRunningTitleDeclarativeContent.prototype.clone = function () {
        return new PdfRunningTitleDeclarativeContent(this.text, this.font, this.brush);
    };
    PdfRunningTitleDeclarativeContent.prototype.equals = function (value) {
        return ((value instanceof PdfRunningTitleDeclarativeContent)
            && (this._text === value.text)
            && (this._brush ? this._brush.equals(value._brush) : this._brush === value._brush)
            && (this._font ? this._font.equals(value._font) : this._font === value._font));
    };
    return PdfRunningTitleDeclarativeContent;
}());
exports.PdfRunningTitleDeclarativeContent = PdfRunningTitleDeclarativeContent;
'use strict';
var PdfRunningTitle = (function (_super) {
    __extends(PdfRunningTitle, _super);
    function PdfRunningTitle(options) {
        var _this = _super.call(this) || this;
        _this._height = 24;
        _this._declarative = new PdfRunningTitleDeclarativeContent();
        _this._heightChanged = new wjcCore.Event();
        wjcCore.copy(_this, options);
        return _this;
    }
    Object.defineProperty(PdfRunningTitle.prototype, "declarative", {
        get: function () {
            return this._declarative;
        },
        set: function (value) {
            if (value != null) {
                wjcCore.assert(value instanceof PdfRunningTitleDeclarativeContent, exports._Errors.InvalidArg('value'));
                value = value.clone();
            }
            this._declarative = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfRunningTitle.prototype, "height", {
        get: function () {
            return this._height;
        },
        set: function (value) {
            if (value !== this._height) {
                this._height = wjcCore.asNumber(value, false, true);
                this._heightChanged.raise(this, wjcCore.EventArgs.empty);
            }
        },
        enumerable: true,
        configurable: true
    });
    PdfRunningTitle.prototype.drawText = function (text, x, y, options) {
        options = options || {};
        options.height = Infinity;
        return _super.prototype.drawText.call(this, text, x, y, options);
    };
    return PdfRunningTitle;
}(PdfPageArea));
exports.PdfRunningTitle = PdfRunningTitle;
'use strict';
var _PdfImageHelper = (function () {
    function _PdfImageHelper() {
    }
    _PdfImageHelper.getDataUri = function (url) {
        wjcCore.assert(!!(url = wjcCore.asString(url)), exports._Errors.EmptyUrl);
        if (_PdfImageHelper.DATAURI_CACHE[url]) {
            return _PdfImageHelper.DATAURI_CACHE[url];
        }
        var res = '';
        if (url.indexOf('data:') === 0) {
            wjcCore.assert(!!url.match(/^data:image\/(png|jpeg|jpg);base64,/), exports._Errors.InvalidImageDataUri);
            res = url;
        }
        else {
            var xhrError, buffer = _XhrHelper.arrayBuffer(url, function (xhr) { return xhrError = xhr.statusText; });
            wjcCore.assert(xhrError == null, xhrError);
            try {
                var arr = new Uint16Array(buffer, 0, 2);
                if ((arr[0] === 0xD8FF) || (arr[0] === 0x5089 && arr[1] === 0x474E)) {
                    var base64 = _PdfImageHelper._toBase64(buffer);
                    res = 'data:' + ((arr[0] === 0xD8FF) ? 'image/jpeg' : 'image/png') + ';base64,' + base64;
                }
                else {
                    throw '';
                }
            }
            catch (ex) {
                wjcCore.assert(false, exports._Errors.InvalidImageFormat);
            }
        }
        return _PdfImageHelper.DATAURI_CACHE[url] = res;
    };
    _PdfImageHelper._toBase64 = function (buffer) {
        var binary = '', bytes = new Uint8Array(buffer);
        for (var i = 0; i < bytes.byteLength; i++) {
            binary += String.fromCharCode(bytes[i]);
        }
        return window.btoa(binary);
    };
    _PdfImageHelper.DATAURI_CACHE = {};
    return _PdfImageHelper;
}());
exports._PdfImageHelper = _PdfImageHelper;
'use strict';
var PdfPaths = (function () {
    function PdfPaths(doc, offset) {
        this._pathBuffer = [];
        this._doc = doc;
        this._offset = offset;
    }
    PdfPaths.prototype.moveTo = function (x, y) {
        this._pathBuffer.push({
            func: this._doc._document.moveTo,
            params: [wjcCore.asNumber(x) + this._offset.x, wjcCore.asNumber(y) + this._offset.y]
        });
        return this;
    };
    PdfPaths.prototype.lineTo = function (x, y) {
        this._pathBuffer.push({
            func: this._doc._document.lineTo,
            params: [wjcCore.asNumber(x) + this._offset.x, wjcCore.asNumber(y) + this._offset.y]
        });
        return this;
    };
    PdfPaths.prototype.quadraticCurveTo = function (cpx, cpy, x, y) {
        this._pathBuffer.push({
            func: this._doc._document.quadraticCurveTo,
            params: [
                wjcCore.asNumber(cpx) + this._offset.x,
                wjcCore.asNumber(cpy) + this._offset.y,
                wjcCore.asNumber(x) + this._offset.x,
                wjcCore.asNumber(y) + this._offset.y
            ]
        });
        return this;
    };
    PdfPaths.prototype.bezierCurveTo = function (cp1x, cp1y, cp2x, cp2y, x, y) {
        this._pathBuffer.push({
            func: this._doc._document.bezierCurveTo,
            params: [
                wjcCore.asNumber(cp1x) + this._offset.x,
                wjcCore.asNumber(cp1y) + this._offset.y,
                wjcCore.asNumber(cp2x) + this._offset.x,
                wjcCore.asNumber(cp2y) + this._offset.y,
                wjcCore.asNumber(x) + this._offset.x,
                wjcCore.asNumber(y) + this._offset.y
            ]
        });
        return this;
    };
    PdfPaths.prototype.svgPath = function (path) {
        if (path) {
            var updatedPath = _PdfSvgPathHelper.offset(wjcCore.asString(path), this._offset);
            this._pathBuffer.push({
                func: this._doc._document.path,
                params: [wjcCore.asString(updatedPath)]
            });
        }
        return this;
    };
    PdfPaths.prototype.closePath = function () {
        this._writePathBuffer();
        this._doc._document.closePath();
        return this;
    };
    PdfPaths.prototype.rect = function (x, y, width, height) {
        this._pathBuffer.push({
            func: this._doc._document.rect,
            params: [
                wjcCore.asNumber(x) + this._offset.x,
                wjcCore.asNumber(y) + this._offset.y,
                wjcCore.asNumber(width, false, true),
                wjcCore.asNumber(height, false, true)
            ]
        });
        return this;
    };
    PdfPaths.prototype.roundedRect = function (x, y, width, height, cornerRadius) {
        if (cornerRadius === void 0) { cornerRadius = 0; }
        this._pathBuffer.push({
            func: this._doc._document.roundedRect,
            params: [
                wjcCore.asNumber(x) + this._offset.x,
                wjcCore.asNumber(y) + this._offset.y,
                wjcCore.asNumber(width, false, true),
                wjcCore.asNumber(height, false, true),
                wjcCore.asNumber(cornerRadius, false, true)
            ]
        });
        return this;
    };
    PdfPaths.prototype.ellipse = function (x, y, radiusX, radiusY) {
        if (radiusY === void 0) { radiusY = radiusX; }
        this._pathBuffer.push({
            func: this._doc._document.ellipse,
            params: [
                wjcCore.asNumber(x) + this._offset.x,
                wjcCore.asNumber(y) + this._offset.y,
                wjcCore.asNumber(radiusX, false, true),
                wjcCore.asNumber(radiusY, false, true)
            ]
        });
        return this;
    };
    PdfPaths.prototype.circle = function (x, y, radius) {
        this._pathBuffer.push({
            func: this._doc._document.circle,
            params: [
                wjcCore.asNumber(x) + this._offset.x,
                wjcCore.asNumber(y) + this._offset.y,
                wjcCore.asNumber(radius, false, true)
            ]
        });
        return this;
    };
    PdfPaths.prototype.polygon = function (points) {
        if (points) {
            for (var i = 0; i < points.length; i++) {
                var pnt = points[i];
                pnt[0] = pnt[0] + this._offset.x;
                pnt[1] = pnt[1] + this._offset.y;
            }
        }
        this._pathBuffer.push({
            func: this._doc._document.polygon,
            params: points
        });
        return this;
    };
    PdfPaths.prototype.clip = function (rule) {
        if (rule === void 0) { rule = PdfFillRule.NonZero; }
        this._writePathBuffer();
        this._doc._document.clip(rule === PdfFillRule.EvenOdd ? 'even-odd' : 'non-zero');
        return this;
    };
    PdfPaths.prototype.fill = function (brushOrColor, rule) {
        this._doc._toggleBrush(_asPdfBrush(brushOrColor));
        this._writePathBuffer();
        this._doc._document.fill(rule === PdfFillRule.EvenOdd ? 'even-odd' : 'non-zero');
        return this;
    };
    PdfPaths.prototype.fillAndStroke = function (brushOrColor, penOrColor, rule) {
        this._doc._toggleBrush(_asPdfBrush(brushOrColor));
        this._doc._togglePen(_asPdfPen(penOrColor));
        this._writePathBuffer();
        this._doc._document.fillAndStroke(rule === PdfFillRule.EvenOdd ? 'even-odd' : 'non-zero');
        return this;
    };
    PdfPaths.prototype.stroke = function (penOrColor) {
        this._doc._togglePen(_asPdfPen(penOrColor));
        this._writePathBuffer();
        this._doc._document.stroke();
        return this;
    };
    PdfPaths.prototype._hasPathBuffer = function () {
        return this._pathBuffer.length > 0;
    };
    PdfPaths.prototype._writePathBuffer = function () {
        var doc = this._doc._document;
        for (var i = 0; i < this._pathBuffer.length; i++) {
            var item = this._pathBuffer[i];
            item.func.apply(doc, item.params);
        }
        this._pathBuffer = [];
    };
    return PdfPaths;
}());
exports.PdfPaths = PdfPaths;
'use strict';
var _PdfSvgPathHelper = (function () {
    function _PdfSvgPathHelper() {
    }
    _PdfSvgPathHelper.offset = function (path, offset) {
        var _this = this;
        var newPath = this._processPath(path, function (value, cmd, cmdIdx, argIdx) {
            value = _this._updateOffset(value, offset, cmd, cmdIdx, argIdx);
            return value;
        });
        return newPath;
    };
    _PdfSvgPathHelper.scale = function (path, scale) {
        var newPath = this._processPath(path, function (value, cmd, cmdIdx, argIdx) {
            if (cmd === 'a' || cmd === 'A') {
                var rm = argIdx % 7;
                if (rm >= 2 && rm <= 4) {
                    return value;
                }
            }
            return value * scale;
        });
        return newPath;
    };
    _PdfSvgPathHelper._processPath = function (path, argCallback) {
        var tkn = this._getTokenizer(path), cmd = '', res = '', argIdx = -1, cmdIdx = -1;
        for (var token; token = tkn();) {
            if (token.length === 1 && /[a-zA-Z]/.test(token)) {
                cmdIdx++;
                cmd = token;
                argIdx = -1;
            }
            else {
                argIdx++;
                var newValue = argCallback(parseFloat(token), cmd, cmdIdx, argIdx);
                token = wjcCore.toFixed(newValue, 7, false) + '';
            }
            res += token + ' ';
        }
        return res;
    };
    _PdfSvgPathHelper._getTokenizer = function (path) {
        var len = path.length, i = 0;
        return function () {
            if (i >= len) {
                return '';
            }
            while ((i < len) && (/\s/.test(path[i]) || path[i] == ',')) {
                i++;
            }
            var j = i;
            while ((i < len) && (/[0-9\.\-eE\+]/.test(path[i]))) {
                i++;
            }
            if (i != j) {
                return path.substr(j, i - j);
            }
            return path.substr(i++, 1);
        };
    };
    _PdfSvgPathHelper._updateOffset = function (value, offset, cmd, cmdIdx, argIdx) {
        var o = 0;
        switch (cmd) {
            case 'm':
                if (cmdIdx === 0) {
                    if (argIdx === 0) {
                        o = -1;
                    }
                    else {
                        if (argIdx === 1) {
                            o = 1;
                        }
                    }
                }
                break;
            case 'L':
            case 'M':
            case 'C':
            case 'S':
            case 'Q':
            case 'T':
                o = (argIdx % 2 === 0) ? -1 : 1;
                break;
            case 'A':
                if (argIdx % 7 === 5) {
                    o = -1;
                }
                else {
                    if (argIdx % 7 === 6) {
                        o = 1;
                    }
                }
                break;
            case 'H':
                o = -1;
                break;
            case 'V':
                o = 1;
                break;
        }
        return o
            ? (o === -1 ? value + offset.x : value + offset.y)
            : value;
    };
    return _PdfSvgPathHelper;
}());
exports._PdfSvgPathHelper = _PdfSvgPathHelper;
'use strict';
var _XhrOverrideMimeTypeSupported = !!new XMLHttpRequest().overrideMimeType;
var _XhrHelper = (function () {
    function _XhrHelper() {
    }
    _XhrHelper.arrayBufferAsync = function (url, success, error) {
        var settings = {
            method: 'GET',
            responseType: 'arraybuffer',
            async: true
        };
        this._getData(url, settings, success, error);
    };
    _XhrHelper.arrayBuffer = function (url, error) {
        var buffer, settings = {
            method: 'GET',
            async: false
        };
        if (exports._IE || !_XhrOverrideMimeTypeSupported) {
            settings.responseType = 'arraybuffer';
            this._getData(url, settings, function (xhr, response) {
                buffer = response;
            }, error);
        }
        else {
            settings.overrideMimeType = 'text/plain; charset=x-user-defined';
            this._getData(url, settings, function (xhr, response) {
                buffer = new ArrayBuffer(response.length);
                var byteView = new Uint8Array(buffer);
                for (var i = 0, len = response.length; i < len; i++) {
                    byteView[i] = response.charCodeAt(i) & 0xFF;
                }
            }, error);
        }
        return buffer;
    };
    _XhrHelper.text = function (url, error) {
        var settings = {
            method: 'GET',
            async: false
        }, res = "";
        this._getData(url, settings, function (xhr, response) { return res = response; }, error);
        return res;
    };
    _XhrHelper._getData = function (url, settings, success, error) {
        var xhr = new XMLHttpRequest();
        settings = settings || {};
        xhr.open(settings.method, url, settings.async, settings.user, settings.password);
        xhr.addEventListener('load', function () {
            if (xhr.readyState === 4) {
                var status = xhr.status;
                if (status >= 200 && status < 300 || status === 304) {
                    if (success) {
                        success(xhr, xhr.response);
                    }
                }
                else {
                    if (error) {
                        error(xhr);
                    }
                }
            }
        });
        if (settings.headers) {
            for (var key in settings.headers) {
                xhr.setRequestHeader(key, settings.headers[key]);
            }
        }
        if (settings.responseType) {
            xhr.responseType = settings.responseType;
        }
        if (settings.overrideMimeType && xhr.overrideMimeType) {
            xhr.overrideMimeType(settings.overrideMimeType);
        }
        xhr.send(settings.data);
    };
    return _XhrHelper;
}());
exports._XhrHelper = _XhrHelper;
'use strict';
var PdfDocumentEndedEventArgs = (function (_super) {
    __extends(PdfDocumentEndedEventArgs, _super);
    function PdfDocumentEndedEventArgs(chunks) {
        var _this = _super.call(this) || this;
        _this._chunks = chunks;
        return _this;
    }
    Object.defineProperty(PdfDocumentEndedEventArgs.prototype, "blob", {
        get: function () {
            if (!this._blob) {
                this._blob = new Blob(this._chunks, { type: 'application/pdf' });
            }
            return this._blob;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfDocumentEndedEventArgs.prototype, "chunks", {
        get: function () {
            return this._chunks;
        },
        enumerable: true,
        configurable: true
    });
    return PdfDocumentEndedEventArgs;
}(wjcCore.EventArgs));
exports.PdfDocumentEndedEventArgs = PdfDocumentEndedEventArgs;
'use strict';
var PdfDocument = (function (_super) {
    __extends(PdfDocument, _super);
    function PdfDocument(options) {
        var _this = _super.call(this) || this;
        _this._docInitialized = false;
        _this._compress = true;
        _this._bufferPages = true;
        _this._chunks = [];
        _this._pageIndex = -1;
        _this._graphicsStack = [];
        _this._currentGS = {};
        _this.info = {
            author: undefined,
            creationDate: undefined,
            keywords: undefined,
            modDate: undefined,
            subject: undefined,
            title: undefined
        };
        _this.pageSettings = {
            layout: PdfPageOrientation.Portrait,
            size: PdfPageSize.Letter,
            margins: {
                top: 72,
                left: 72,
                bottom: 72,
                right: 72
            },
            _copy: function (key, value) {
                if (key === 'size') {
                    this.size = value;
                    return true;
                }
            }
        };
        _this.ended = new wjcCore.Event();
        _this.pageAdded = new wjcCore.Event();
        _this._runtimeProperties = ['pageIndex', 'x', 'y'];
        wjcCore.copy(_this, options);
        var pre = function (doc) {
            _this._doc = doc;
            _this._fontReg = new _PdfFontRegistrar(_this._doc);
        }, post = function () {
            _this.setPen(_this._currentGS[_this._pageIndex].pen);
            _this.setBrush(_this._currentGS[_this._pageIndex].brush);
            _this._curFont = PdfFont._DEF_PDFKIT_FONT;
            _this.setFont(new PdfFont());
        }, autoPage = false, pdfKitOptions = {
            compress: _this._compress,
            bufferPages: _this._bufferPages,
            pageAdding: _this._ehOnPageAdding = function (doc, options) {
                if (!_this._docInitialized) {
                    autoPage = true;
                    pre(doc);
                }
                _this._onPageAdding(doc, options);
            },
            pageAdded: _this._ehOnPageAdded = function (doc) {
                var brush = _this._isDrawingText()
                    ? _this._currentGS[_this._pageIndex].brush
                    : new PdfSolidBrush();
                _this._currentGS[++_this._pageIndex] = {
                    pen: new PdfPen(),
                    brush: brush
                };
                if (!_this._docInitialized) {
                    post();
                }
                _this._onPageAdded(doc);
            }
        };
        _this._doc = new PDFDocument(pdfKitOptions);
        if (!autoPage) {
            pre(_this._doc);
            post();
        }
        _this._doc
            .on('data', _this._ehOnDocData = function (chunk) { _this._onDocData(chunk); })
            .on('ending', _this._ehOnDocEnding = function () { _this._onDocEnding(); })
            .on('end', _this._ehOnDocEnded = function () { _this._onDocEnded(); });
        _this._docInitialized = true;
        return _this;
    }
    Object.defineProperty(PdfDocument.prototype, "compress", {
        get: function () {
            return this._compress;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfDocument.prototype, "bufferPages", {
        get: function () {
            return this._bufferPages;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfDocument.prototype, "header", {
        get: function () {
            var _this = this;
            if (!this._header) {
                this._header = new PdfRunningTitle({
                    _heightChanged: function () {
                        if (_this._docInitialized) {
                            _this._resetAreasOffset(_this._doc);
                        }
                    }
                });
            }
            return this._header;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfDocument.prototype, "footer", {
        get: function () {
            var _this = this;
            if (!this._footer) {
                this._footer = new PdfRunningTitle({
                    _heightChanged: function () {
                        if (_this._docInitialized) {
                            _this._resetAreasOffset(_this._doc);
                        }
                    }
                });
            }
            return this._footer;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PdfDocument.prototype, "pageIndex", {
        get: function () {
            return this._pageIndex;
        },
        set: function (value) {
            value = wjcCore.asNumber(value, false, true);
            if (this._pageIndex !== value) {
                this._doc.switchToPage(value);
                this._pageIndex = value;
            }
        },
        enumerable: true,
        configurable: true
    });
    PdfDocument.prototype.onEnded = function (args) {
        if (this.ended) {
            this.ended.raise(this, args);
        }
    };
    PdfDocument.prototype.onPageAdded = function (args) {
        if (this.pageAdded) {
            this.pageAdded.raise(this, args);
        }
    };
    PdfDocument.prototype.dispose = function () {
        if (this._doc) {
            this._doc
                .removeEventListener('data', this._ehOnDocData)
                .removeEventListener('ending', this._ehOnDocEnding)
                .removeEventListener('end', this._ehOnDocEnded)
                .removeEventListener('pageAdding', this._ehOnPageAdding)
                .removeEventListener('pageAdded', this._ehOnPageAdded);
            this._doc = null;
            this._chunks = null;
        }
    };
    Object.defineProperty(PdfDocument.prototype, "currentPageSettings", {
        get: function () {
            var page = this._doc.page;
            return {
                layout: page.layout === 'landscape'
                    ? PdfPageOrientation.Landscape
                    : PdfPageOrientation.Portrait,
                size: wjcCore.isArray(page.size)
                    ? new wjcCore.Size(page.size[0], page.size[1])
                    : PdfPageSize[page.size.match(/\d+/) ? page.size : _toTitleCase(page.size)],
                margins: {
                    left: page.margins.left,
                    right: page.margins.right,
                    top: page.margins.top - this.header.height,
                    bottom: page.margins.bottom - this.footer.height
                }
            };
        },
        enumerable: true,
        configurable: true
    });
    PdfDocument.prototype.addPage = function (settings) {
        var native = this._pageSettingsToNative(settings || this.pageSettings);
        this._doc.addPage(native);
        return this;
    };
    PdfDocument.prototype.bufferedPageRange = function () {
        return this._doc.bufferedPageRange();
    };
    PdfDocument.prototype.end = function () {
        this._doc.end();
    };
    PdfDocument.prototype.setBrush = function (brushOrColor) {
        this._assertAreasPathStarted();
        this._setCurBrush(this._defBrush = _asPdfBrush(brushOrColor, false).clone());
        return this;
    };
    PdfDocument.prototype.setPen = function (penOrColor) {
        this._assertAreasPathStarted();
        this._setCurPen(this._defPen = _asPdfPen(penOrColor, false).clone());
        return this;
    };
    PdfDocument.prototype.setFont = function (font) {
        this._setCurFont(this._defFont = _asPdfFont(font, false).clone());
        return this;
    };
    PdfDocument.prototype._getFont = function () {
        return this._curFont;
    };
    PdfDocument.prototype.registerFont = function (font) {
        wjcCore.assert(!!font, exports._Errors.ValueCannotBeEmpty('font'));
        var buffer;
        if (wjcCore.isString(font.source)) {
            var xhrError;
            buffer = _XhrHelper.arrayBuffer(font.source, function (xhr) { return xhrError = xhr.statusText; });
            wjcCore.assert(xhrError == null, xhrError);
        }
        else {
            if (font.source instanceof ArrayBuffer) {
                buffer = font.source;
            }
            else {
                wjcCore.assert(false, exports._Errors.FontSourceMustBeStringArrayBuffer);
            }
        }
        font = _shallowCopy(font);
        font.source = buffer;
        this._fontReg.registerFont(font);
        return this;
    };
    PdfDocument.prototype.registerFontAsync = function (font, callback) {
        var _this = this;
        wjcCore.assert(typeof (font.source) === 'string', exports._Errors.FontSourceMustBeString);
        wjcCore.asFunction(callback, false);
        _XhrHelper.arrayBufferAsync(font.source, function (xhr, buffer) {
            var fnt = _shallowCopy(font);
            fnt.source = buffer;
            _this._fontReg.registerFont(fnt);
            callback(font);
        });
    };
    PdfDocument.prototype.saveState = function () {
        this._assertAreasPathStarted();
        this._graphicsStack.push(this._currentGS[this._pageIndex].pen.clone(), this._defPen.clone(), this._currentGS[this._pageIndex].brush.clone(), this._defBrush.clone());
        this._pdfdoc._document.save();
        return this;
    };
    PdfDocument.prototype.restoreState = function () {
        this._assertAreasPathStarted();
        if (this._graphicsStack.length) {
            this._defBrush = this._graphicsStack.pop();
            this._currentGS[this._pageIndex].brush = this._graphicsStack.pop();
            this._defPen = this._graphicsStack.pop();
            this._currentGS[this._pageIndex].pen = this._graphicsStack.pop();
        }
        this._pdfdoc._document.restore();
        return this;
    };
    PdfDocument.prototype._copy = function (key, value) {
        if (key === 'compress') {
            this._compress = wjcCore.asBoolean(value);
            return true;
        }
        if (key === 'bufferPages') {
            this._bufferPages = wjcCore.asBoolean(value);
            return true;
        }
        if (this._runtimeProperties.indexOf(key) >= 0) {
            return true;
        }
        return false;
    };
    Object.defineProperty(PdfDocument.prototype, "_document", {
        get: function () {
            return this._doc;
        },
        enumerable: true,
        configurable: true
    });
    PdfDocument.prototype._switchTextFlowCtx = function (state) {
        this._doc.x = state.xo;
        this._doc.y = state.yo;
        this._doc.lineGap(state.lineGap);
    };
    PdfDocument.prototype._getTextFlowCtxState = function () {
        return {
            xo: this._doc.x,
            yo: this._doc.y,
            lineGap: this._doc.currentLineGap()
        };
    };
    PdfDocument.prototype._toggleBrush = function (brush) {
        if (brush) {
            this._setCurBrush(brush);
        }
        else {
            this._setCurBrush(this._defBrush);
        }
    };
    PdfDocument.prototype._togglePen = function (pen) {
        if (pen) {
            this._setCurPen(pen);
        }
        else {
            this._setCurPen(this._defPen);
        }
    };
    PdfDocument.prototype._toggleFont = function (font) {
        if (font) {
            this._setCurFont(font);
        }
        else {
            this._setCurFont(this._defFont);
        }
    };
    PdfDocument.prototype._onDocData = function (chunk) {
        this._chunks.push(chunk);
    };
    PdfDocument.prototype._onDocEnding = function () {
        this._processHeadersFooters();
        if (this.info) {
            var v;
            if (v = this.info.author) {
                this._doc.info.Author = v;
            }
            if (v = this.info.creationDate) {
                this._doc.info.CreationDate = v;
            }
            if (v = this.info.keywords) {
                this._doc.info.Keywords = v;
            }
            if (v = this.info.modDate) {
                this._doc.info.ModDate = v;
            }
            if (v = this.info.subject) {
                this._doc.info.Subject = v;
            }
            if (v = this.info.title) {
                this._doc.info.Title = v;
            }
        }
    };
    PdfDocument.prototype._onDocEnded = function () {
        if (exports._IE && this._chunks.length) {
            if (!this._chunks[0].buffer) {
                for (var i = 0; i < this._chunks.length; i++) {
                    var chunk = this._chunks[i], buf = new Uint8Array(chunk.length);
                    for (var j = 0; j < chunk.length; j++) {
                        buf[j] = chunk[j];
                    }
                    this._chunks[i] = buf.buffer;
                }
            }
        }
        this.onEnded(new PdfDocumentEndedEventArgs(this._chunks));
        this._chunks = [];
    };
    PdfDocument.prototype._onPageAdding = function (doc, options) {
        if (this.pageSettings) {
            var native = this._pageSettingsToNative(this.pageSettings);
            options.layout = doc.options.layout = native.layout;
            options.margins = doc.options.margins = native.margins;
            options.size = doc.options.size = native.size;
        }
    };
    PdfDocument.prototype._onPageAdded = function (doc) {
        doc.page.originalMargins = _shallowCopy(doc.page.margins);
        this._resetAreasOffset(doc);
        this.onPageAdded(wjcCore.EventArgs.empty);
    };
    PdfDocument.prototype._assertAreasPathStarted = function () {
        if (!this._docInitialized) {
            return;
        }
        this._assertPathStarted();
        this.header._assertPathStarted();
        this.footer._assertPathStarted();
    };
    PdfDocument.prototype._pageSettingsToNative = function (pageSettings) {
        var res = {};
        if (pageSettings) {
            var layout = wjcCore.asEnum(pageSettings.layout, PdfPageOrientation, true);
            if (layout != null) {
                res.layout = (PdfPageOrientation[layout] || '').toLowerCase();
            }
            var margins = pageSettings.margins;
            if (margins) {
                res.margins = {
                    left: wjcCore.asNumber(margins.left, false, true),
                    right: wjcCore.asNumber(margins.right, false, true),
                    top: wjcCore.asNumber(margins.top, false, true),
                    bottom: wjcCore.asNumber(margins.bottom, false, true)
                };
            }
            var size = pageSettings.size;
            if (size != null) {
                if (size instanceof wjcCore.Size) {
                    res.size = [
                        wjcCore.asNumber(size.width, false, true),
                        wjcCore.asNumber(size.height, false, true)
                    ];
                }
                else {
                    size = wjcCore.asEnum(size, PdfPageSize);
                    res.size = (PdfPageSize[size] || '').toUpperCase();
                }
            }
        }
        return res;
    };
    PdfDocument.prototype._processHeadersFooters = function () {
        var hdr = this.header, ftr = this.footer;
        if (hdr.height > 0 || ftr.height > 0) {
            var doc = this._doc;
            wjcCore.assert(doc.options.bufferPages, exports._Errors.BufferPagesMustBeEnabled);
            var range = doc.bufferedPageRange();
            for (var i = range.start; i < range.count; i++) {
                var frmt = {
                    'Page': i + 1,
                    'Pages': range.count
                };
                this.pageIndex = i;
                this._renderHeaderFooter(hdr, frmt, true);
                this._renderHeaderFooter(ftr, frmt, false);
            }
        }
    };
    PdfDocument.prototype._renderHeaderFooter = function (title, macros, isHeader) {
        if (title.height > 0 && title.declarative && title.declarative.text) {
            var text = _formatMacros(title.declarative.text, macros), parts = text.split('\t');
            if (parts.length > 0 && parts[0]) {
                this._renderHeaderFooterPart(title, parts[0], PdfTextHorizontalAlign.Left, isHeader);
            }
            if (parts.length > 1 && parts[1]) {
                this._renderHeaderFooterPart(title, parts[1], PdfTextHorizontalAlign.Center, isHeader);
            }
            if (parts.length > 2 && parts[2]) {
                this._renderHeaderFooterPart(title, parts[2], PdfTextHorizontalAlign.Right, isHeader);
            }
        }
    };
    PdfDocument.prototype._renderHeaderFooterPart = function (title, text, alignment, isHeader) {
        var textSettings = {
            font: title.declarative.font,
            brush: title.declarative.brush,
            width: title.width,
            height: title.height,
            align: alignment
        };
        if (isHeader) {
            this.header.drawText(text, 0, 0, textSettings);
        }
        else {
            textSettings.includeLastLineExternalLeading = false;
            var sz = this.footer.measureText(text, textSettings.font, textSettings);
            this.footer.drawText(text, 0, this.footer.height - sz.size.height, textSettings);
        }
    };
    PdfDocument.prototype._setCurBrush = function (brush) {
        if (!this._currentGS[this.pageIndex].brush.equals(brush)) {
            this._setNativeDocBrush(brush, false);
            this._currentGS[this.pageIndex].brush = brush.clone();
        }
    };
    PdfDocument.prototype._setCurFont = function (font) {
        if (!this._curFont.equals(font)) {
            var internalName = this._fontReg.findFont(font.family, font.style, font.weight);
            this._doc.font(internalName, font.size || PdfFont._DEF_FONT.size);
            this._curFont = font.clone();
        }
    };
    PdfDocument.prototype._setCurPen = function (pen) {
        var d = this._doc, cp = this._currentGS[this.pageIndex].pen;
        if (pen.brush && (!cp.brush || !cp.brush.equals(pen.brush))) {
            this._setNativeDocBrush(pen.brush, true);
        }
        else {
            if ((cp.brush && !pen.brush) || (!cp.brush && !cp.color.equals(pen.color))) {
                d.strokeColor([pen.color.r, pen.color.g, pen.color.b], pen.color.a);
            }
        }
        if (cp.width !== pen.width) {
            d.lineWidth(pen.width);
        }
        if (cp.miterLimit !== pen.miterLimit) {
            d.miterLimit(pen.miterLimit);
        }
        if (cp.cap !== pen.cap) {
            d.lineCap(pen.cap);
        }
        if (cp.join !== pen.join) {
            d.lineJoin(pen.join);
        }
        if (!cp.dashPattern.equals(pen.dashPattern)) {
            if (pen.dashPattern.dash != null) {
                d.dash(pen.dashPattern.dash, { space: pen.dashPattern.gap, phase: pen.dashPattern.phase });
            }
            else {
                if (cp.dashPattern.dash != null) {
                    d.undash();
                }
            }
        }
        this._currentGS[this.pageIndex].pen = pen.clone();
    };
    PdfDocument.prototype._setNativeDocBrush = function (brush, strokeOrFill) {
        var d = this._doc, nativeColor = brush._getBrushObject(this), opacity = 1;
        if (nativeColor instanceof wjcCore.Color) {
            opacity = nativeColor.a;
            nativeColor = [nativeColor.r, nativeColor.g, nativeColor.b];
        }
        else {
            if (brush instanceof PdfGradientBrush) {
                opacity = brush.opacity;
            }
        }
        if (strokeOrFill) {
            d.strokeColor(nativeColor, opacity);
        }
        else {
            d.fillColor(nativeColor, opacity);
        }
    };
    PdfDocument.prototype._resetAreasOffset = function (doc) {
        doc.page.margins.top = doc.page.originalMargins.top + this.header.height;
        doc.y = doc.page.margins.top;
        doc.page.margins.bottom = doc.page.originalMargins.bottom + this.footer.height;
        this._header._initialize(this, doc.page.margins.left, doc.page.originalMargins.top);
        this._initialize(this, doc.page.margins.left, doc.page.margins.top);
        this._footer._initialize(this, doc.page.margins.left, doc.page.height - doc.page.margins.bottom);
    };
    return PdfDocument;
}(PdfPageArea));
exports.PdfDocument = PdfDocument;
'use strict';
function _compressSpaces(value) {
    if (value) {
        value = value.trim().replace(/\s+/gm, ' ');
    }
    return value;
}
exports._compressSpaces = _compressSpaces;
function _resolveUrlIfRelative(url, urlResolver) {
    if (url && urlResolver && !/(^[a-z][a-z0-9]*:)?\/\//i.test(url)) {
        url = urlResolver(url);
    }
    return url;
}
exports._resolveUrlIfRelative = _resolveUrlIfRelative;
var _SvgCssRule = (function () {
    function _SvgCssRule(selector, declaration) {
        this.selector = selector;
        this.declarations = {};
        this._fillDeclarations(declaration);
    }
    _SvgCssRule.prototype._fillDeclarations = function (declaration) {
        var _this = this;
        if (!declaration) {
            return;
        }
        declaration.split(';').forEach(function (item) {
            if (item) {
                var def = item.split(':');
                if (def.length === 2) {
                    var name = def[0].trim().toLowerCase(), value = def[1].trim();
                    if (name && value) {
                        var important = /!important$/i.test(value);
                        if (important) {
                            value = value.replace(/!important$/i, '').trim();
                        }
                        if (value) {
                            _this.declarations[name] = {
                                value: value,
                                important: important
                            };
                        }
                    }
                }
            }
        });
    };
    return _SvgCssRule;
}());
exports._SvgCssRule = _SvgCssRule;
var _SvgCssHelper = (function () {
    function _SvgCssHelper() {
    }
    _SvgCssHelper.matchesSelector = function (node, selector) {
        var res = false;
        try {
            var fn = node.matches || node.msMatchesSelector || node.webkitMatchesSelector || node.mozMatchesSelector;
            res = fn.call(node, selector);
        }
        catch (ex) { }
        return res;
    };
    _SvgCssHelper.getSpecificity = function (selector) {
        var a = 0, b = 0, c = 0, match = function (rg) {
            var match = (selector.match(rg) || []).length;
            if (match) {
                selector = selector.replace(rg, '');
            }
            return match;
        };
        selector = selector.replace(/:not\(([^\)]*)\)/g, function (match, g1) {
            return ' ' + g1 + ' ';
        });
        b += match(/(\[[^\]]+\])/g);
        a += match(/(#[^\s\+>~\.\[:]+)/g);
        b += match(/(\.[^\s\+>~\.\[:]+)/g);
        c += match(/(::[^\s\+>~\.\[:]+|:first-line|:first-letter|:before|:after)/gi);
        b += match(/(:[\w-]+\([^\)]*\))/gi);
        b += match(/(:[^\s\+>~\.\[:]+)/g);
        selector = selector.replace(/[\*\s\+>~]/g, ' ');
        selector = selector.replace(/[#\.]/g, ' ');
        c += match(/([^\s\+>~\.\[:]+)/g);
        return (a << 16) | (b << 8) | c;
    };
    _SvgCssHelper.getComputedStyle = function (node, registeredRules) {
        var _this = this;
        var composite = {}, associatedRules = [];
        if (node.className) {
            var associatedRules = [];
            for (var i = 0, keys = Object.keys(registeredRules); i < keys.length; i++) {
                var selector = keys[i];
                if (this.matchesSelector(node, selector)) {
                    associatedRules.push(registeredRules[selector]);
                }
            }
        }
        associatedRules.sort(function (a, b) { return _this.getSpecificity(a.selector) - _this.getSpecificity(b.selector); });
        var inline = node.getAttribute('style');
        if (inline) {
            associatedRules.push(new _SvgCssRule('_inline_', _compressSpaces(inline)));
        }
        for (var i = 0; i < associatedRules.length; i++) {
            var rule = associatedRules[i];
            for (var j = 0, keys = Object.keys(rule.declarations); j < keys.length; j++) {
                var name = keys[j], val = rule.declarations[name];
                if ((composite[name] == null) || (val.important || !composite[name].important)) {
                    composite[name] = val;
                }
            }
        }
        var result = {};
        for (var i = 0, keys = Object.keys(composite); i < keys.length; i++) {
            var name = keys[i];
            result[name] = composite[name].value;
        }
        return result;
    };
    _SvgCssHelper.registerFontFace = function (doc, rule, urlResolver) {
        var rd = rule.declarations;
        if (!rd['font-family'] || !rd['src']) {
            return;
        }
        rd['src'].value.split(',').every(function (url) {
            if (url.match(/format\(\s*['"]?truetype['"]?\s*\)/i)) {
                var match = url.match(/url\(\s*['"]?([^'"\)]+)['"]?\s*\)/i);
                if (match) {
                    var src = match[1].trim(), success = false;
                    if (src = _resolveUrlIfRelative(src, urlResolver)) {
                        var font = {
                            name: rd['font-family'].value,
                            source: src,
                            weight: rd['font-weight'] ? rd['font-weight'].value.toLowerCase() : 'normal',
                            style: rd['font-style'] ? rd['font-style'].value.toLowerCase() : 'normal'
                        };
                        try {
                            doc.registerFont(font);
                            success = true;
                        }
                        catch (ex) { }
                    }
                    return !success;
                }
            }
            return true;
        });
    };
    return _SvgCssHelper;
}());
exports._SvgCssHelper = _SvgCssHelper;
'use strict';
var _SvgNumConversion;
(function (_SvgNumConversion) {
    _SvgNumConversion[_SvgNumConversion["Default"] = 1] = "Default";
    _SvgNumConversion[_SvgNumConversion["None"] = 2] = "None";
    _SvgNumConversion[_SvgNumConversion["Px"] = 3] = "Px";
})(_SvgNumConversion = exports._SvgNumConversion || (exports._SvgNumConversion = {}));
var _SvgLengthContext;
(function (_SvgLengthContext) {
    _SvgLengthContext[_SvgLengthContext["Width"] = 1] = "Width";
    _SvgLengthContext[_SvgLengthContext["Height"] = 2] = "Height";
    _SvgLengthContext[_SvgLengthContext["Other"] = 3] = "Other";
})(_SvgLengthContext = exports._SvgLengthContext || (exports._SvgLengthContext = {}));
var _SvgAttrType;
(function (_SvgAttrType) {
    _SvgAttrType[_SvgAttrType["Number"] = 1] = "Number";
    _SvgAttrType[_SvgAttrType["String"] = 2] = "String";
})(_SvgAttrType = exports._SvgAttrType || (exports._SvgAttrType = {}));
var _SvgAttr = (function () {
    function _SvgAttr(owner, propName, propType, defValue, nc, lCtx, inheritable) {
        if (defValue === void 0) { defValue = undefined; }
        if (nc === void 0) { nc = _SvgNumConversion.Default; }
        if (lCtx === void 0) { lCtx = _SvgLengthContext.Other; }
        if (inheritable === void 0) { inheritable = false; }
        wjcCore.assert(!!owner, exports._Errors.ValueCannotBeEmpty('owner'));
        wjcCore.assert(!!propName, exports._Errors.ValueCannotBeEmpty('propName'));
        this._owner = owner;
        this._propName = propName;
        this._propType = propType;
        this._defValue = defValue;
        this._inheritable = inheritable;
        this._nc = nc;
        this._pCtx = lCtx;
        this._searchValue = true;
    }
    _SvgAttr.parseValue = function (value, attrType, viewPort, lCtx, numConv) {
        if (value == null) {
            return value;
        }
        if (attrType & _SvgAttrType.Number) {
            var numVal, unitType;
            if (typeof (value) === 'number') {
                numVal = value;
            }
            else {
                var match = value.match(/^([\+-]?[\d\.]+)(em|ex|px|pt|pc|cm|mm|in|%)?$/);
                if (match) {
                    numVal = parseFloat(match[1]);
                    unitType = match[2];
                }
            }
            if (numVal != null && numVal === numVal) {
                if (numConv !== _SvgNumConversion.Default) {
                    wjcCore.assert(!unitType, exports._Errors.InvalidFormat(value));
                    if (numConv === _SvgNumConversion.None) {
                        return numVal;
                    }
                }
                switch (unitType) {
                    case 'mm':
                        return numVal * 72 / 25.4;
                    case 'cm':
                        return numVal * 72 / 2.54;
                    case 'in':
                        return numVal * 72;
                    case 'pt':
                        return numVal;
                    case 'pc':
                        return numVal * 12;
                    case '%':
                        switch (lCtx) {
                            case _SvgLengthContext.Height:
                                numVal *= viewPort.height / 100;
                                break;
                            case _SvgLengthContext.Width:
                                numVal *= viewPort.width / 100;
                                break;
                            case _SvgLengthContext.Other:
                                numVal *= (Math.sqrt(viewPort.width * viewPort.width + viewPort.height * viewPort.height) / Math.sqrt(2)) / 100;
                                break;
                        }
                        return numVal;
                    case 'px':
                    default:
                        return numVal * 0.75;
                }
            }
        }
        if (attrType & _SvgAttrType.String) {
            return value + '';
        }
        wjcCore.assert(false, exports._Errors.InvalidFormat(value));
    };
    Object.defineProperty(_SvgAttr.prototype, "hasVal", {
        get: function () {
            return this._val != null;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(_SvgAttr.prototype, "val", {
        get: function () {
            if (this._val != null) {
                return this._val;
            }
            else {
                var value = wjcCore.isFunction(this._defValue) ? this._defValue.call(this, this._owner.ctx) : this._defValue;
                return this._parse(value);
            }
        },
        set: function (value) {
            this._searchValue = false;
            this._value = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(_SvgAttr.prototype, "_val", {
        get: function () {
            if (this._searchValue) {
                this._searchValue = false;
                var value;
                for (var p = this._owner; p; p = p.parent) {
                    value = p.attr(this._propName);
                    if (!(this._inheritable && (value == null || value == 'inherit'))) {
                        break;
                    }
                }
                this._value = (value === 'inherit') ? undefined : this._parse(value);
            }
            return this._value;
        },
        enumerable: true,
        configurable: true
    });
    _SvgAttr.prototype.reset = function () {
        this._value = undefined;
        this._searchValue = true;
    };
    _SvgAttr.prototype._parse = function (value, nc) {
        var value = _SvgAttr.parseValue(value, this._propType, this._owner.viewport, this._pCtx, nc || this._nc);
        return value;
    };
    return _SvgAttr;
}());
exports._SvgAttr = _SvgAttr;
var _SvgNumAttr = (function (_super) {
    __extends(_SvgNumAttr, _super);
    function _SvgNumAttr(owner, propName, defValue, nc, pCtx, inheritable) {
        if (defValue === void 0) { defValue = undefined; }
        if (nc === void 0) { nc = _SvgNumConversion.Default; }
        if (pCtx === void 0) { pCtx = _SvgLengthContext.Other; }
        return _super.call(this, owner, propName, _SvgAttrType.Number, defValue, nc, pCtx, inheritable) || this;
    }
    return _SvgNumAttr;
}(_SvgAttr));
exports._SvgNumAttr = _SvgNumAttr;
var _SvgStrAttr = (function (_super) {
    __extends(_SvgStrAttr, _super);
    function _SvgStrAttr(owner, propName, defValue, inheritable) {
        return _super.call(this, owner, propName, _SvgAttrType.String, defValue, undefined, undefined, inheritable) || this;
    }
    return _SvgStrAttr;
}(_SvgAttr));
exports._SvgStrAttr = _SvgStrAttr;
var _SvgColorAttr = (function (_super) {
    __extends(_SvgColorAttr, _super);
    function _SvgColorAttr(owner, propName, defValue, inheritable) {
        if (defValue === void 0) { defValue = undefined; }
        if (inheritable === void 0) { inheritable = true; }
        return _super.call(this, owner, propName, _SvgAttrType.String, defValue, _SvgNumConversion.None, _SvgLengthContext.Other, inheritable) || this;
    }
    _SvgColorAttr.prototype.asHref = function () {
        var match = this.val.match(/url\((.+)\)/);
        if (match) {
            return match[1];
        }
        return null;
    };
    _SvgColorAttr.prototype._parse = function (value) {
        if (value === '' || value === 'null' || value === 'undefined') {
            return undefined;
        }
        return _super.prototype._parse.call(this, value);
    };
    return _SvgColorAttr;
}(_SvgAttr));
exports._SvgColorAttr = _SvgColorAttr;
var _SvgDashArrayAttr = (function (_super) {
    __extends(_SvgDashArrayAttr, _super);
    function _SvgDashArrayAttr(owner) {
        return _super.call(this, owner, 'stroke-dasharray', _SvgAttrType.Number, undefined, _SvgNumConversion.Px, _SvgLengthContext.Other, true) || this;
    }
    _SvgDashArrayAttr.prototype._parse = function (value) {
        var res, vals = (value || '').trim().split(/[\s,]+/);
        if (vals.length) {
            res = [];
            try {
                for (var i = 0; i < vals.length; i++) {
                    if (vals[i]) {
                        res.push(_super.prototype._parse.call(this, vals[i]));
                    }
                }
            }
            catch (ex) {
                return undefined;
            }
            return res.length ? res : undefined;
        }
        return res;
    };
    return _SvgDashArrayAttr;
}(_SvgAttr));
exports._SvgDashArrayAttr = _SvgDashArrayAttr;
var _SvgFillRuleAttr = (function (_super) {
    __extends(_SvgFillRuleAttr, _super);
    function _SvgFillRuleAttr(owner, propName) {
        return _super.call(this, owner, propName, _SvgAttrType.String, PdfFillRule.NonZero, undefined, undefined, true) || this;
    }
    _SvgFillRuleAttr.prototype._parse = function (value) {
        if (wjcCore.isNumber(value)) {
            return value;
        }
        else {
            var match = (value || '').match(/(nonzero|evenodd)/i);
            if (match) {
                return match[1] === 'nonzero' ? PdfFillRule.NonZero : PdfFillRule.EvenOdd;
            }
            return undefined;
        }
    };
    return _SvgFillRuleAttr;
}(_SvgAttr));
exports._SvgFillRuleAttr = _SvgFillRuleAttr;
var _SvgHRefAttr = (function (_super) {
    __extends(_SvgHRefAttr, _super);
    function _SvgHRefAttr(owner, propName) {
        return _super.call(this, owner, propName) || this;
    }
    _SvgHRefAttr.prototype._parse = function (value) {
        value = (value || '').trim();
        var match = value.match(/url\((.+)\)/);
        if (match) {
            value = match[1].trim();
        }
        value = value.replace(/["']/g, '');
        return value;
    };
    return _SvgHRefAttr;
}(_SvgStrAttr));
exports._SvgHRefAttr = _SvgHRefAttr;
var _SvgIdRefAttr = (function (_super) {
    __extends(_SvgIdRefAttr, _super);
    function _SvgIdRefAttr() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    _SvgIdRefAttr.prototype._parse = function (value) {
        value = _super.prototype._parse.call(this, value);
        if (value && value[0] === '#') {
            return value.substring(1);
        }
        return undefined;
    };
    return _SvgIdRefAttr;
}(_SvgHRefAttr));
exports._SvgIdRefAttr = _SvgIdRefAttr;
var _SvgPointsArrayAttr = (function (_super) {
    __extends(_SvgPointsArrayAttr, _super);
    function _SvgPointsArrayAttr(owner, propName) {
        return _super.call(this, owner, propName, _SvgAttrType.Number, undefined, _SvgNumConversion.Px) || this;
    }
    _SvgPointsArrayAttr.prototype._parse = function (value) {
        var res, vals = (value || '').trim().split(/[\s,]+/), len = Math.floor(vals.length / 2) * 2;
        if (len) {
            res = [];
            try {
                for (var i = 0; i < len - 1; i = i + 2) {
                    res.push(new wjcCore.Point(_super.prototype._parse.call(this, vals[i]), _super.prototype._parse.call(this, vals[i + 1])));
                }
            }
            catch (ex) {
                return undefined;
            }
        }
        return res;
    };
    return _SvgPointsArrayAttr;
}(_SvgAttr));
exports._SvgPointsArrayAttr = _SvgPointsArrayAttr;
var _SvgTransformAttr = (function (_super) {
    __extends(_SvgTransformAttr, _super);
    function _SvgTransformAttr(owner) {
        return _super.call(this, owner, 'transform', _SvgAttrType.Number, undefined, _SvgNumConversion.None) || this;
    }
    _SvgTransformAttr.prototype.apply = function (element) {
        var area = element.ctx.area;
        if (this.hasVal) {
            this.val.forEach(function (item) {
                item(area);
            });
        }
    };
    _SvgTransformAttr.prototype._parse = function (value) {
        var _this = this;
        var res = [], match = (value || '').match(/((matrix|translate|scale|rotate|skewX|skewY)\([^\)]+\))+/g);
        if (match) {
            for (var i = 0; i < match.length; i++) {
                var item = match[i], sgnr = item.match(/(\w+)\(([^\)]+)\)/), args = [];
                try {
                    sgnr[2].trim().split(/[\s,]+/).forEach(function (numStr) {
                        if (numStr) {
                            args.push(_super.prototype._parse.call(_this, numStr, _SvgNumConversion.None));
                        }
                    });
                }
                catch (ex) {
                    return undefined;
                }
                if (args.length) {
                    switch (sgnr[1]) {
                        case 'matrix':
                            res.push((function (a, b, c, d, e, f) {
                                return function (area) {
                                    area.transform(a, b, c, d, e, f);
                                };
                            })(args[0], args[1], args[2], args[3], _super.prototype._parse.call(this, args[4], _SvgNumConversion.Px), _super.prototype._parse.call(this, args[5], _SvgNumConversion.Px)));
                            break;
                        case 'translate':
                            res.push((function (x, y) {
                                return function (area) {
                                    area.translate(x, y);
                                };
                            })(_super.prototype._parse.call(this, args[0], _SvgNumConversion.Px), _super.prototype._parse.call(this, args[1] || 0, _SvgNumConversion.Px)));
                            break;
                        case 'scale':
                            res.push((function (xFactor, yFactor) {
                                return function (area) {
                                    area.scale(xFactor, yFactor);
                                };
                            })(args[0], args[1]));
                            break;
                        case 'rotate':
                            res.push((function (angle, point) {
                                return function (area) {
                                    area.rotate(angle, point);
                                };
                            })(args[0], new wjcCore.Point(_super.prototype._parse.call(this, args[1] || 0, _SvgNumConversion.Px), _super.prototype._parse.call(this, args[2] || 0, _SvgNumConversion.Px))));
                            break;
                        case 'skewX':
                            res.push((function (angle) {
                                return function (area) {
                                    area.transform(1, 0, angle, 1, 0, 0);
                                };
                            })(Math.tan(args[0] * Math.PI / 180)));
                            break;
                        case 'skewY':
                            res.push((function (angle) {
                                return function (area) {
                                    area.transform(1, angle, 0, 1, 0, 0);
                                };
                            })(Math.tan(args[0] * Math.PI / 180)));
                            break;
                    }
                }
            }
        }
        return res.length ? res : undefined;
    };
    return _SvgTransformAttr;
}(_SvgAttr));
exports._SvgTransformAttr = _SvgTransformAttr;
var _SvgTextDecorationAttr = (function (_super) {
    __extends(_SvgTextDecorationAttr, _super);
    function _SvgTextDecorationAttr(owner) {
        return _super.call(this, owner, 'text-decoration', _SvgAttrType.String, undefined, _SvgNumConversion.None) || this;
    }
    _SvgTextDecorationAttr.prototype._parse = function (value) {
        var res, vals = (value || '').trim().toLowerCase().split(/[\s,]+/);
        if (vals.length) {
            res = [];
            for (var i = 0; i < vals.length; i++) {
                if (/line-through|overline|underline/.test(vals[i])) {
                    res.push(vals[i]);
                }
            }
        }
        return res && res.length ? res : undefined;
    };
    return _SvgTextDecorationAttr;
}(_SvgAttr));
exports._SvgTextDecorationAttr = _SvgTextDecorationAttr;
var _SvgViewboxAttr = (function (_super) {
    __extends(_SvgViewboxAttr, _super);
    function _SvgViewboxAttr(owner) {
        return _super.call(this, owner, 'viewBox', _SvgAttrType.Number, undefined, _SvgNumConversion.Px) || this;
    }
    _SvgViewboxAttr.prototype._parse = function (value) {
        var res, vals = (value || '').trim().split(/[\s,]+/);
        if (vals.length === 4) {
            res = {
                minX: _super.prototype._parse.call(this, vals[0]),
                minY: _super.prototype._parse.call(this, vals[1]),
                width: _super.prototype._parse.call(this, vals[2]),
                height: _super.prototype._parse.call(this, vals[3])
            };
        }
        return res;
    };
    return _SvgViewboxAttr;
}(_SvgAttr));
exports._SvgViewboxAttr = _SvgViewboxAttr;
var _SvgPreserveAspectRatioAttr = (function (_super) {
    __extends(_SvgPreserveAspectRatioAttr, _super);
    function _SvgPreserveAspectRatioAttr(owner) {
        return _super.call(this, owner, 'preserveAspectRatio', _SvgAttrType.Number, 'xMidYMid meet') || this;
    }
    _SvgPreserveAspectRatioAttr.prototype._parse = function (value) {
        var res;
        if (typeof (value) === 'string') {
            var vals = value.replace(/^defer\s+/, '').trim().split(/\s+/);
            res = {
                align: vals[0],
                meet: !vals[1] || (vals[1] === 'meet')
            };
        }
        else {
            res = value;
        }
        return res;
    };
    return _SvgPreserveAspectRatioAttr;
}(_SvgAttr));
exports._SvgPreserveAspectRatioAttr = _SvgPreserveAspectRatioAttr;
var _SvgScaleAttributes = (function () {
    function _SvgScaleAttributes(owner) {
        this._owner = owner;
        this.aspect = new _SvgPreserveAspectRatioAttr(this._owner);
        this.viewBox = new _SvgViewboxAttr(this._owner);
    }
    _SvgScaleAttributes.prototype.apply = function (element) {
        var area = element.ctx.area, viewPort = element.viewport, viewBox = this.viewBox.val;
        if (viewPort && viewBox) {
            if (viewBox.width && viewBox.height) {
                var ar = this.aspect.val, sx = viewPort.width / viewBox.width, sy = viewPort.height / viewBox.height, sMin = Math.min(sx, sy), sMax = Math.max(sx, sy), uniScaledWidth = viewBox.width * (ar.meet ? sMin : sMax), uniScaledHeight = viewBox.height * (ar.meet ? sMin : sMax);
                if (ar.align === 'none') {
                    area.scale(sx, sy);
                }
                else {
                    var scale = ar.meet ? sMin : sMax, tx = 0, ty = 0;
                    if (ar.align.match(/^xMid/) && (scale === sy)) {
                        tx = viewPort.width / 2 - uniScaledWidth / 2;
                    }
                    else {
                        if (ar.align.match(/^xMax/) && (scale === sy)) {
                            tx = viewPort.width - uniScaledWidth;
                        }
                    }
                    if (ar.align.match(/YMid$/) && (scale === sx)) {
                        ty = viewPort.height / 2 - uniScaledHeight / 2;
                    }
                    else {
                        if (ar.align.match(/YMax$/) && (scale === sx)) {
                            ty = viewPort.height - uniScaledHeight;
                        }
                    }
                    if (tx || ty) {
                        area.translate(tx, ty);
                    }
                    if (ar.meet) {
                        area.scale(sMin, sMin);
                    }
                    else {
                        area.scale(sMax, sMax);
                    }
                    if (viewBox.minX || viewBox.minY) {
                        area.translate(-viewBox.minX, -viewBox.minY);
                    }
                }
            }
            return new wjcCore.Size(viewBox.width, viewBox.height);
        }
        return viewPort;
    };
    return _SvgScaleAttributes;
}());
exports._SvgScaleAttributes = _SvgScaleAttributes;
var _SvgStrokeAttributes = (function () {
    function _SvgStrokeAttributes(owner) {
        this._owner = owner;
        this.color = new _SvgColorAttr(this._owner, 'stroke', 'none');
        this.dashArray = new _SvgDashArrayAttr(this._owner);
        this.dashOffset = new _SvgNumAttr(this._owner, 'stroke-dashoffset', 0, _SvgNumConversion.Default, _SvgLengthContext.Other, true);
        this.lineCap = new _SvgStrAttr(this._owner, 'stroke-linecap', 'butt', true);
        this.lineJoin = new _SvgStrAttr(this._owner, 'stroke-linejoin', 'miter', true);
        this.miterLimit = new _SvgNumAttr(this._owner, 'stroke-miterlimit', 4, _SvgNumConversion.None, _SvgLengthContext.Other, true);
        this.opacity = new _SvgNumAttr(this._owner, 'stroke-opacity', 1, _SvgNumConversion.None, _SvgLengthContext.Other, true);
        this.width = new _SvgNumAttr(this._owner, 'stroke-width', 1, _SvgNumConversion.Default, _SvgLengthContext.Other, true);
    }
    _SvgStrokeAttributes.prototype.toPen = function (element) {
        var color = new wjcCore.Color(this.color.val);
        if (this.opacity.hasVal) {
            color.a = this.opacity.val;
        }
        var pen = new PdfPen(color, this.width.val);
        if (this.dashArray.hasVal) {
            var dashes = this.dashArray.val;
            if (dashes.length) {
                pen.dashPattern = new PdfDashPattern(dashes[0], dashes.length > 1 ? dashes[1] : undefined, this.dashOffset.val);
            }
        }
        switch (this.lineCap.val) {
            case 'butt':
                pen.cap = PdfLineCapStyle.Butt;
                break;
            case 'round':
                pen.cap = PdfLineCapStyle.Round;
                break;
            case 'square':
                pen.cap = PdfLineCapStyle.Square;
                break;
        }
        switch (this.lineJoin.val) {
            case 'miter':
                pen.join = PdfLineJoinStyle.Miter;
                break;
            case 'round':
                pen.join = PdfLineJoinStyle.Round;
                break;
            case 'bevel':
                pen.join = PdfLineJoinStyle.Bevel;
                break;
        }
        pen.miterLimit = this.miterLimit.val;
        return pen;
    };
    return _SvgStrokeAttributes;
}());
exports._SvgStrokeAttributes = _SvgStrokeAttributes;
var _SvgFillAttributes = (function () {
    function _SvgFillAttributes(owner) {
        this._owner = owner;
        this.color = new _SvgColorAttr(this._owner, 'fill', 'black');
        this.opacity = new _SvgNumAttr(this._owner, 'fill-opacity', 1, _SvgNumConversion.None, undefined, true);
        this.rule = new _SvgFillRuleAttr(this._owner, 'fill-rule');
    }
    _SvgFillAttributes.prototype.toBrush = function (element) {
        var color;
        var href = this.color.asHref();
        if (href && element) {
            var gradient = element.ctx.getElement(href);
            if (gradient instanceof _SvgLinearGradientElementImpl) {
                return gradient.toBrush(element);
            }
        }
        color = new wjcCore.Color(this.color.val);
        if (this.opacity.hasVal) {
            color.a = this.opacity.val;
        }
        return new PdfSolidBrush(color);
    };
    return _SvgFillAttributes;
}());
exports._SvgFillAttributes = _SvgFillAttributes;
var _SvgFontAttributes = (function () {
    function _SvgFontAttributes(owner) {
        this._owner = owner;
        this.family = new _SvgStrAttr(this._owner, 'font-family', function (ctx) {
            var font = ctx.area._pdfdoc._getFont();
            return font ? font.family : undefined;
        }, true);
        this.size = new _SvgAttr(this._owner, 'font-size', _SvgAttrType.Number | _SvgAttrType.String, 'medium', undefined, _SvgLengthContext.Other, true);
        this.style = new _SvgStrAttr(this._owner, 'font-style', 'normal', true);
        this.weight = new _SvgStrAttr(this._owner, 'font-weight', 'normal', true);
    }
    _SvgFontAttributes.prototype.toFont = function () {
        var size = _asPt(this.size.val);
        return new PdfFont(this.family.val, size, this.style.val, this.weight.val);
    };
    return _SvgFontAttributes;
}());
exports._SvgFontAttributes = _SvgFontAttributes;
var _SvgStyleAttributes = (function () {
    function _SvgStyleAttributes(owner) {
        this._owner = owner;
        this.clipRule = new _SvgFillRuleAttr(this._owner, 'clip-rule');
        this.fill = new _SvgFillAttributes(this._owner);
        this.font = new _SvgFontAttributes(this._owner);
        this.stroke = new _SvgStrokeAttributes(this._owner);
    }
    _SvgStyleAttributes.prototype.apply = function (element, fill, stroke) {
        var area = element.ctx.area;
        if (element.renderMode === _SvgRenderMode.Clip) {
        }
        else {
            if (fill && stroke && this.fill.color.val !== 'none' && this.stroke.color.val !== 'none') {
                area.paths.fillAndStroke(this.fill.toBrush(element), this.stroke.toPen(element), this.fill.rule.val);
            }
            else {
                if (fill && (this.fill.color.val !== 'none')) {
                    area.paths.fill(this.fill.toBrush(element), this.fill.rule.val);
                }
                else {
                    if (stroke && (this.stroke.color.val !== 'none')) {
                        area.paths.stroke(this.stroke.toPen(element));
                    }
                    else {
                        area.paths.stroke(wjcCore.Color.fromRgba(0, 0, 0, 0));
                    }
                }
            }
        }
    };
    return _SvgStyleAttributes;
}());
exports._SvgStyleAttributes = _SvgStyleAttributes;
'use strict';
var _SvgRenderMode;
(function (_SvgRenderMode) {
    _SvgRenderMode[_SvgRenderMode["Render"] = 0] = "Render";
    _SvgRenderMode[_SvgRenderMode["Ignore"] = 1] = "Ignore";
    _SvgRenderMode[_SvgRenderMode["Clip"] = 2] = "Clip";
})(_SvgRenderMode = exports._SvgRenderMode || (exports._SvgRenderMode = {}));
var _SvgElementBase = (function () {
    function _SvgElementBase(ctx, node, defRenderMode) {
        if (defRenderMode === void 0) { defRenderMode = _SvgRenderMode.Render; }
        this._children = [];
        this._attributes = {};
        this._defRenderMode = defRenderMode;
        this._ctx = ctx;
    }
    Object.defineProperty(_SvgElementBase.prototype, "children", {
        get: function () {
            return this._children;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(_SvgElementBase.prototype, "ctx", {
        get: function () {
            return this._ctx;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(_SvgElementBase.prototype, "parent", {
        get: function () {
            return this._parent;
        },
        set: function (value) {
            this._parent = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(_SvgElementBase.prototype, "style", {
        get: function () {
            if (!this._style) {
                this._style = new _SvgStyleAttributes(this);
            }
            return this._style;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(_SvgElementBase.prototype, "viewport", {
        get: function () {
            return this._viewport;
        },
        set: function (value) {
            this._viewport = value.clone();
        },
        enumerable: true,
        configurable: true
    });
    _SvgElementBase.prototype.attr = function (name, value) {
        name = name.toLowerCase();
        if (arguments.length > 1) {
            this._attributes[name] = value;
        }
        return this._attributes[name];
    };
    _SvgElementBase.prototype.appendNode = function (node) {
        if (!node || (node === this)) {
            return;
        }
        if (node.parent !== this) {
            node.remove();
            this.children.push(node);
            node.parent = this;
        }
    };
    _SvgElementBase.prototype.copyAttributesFrom = function (el, except) {
        if (!el) {
            return;
        }
        var fa = el._attributes, ta = this._attributes;
        for (var key in fa) {
            if (fa.hasOwnProperty(key) && (ta[key] == null) && (!except || (except.indexOf(key) < 0))) {
                ta[key] = fa[key];
            }
        }
    };
    _SvgElementBase.prototype.clone = function () {
        var el = new (Function.prototype.bind.call(this.constructor, null, this.ctx, null));
        el.copyAttributesFrom(this);
        this._children.forEach(function (item) {
            el.appendNode(item.clone());
        });
        return el;
    };
    _SvgElementBase.prototype.remove = function () {
        var p = this.parent;
        if (p) {
            for (var i = 0; i < p.children.length; i++) {
                if (p.children[i] === this) {
                    p.children.splice(i, 1);
                    break;
                }
            }
            this.parent = null;
        }
    };
    _SvgElementBase.prototype.clearAttr = function (name) {
        delete this._attributes[name.toLowerCase()];
    };
    _SvgElementBase.prototype.render = function (viewPort, renderMode) {
        this._viewport = viewPort.clone();
        if ((this._curRenderMode = renderMode || this._defRenderMode) !== _SvgRenderMode.Ignore) {
            this._render();
        }
    };
    Object.defineProperty(_SvgElementBase.prototype, "renderMode", {
        get: function () {
            return this._curRenderMode;
        },
        enumerable: true,
        configurable: true
    });
    _SvgElementBase.prototype._render = function () {
        this._renderContent();
    };
    _SvgElementBase.prototype._renderContent = function () {
        for (var i = 0; i < this._children.length; i++) {
            this._children[i].render(this.viewport, this.renderMode);
        }
    };
    return _SvgElementBase;
}());
exports._SvgElementBase = _SvgElementBase;
var _SvgClippableElementBase = (function (_super) {
    __extends(_SvgClippableElementBase, _super);
    function _SvgClippableElementBase(ctx, node, defRenderMode) {
        if (defRenderMode === void 0) { defRenderMode = _SvgRenderMode.Render; }
        var _this = _super.call(this, ctx, node, defRenderMode) || this;
        _this._clipPath = new _SvgIdRefAttr(_this, 'clip-path');
        return _this;
    }
    _SvgClippableElementBase.prototype._render = function () {
        var clip, area = this.ctx.area;
        if (this._clipPath.val) {
            var clipPath = this.ctx.getElement(this._clipPath.val);
            if (clip = !!(clipPath && (clipPath instanceof _SvgClipPathElementImpl))) {
                area._pdfdoc.saveState();
                clipPath.render(this.viewport, _SvgRenderMode.Clip);
                area.paths.clip(this.style.clipRule.val);
            }
        }
        _super.prototype._render.call(this);
        if (clip) {
            area._pdfdoc.restoreState();
        }
    };
    return _SvgClippableElementBase;
}(_SvgElementBase));
exports._SvgClippableElementBase = _SvgClippableElementBase;
var _SvgTransformableElementBase = (function (_super) {
    __extends(_SvgTransformableElementBase, _super);
    function _SvgTransformableElementBase(ctx, node) {
        var _this = _super.call(this, ctx, node) || this;
        _this._transform = new _SvgTransformAttr(_this);
        return _this;
    }
    _SvgTransformableElementBase.prototype._render = function () {
        var transform = this._transform.hasVal && this.renderMode !== _SvgRenderMode.Clip;
        if (transform) {
            this.ctx.area._pdfdoc.saveState();
            this._transform.apply(this);
        }
        _super.prototype._render.call(this);
        if (transform) {
            this.ctx.area._pdfdoc.restoreState();
        }
    };
    return _SvgTransformableElementBase;
}(_SvgClippableElementBase));
exports._SvgTransformableElementBase = _SvgTransformableElementBase;
var _SvgShapeElementBase = (function (_super) {
    __extends(_SvgShapeElementBase, _super);
    function _SvgShapeElementBase() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._fill = true;
        _this._stroke = true;
        return _this;
    }
    _SvgShapeElementBase.prototype._renderContent = function () {
        this._draw();
        this.style.apply(this, this._fill, this._stroke);
    };
    _SvgShapeElementBase.prototype._draw = function () {
        wjcCore.assert(false, exports._Errors.AbstractMethod);
    };
    return _SvgShapeElementBase;
}(_SvgTransformableElementBase));
exports._SvgShapeElementBase = _SvgShapeElementBase;
var _SvgCircleElementImpl = (function (_super) {
    __extends(_SvgCircleElementImpl, _super);
    function _SvgCircleElementImpl() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    _SvgCircleElementImpl.prototype._draw = function () {
        var r = new _SvgNumAttr(this, 'r', 0).val;
        if (r > 0) {
            var cx = new _SvgNumAttr(this, 'cx', 0, _SvgNumConversion.Default, _SvgLengthContext.Width).val, cy = new _SvgNumAttr(this, 'cy', 0, _SvgNumConversion.Default, _SvgLengthContext.Height).val;
            this.ctx.area.paths.circle(cx, cy, r);
        }
    };
    return _SvgCircleElementImpl;
}(_SvgShapeElementBase));
exports._SvgCircleElementImpl = _SvgCircleElementImpl;
var _SvgEllipseElementImpl = (function (_super) {
    __extends(_SvgEllipseElementImpl, _super);
    function _SvgEllipseElementImpl() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    _SvgEllipseElementImpl.prototype._draw = function () {
        var rx = new _SvgNumAttr(this, 'rx', 0, _SvgNumConversion.Default, _SvgLengthContext.Width).val, ry = new _SvgNumAttr(this, 'ry', 0, _SvgNumConversion.Default, _SvgLengthContext.Height).val;
        if (rx > 0 && ry > 0) {
            var cx = new _SvgNumAttr(this, 'cx', 0, _SvgNumConversion.Default, _SvgLengthContext.Width).val, cy = new _SvgNumAttr(this, 'cy', 0, _SvgNumConversion.Default, _SvgLengthContext.Height).val;
            this.ctx.area.paths.ellipse(cx, cy, rx, ry);
        }
    };
    return _SvgEllipseElementImpl;
}(_SvgShapeElementBase));
exports._SvgEllipseElementImpl = _SvgEllipseElementImpl;
var _SvgLineElementImpl = (function (_super) {
    __extends(_SvgLineElementImpl, _super);
    function _SvgLineElementImpl(ctx, node) {
        var _this = _super.call(this, ctx, node) || this;
        _this._fill = false;
        return _this;
    }
    _SvgLineElementImpl.prototype._draw = function () {
        var x1 = new _SvgNumAttr(this, 'x1', 0, _SvgNumConversion.Default, _SvgLengthContext.Width).val, y1 = new _SvgNumAttr(this, 'y1', 0, _SvgNumConversion.Default, _SvgLengthContext.Height).val, x2 = new _SvgNumAttr(this, 'x2', 0, _SvgNumConversion.Default, _SvgLengthContext.Width).val, y2 = new _SvgNumAttr(this, 'y2', 0, _SvgNumConversion.Default, _SvgLengthContext.Height).val;
        this.ctx.area.paths
            .moveTo(x1, y1)
            .lineTo(x2, y2);
    };
    return _SvgLineElementImpl;
}(_SvgShapeElementBase));
exports._SvgLineElementImpl = _SvgLineElementImpl;
var _SvgPathElementImpl = (function (_super) {
    __extends(_SvgPathElementImpl, _super);
    function _SvgPathElementImpl(ctx, node) {
        var _this = _super.call(this, ctx, node) || this;
        _this._d = new _SvgStrAttr(_this, 'd');
        return _this;
    }
    _SvgPathElementImpl.prototype._renderContent = function () {
        var area = this.ctx.area;
        if (this.renderMode === _SvgRenderMode.Clip) {
            if (this._d.hasVal) {
                var path = _PdfSvgPathHelper.scale(this._d.val, 0.75);
                this.attr('d', path);
                this._d.reset();
            }
            _super.prototype._renderContent.call(this);
        }
        else {
            area._pdfdoc.saveState();
            area.scale(0.75);
            _super.prototype._renderContent.call(this);
            area._pdfdoc.restoreState();
        }
    };
    _SvgPathElementImpl.prototype._draw = function () {
        if (this._d.hasVal) {
            this.ctx.area.paths.svgPath(this._d.val);
        }
    };
    return _SvgPathElementImpl;
}(_SvgShapeElementBase));
exports._SvgPathElementImpl = _SvgPathElementImpl;
var _SvgPolylineElementImpl = (function (_super) {
    __extends(_SvgPolylineElementImpl, _super);
    function _SvgPolylineElementImpl() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    _SvgPolylineElementImpl.prototype._draw = function () {
        var _points = new _SvgPointsArrayAttr(this, 'points');
        if (_points.hasVal) {
            var points = _points.val, area = this.ctx.area;
            if (points.length > 1) {
                for (var i = 0; i < points.length; i++) {
                    if (i == 0) {
                        area.paths.moveTo(points[i].x, points[i].y);
                    }
                    else {
                        area.paths.lineTo(points[i].x, points[i].y);
                    }
                }
                return true;
            }
        }
        return false;
    };
    return _SvgPolylineElementImpl;
}(_SvgShapeElementBase));
exports._SvgPolylineElementImpl = _SvgPolylineElementImpl;
var _SvgPolygonElementImpl = (function (_super) {
    __extends(_SvgPolygonElementImpl, _super);
    function _SvgPolygonElementImpl() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    _SvgPolygonElementImpl.prototype._draw = function () {
        if (_super.prototype._draw.call(this)) {
            this.ctx.area.paths.closePath();
            return true;
        }
        return false;
    };
    return _SvgPolygonElementImpl;
}(_SvgPolylineElementImpl));
exports._SvgPolygonElementImpl = _SvgPolygonElementImpl;
var _SvgRectElementImpl = (function (_super) {
    __extends(_SvgRectElementImpl, _super);
    function _SvgRectElementImpl() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    _SvgRectElementImpl.prototype._draw = function () {
        var w = new _SvgNumAttr(this, 'width', 0, _SvgNumConversion.Default, _SvgLengthContext.Width).val, h = new _SvgNumAttr(this, 'height', 0, _SvgNumConversion.Default, _SvgLengthContext.Height).val;
        if (w > 0 && h > 0) {
            var x = new _SvgNumAttr(this, 'x', 0, _SvgNumConversion.Default, _SvgLengthContext.Width).val, y = new _SvgNumAttr(this, 'y', 0, _SvgNumConversion.Default, _SvgLengthContext.Height).val, rx = Math.max(new _SvgNumAttr(this, 'rx', 0, _SvgNumConversion.Default, _SvgLengthContext.Width).val, 0), ry = Math.max(new _SvgNumAttr(this, 'ry', 0, _SvgNumConversion.Default, _SvgLengthContext.Height).val, 0), paths = this.ctx.area.paths;
            if (rx || ry) {
                rx = Math.min(rx || ry, w / 2);
                ry = Math.min(ry || rx, h / 2);
                paths.moveTo(x + rx, y);
                paths.lineTo(x + w - rx, y);
                paths.quadraticCurveTo(x + w, y, x + w, y + ry);
                paths.lineTo(x + w, y + h - ry);
                paths.quadraticCurveTo(x + w, y + h, x + w - rx, y + h);
                paths.lineTo(x + rx, y + h);
                paths.quadraticCurveTo(x, y + h, x, y + h - ry);
                paths.lineTo(x, y + ry);
                paths.quadraticCurveTo(x, y, x + rx, y);
            }
            else {
                paths.rect(x, y, w, h);
            }
        }
    };
    return _SvgRectElementImpl;
}(_SvgShapeElementBase));
exports._SvgRectElementImpl = _SvgRectElementImpl;
var _SvgClipPathElementImpl = (function (_super) {
    __extends(_SvgClipPathElementImpl, _super);
    function _SvgClipPathElementImpl(ctx, node) {
        return _super.call(this, ctx, node, _SvgRenderMode.Ignore) || this;
    }
    return _SvgClipPathElementImpl;
}(_SvgElementBase));
exports._SvgClipPathElementImpl = _SvgClipPathElementImpl;
var _SvgDefsElementImpl = (function (_super) {
    __extends(_SvgDefsElementImpl, _super);
    function _SvgDefsElementImpl(ctx, node) {
        return _super.call(this, ctx, node, _SvgRenderMode.Ignore) || this;
    }
    return _SvgDefsElementImpl;
}(_SvgClippableElementBase));
exports._SvgDefsElementImpl = _SvgDefsElementImpl;
var _SvgGElementImpl = (function (_super) {
    __extends(_SvgGElementImpl, _super);
    function _SvgGElementImpl() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return _SvgGElementImpl;
}(_SvgTransformableElementBase));
exports._SvgGElementImpl = _SvgGElementImpl;
var _SvgLinearGradientElementImpl = (function (_super) {
    __extends(_SvgLinearGradientElementImpl, _super);
    function _SvgLinearGradientElementImpl(ctx, node) {
        var _this = _super.call(this, ctx, node, _SvgRenderMode.Ignore) || this;
        _this._x1 = new _SvgStrAttr(_this, 'x1', '0%');
        _this._x2 = new _SvgStrAttr(_this, 'x2', '100%');
        _this._y1 = new _SvgStrAttr(_this, 'y1', '0%');
        _this._y2 = new _SvgStrAttr(_this, 'y2', '0%');
        _this._gradientUnits = new _SvgStrAttr(_this, 'gradientUnits', 'objectBoundingBox');
        return _this;
    }
    _SvgLinearGradientElementImpl.prototype.toBrush = function (element) {
        var rect = new wjcCore.Rect(new _SvgNumAttr(element, 'x', 0, _SvgNumConversion.Default, _SvgLengthContext.Width).val, new _SvgNumAttr(element, 'y', 0, _SvgNumConversion.Default, _SvgLengthContext.Height).val, new _SvgNumAttr(element, 'width', 0, _SvgNumConversion.Default, _SvgLengthContext.Width).val, new _SvgNumAttr(element, 'height', 0, _SvgNumConversion.Default, _SvgLengthContext.Height).val), vp = (this._gradientUnits.val === 'objectBoundingBox')
            ? new wjcCore.Size(rect.width, rect.height)
            : element.viewport.clone();
        var x1 = _SvgNumAttr.parseValue(this._x1.val, _SvgAttrType.Number, vp, _SvgLengthContext.Width, _SvgNumConversion.Default), x2 = _SvgNumAttr.parseValue(this._x2.val, _SvgAttrType.Number, vp, _SvgLengthContext.Width, _SvgNumConversion.Default), y1 = _SvgNumAttr.parseValue(this._y1.val, _SvgAttrType.Number, vp, _SvgLengthContext.Height, _SvgNumConversion.Default), y2 = _SvgNumAttr.parseValue(this._y2.val, _SvgAttrType.Number, vp, _SvgLengthContext.Height, _SvgNumConversion.Default), stops = [];
        for (var i = 0; i < this.children.length; i++) {
            if (this.children[i] instanceof _SvgStopElementImpl) {
                var stop = this.children[i];
                stops.push(new PdfGradientStop(_SvgNumAttr.parseValue(stop.offset.val, _SvgAttrType.Number, vp, _SvgLengthContext.Other, _SvgNumConversion.Default), stop.color.val, stop.opacity.val));
            }
        }
        return new PdfLinearGradientBrush(rect.left + x1, rect.top + y1, rect.left + x2, rect.top + y2, stops);
    };
    return _SvgLinearGradientElementImpl;
}(_SvgElementBase));
exports._SvgLinearGradientElementImpl = _SvgLinearGradientElementImpl;
var _SvgStopElementImpl = (function (_super) {
    __extends(_SvgStopElementImpl, _super);
    function _SvgStopElementImpl(ctx, node) {
        var _this = _super.call(this, ctx, node, _SvgRenderMode.Ignore) || this;
        _this.color = new _SvgColorAttr(_this, 'stop-color', 'black');
        _this.opacity = new _SvgNumAttr(_this, 'stop-opacity', 1, _SvgNumConversion.None, undefined, true);
        _this.offset = new _SvgStrAttr(_this, 'offset', '0');
        return _this;
    }
    return _SvgStopElementImpl;
}(_SvgElementBase));
exports._SvgStopElementImpl = _SvgStopElementImpl;
var _SvgImageElementImpl = (function (_super) {
    __extends(_SvgImageElementImpl, _super);
    function _SvgImageElementImpl(ctx, node) {
        var _this = _super.call(this, ctx, node) || this;
        _this._x = new _SvgNumAttr(_this, 'x', 0, _SvgNumConversion.Default, _SvgLengthContext.Width);
        _this._y = new _SvgNumAttr(_this, 'y', 0, _SvgNumConversion.Default, _SvgLengthContext.Height);
        _this._width = new _SvgNumAttr(_this, 'width', 0, _SvgNumConversion.Default, _SvgLengthContext.Width);
        _this._height = new _SvgNumAttr(_this, 'height', 0, _SvgNumConversion.Default, _SvgLengthContext.Height);
        _this._href = new _SvgHRefAttr(_this, 'xlink:href');
        _this._par = new _SvgPreserveAspectRatioAttr(_this);
        return _this;
    }
    _SvgImageElementImpl.prototype._renderContent = function () {
        var width = this._width.val, height = this._height.val;
        if (width > 0 && height > 0 && this._href.hasVal) {
            var url = _resolveUrlIfRelative(this._href.val, this.ctx.urlResolver);
            if (url) {
                this.ctx.area._pdfdoc.saveState();
                if (this._x.val || this._y.val) {
                    this.ctx.area.translate(this._x.val, this._y.val);
                }
                this.viewport = new wjcCore.Size(width, height);
                try {
                    if (this._href.val.match(/\.svg$/i)) {
                        this._renderSvgImage(url);
                    }
                    else {
                        this._renderRasterImage(url);
                    }
                }
                catch (ex) {
                }
                this.ctx.area._pdfdoc.restoreState();
            }
        }
    };
    _SvgImageElementImpl.prototype._renderSvgImage = function (url) {
        var xhrError, str = _XhrHelper.text(url, function (xhr) { return xhrError = xhr.statusText; });
        wjcCore.assert(xhrError == null, xhrError);
        var svg = new _SvgRenderer(str, this.ctx.area), r = svg.root;
        this.attr('viewBox', r.attr('viewBox'));
        r.clearAttr('viewBox');
        r.clearAttr('x');
        r.clearAttr('y');
        r.clearAttr('width');
        r.clearAttr('height');
        r.clearAttr('preserveAspectRatio');
        r.clearAttr('clip');
        r.clearAttr('overflow');
        this.ctx.area.paths.rect(0, 0, this.viewport.width, this.viewport.height).clip();
        var scale = new _SvgScaleAttributes(this);
        svg.render(scale.apply(this));
    };
    _SvgImageElementImpl.prototype._renderRasterImage = function (url) {
        var dataUri = _PdfImageHelper.getDataUri(url), ar = this._par.val, opt = {
            width: this.viewport.width,
            height: this.viewport.height,
            align: PdfImageHorizontalAlign.Left,
            vAlign: PdfImageVerticalAlign.Top
        };
        if (ar.align === 'none') {
            opt.stretchProportionally = false;
        }
        else {
            opt.stretchProportionally = true;
            if (ar.align.match(/^xMid/)) {
                opt.align = PdfImageHorizontalAlign.Center;
            }
            else {
                if (ar.align.match(/^xMax/)) {
                    opt.align = PdfImageHorizontalAlign.Right;
                }
            }
            if (ar.align.match(/YMid$/)) {
                opt.vAlign = PdfImageVerticalAlign.Center;
            }
            else {
                if (ar.align.match(/YMax$/)) {
                    opt.vAlign = PdfImageVerticalAlign.Bottom;
                }
            }
        }
        this.ctx.area.drawImage(dataUri, 0, 0, opt);
    };
    return _SvgImageElementImpl;
}(_SvgTransformableElementBase));
exports._SvgImageElementImpl = _SvgImageElementImpl;
var _SvgStyleElementImpl = (function (_super) {
    __extends(_SvgStyleElementImpl, _super);
    function _SvgStyleElementImpl(ctx, node) {
        var _this = _super.call(this, ctx, node, _SvgRenderMode.Ignore) || this;
        if (node && (!node.type || node.type === 'text/css')) {
            var css = '';
            for (var i = 0; i < node.childNodes.length; i++) {
                css += node.childNodes[i].textContent;
            }
            css = _compressSpaces(css);
            css = css.replace(/\/\*([^*]|\*+[^*/])*\*+\//gm, '');
            var rules = css.match(/[^{}]*{[^}]*}/g);
            if (rules) {
                for (var i = 0; i < rules.length; i++) {
                    var rule = rules[i].match(/([^{}]*){([^}]*)}/);
                    if (rule) {
                        var selectors = rule[1].trim().split(','), declaration = rule[2].trim();
                        if (selectors.length && declaration) {
                            selectors.forEach(function (selector) {
                                if (selector = selector.trim()) {
                                    _this.ctx.registerCssRule(new _SvgCssRule(selector, declaration));
                                }
                            });
                        }
                    }
                }
            }
        }
        return _this;
    }
    return _SvgStyleElementImpl;
}(_SvgElementBase));
exports._SvgStyleElementImpl = _SvgStyleElementImpl;
var _SvgSvgElementImpl = (function (_super) {
    __extends(_SvgSvgElementImpl, _super);
    function _SvgSvgElementImpl(ctx, node) {
        var _this = _super.call(this, ctx, node) || this;
        _this._x = new _SvgNumAttr(_this, 'x', 0, _SvgNumConversion.Default, _SvgLengthContext.Width);
        _this._y = new _SvgNumAttr(_this, 'y', 0, _SvgNumConversion.Default, _SvgLengthContext.Height);
        _this._width = new _SvgNumAttr(_this, 'width', '100%', _SvgNumConversion.Default, _SvgLengthContext.Width);
        _this._height = new _SvgNumAttr(_this, 'height', '100%', _SvgNumConversion.Default, _SvgLengthContext.Height);
        _this._scale = new _SvgScaleAttributes(_this);
        _this._overflow = new _SvgStrAttr(_this, 'overflow', 'hidden');
        return _this;
    }
    Object.defineProperty(_SvgSvgElementImpl.prototype, "width", {
        get: function () {
            return this._width;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(_SvgSvgElementImpl.prototype, "height", {
        get: function () {
            return this._height;
        },
        enumerable: true,
        configurable: true
    });
    _SvgSvgElementImpl.prototype._render = function () {
        var area = this.ctx.area;
        area._pdfdoc.saveState();
        var width = this._width.val, height = this._height.val, x = this._x.val, y = this._y.val;
        if (this.parent && (x || y)) {
            area.translate(x, y);
        }
        this.viewport = new wjcCore.Size(width, height);
        if (this._overflow.val !== 'visible') {
            area.paths.rect(0, 0, width, height).clip();
        }
        this.viewport = this._scale.apply(this);
        if (this.viewport.width > 0 && this.viewport.height > 0) {
            _super.prototype._render.call(this);
        }
        area._pdfdoc.restoreState();
    };
    return _SvgSvgElementImpl;
}(_SvgClippableElementBase));
exports._SvgSvgElementImpl = _SvgSvgElementImpl;
var _SvgSymbolElementImpl = (function (_super) {
    __extends(_SvgSymbolElementImpl, _super);
    function _SvgSymbolElementImpl(ctx, node) {
        return _super.call(this, ctx, node, _SvgRenderMode.Ignore) || this;
    }
    return _SvgSymbolElementImpl;
}(_SvgClippableElementBase));
exports._SvgSymbolElementImpl = _SvgSymbolElementImpl;
var _SvgUseElementImpl = (function (_super) {
    __extends(_SvgUseElementImpl, _super);
    function _SvgUseElementImpl(ctx, node) {
        var _this = _super.call(this, ctx, node) || this;
        _this._xlink = new _SvgIdRefAttr(_this, 'xlink:href');
        return _this;
    }
    _SvgUseElementImpl.prototype._render = function () {
        var ref, foo;
        if (!this._xlink.hasVal || !(ref = this.ctx.getElement(this._xlink.val))) {
            return;
        }
        var g = new _SvgGElementImpl(this.ctx, null);
        g.parent = this.parent;
        g.copyAttributesFrom(this, ['x', 'y', 'width', 'height', 'xlink:href']);
        if (this.attr('x') != null || this.attr('y') != null) {
            var trans = wjcCore.format('translate({x},{y})', { x: this.attr('x') || 0, y: this.attr('y') || 0 });
            g.attr('transform', (foo = g.attr('transform')) ? foo + ' ' + trans : trans);
        }
        if (ref instanceof _SvgSymbolElementImpl) {
            var svg = new _SvgSvgElementImpl(this.ctx, null);
            svg.copyAttributesFrom(ref);
            for (var i = 0; i < ref.children.length; i++) {
                svg.appendNode(ref.children[i].clone());
            }
            g.appendNode(svg);
            svg.attr('width', this.attr('width') || '100%');
            svg.attr('height', this.attr('height') || '100%');
        }
        else {
            ref = ref.clone();
            g.appendNode(ref);
            if (ref instanceof _SvgSvgElementImpl) {
                if ((foo = this.attr('width')) != null) {
                    ref.attr('width', foo);
                }
                if ((foo = this.attr('height')) != null) {
                    ref.attr('height', foo);
                }
            }
        }
        g.render(this.viewport, this.renderMode);
    };
    return _SvgUseElementImpl;
}(_SvgElementBase));
exports._SvgUseElementImpl = _SvgUseElementImpl;
var _SvgTextElementImpl = (function (_super) {
    __extends(_SvgTextElementImpl, _super);
    function _SvgTextElementImpl(ctx, node) {
        var _this = _super.call(this, ctx, node) || this;
        _this._x = new _SvgNumAttr(_this, 'x', 0, _SvgNumConversion.Default, _SvgLengthContext.Width);
        _this._y = new _SvgNumAttr(_this, 'y', 0, _SvgNumConversion.Default, _SvgLengthContext.Height);
        _this._dx = new _SvgNumAttr(_this, 'dx', 0, _SvgNumConversion.Default, _SvgLengthContext.Width);
        _this._dy = new _SvgNumAttr(_this, 'dy', 0, _SvgNumConversion.Default, _SvgLengthContext.Height);
        _this._textDecoration = new _SvgTextDecorationAttr(_this);
        return _this;
    }
    _SvgTextElementImpl.prototype._render = function () {
        if (this.renderMode === _SvgRenderMode.Render) {
            _super.prototype._render.call(this);
        }
    };
    _SvgTextElementImpl.prototype._renderContent = function () {
        var _this = this;
        this._prepareNodes();
        var cx = this._x.val + this._dx.val, cy = this._y.val + this._dy.val, func = function (node, decorators) {
            if (node._x.hasVal) {
                cx = node._x.val;
            }
            if (node._y.hasVal) {
                cy = node._y.val;
            }
            cx += node._dx.val;
            cy += node._dy.val;
            if (node._text) {
                node._cx = cx;
                node._cy = cy;
                node._setDecorators(decorators);
                node.render(_this.viewport, _this.renderMode);
                cx += _this.ctx.area.measureText(node._text, node.style.font.toFont(), {
                    width: Infinity,
                    height: Infinity,
                    includeLastLineExternalLeading: false
                }).size.width;
            }
            else {
                for (var i = 0; i < node.children.length; i++) {
                    var dec = decorators.slice();
                    dec.push({ decoration: node._textDecoration, style: node.style });
                    func(node.children[i], dec);
                }
            }
        };
        for (var i = 0; i < this.children.length; i++) {
            func(this.children[i], [{ decoration: this._textDecoration, style: this.style }]);
        }
    };
    _SvgTextElementImpl.prototype._prepareNodes = function () {
        var removeEmptyNodes = function (node) {
            for (var i = 0; i < node.children.length; i++) {
                var child = node.children[i];
                if (!child._text && removeEmptyNodes(child)) {
                    child.remove();
                }
            }
            return node.children.length === 0;
        };
        var list = [];
        var buildTextList = function (node) {
            for (var i = 0; i < node.children.length; i++) {
                var child = node.children[i];
                if (child._text) {
                    list.push(child);
                }
                else {
                    buildTextList(child);
                }
            }
        };
        removeEmptyNodes(this);
        buildTextList(this);
        for (var i = 0; i < list.length; i++) {
            var len = list.length;
            if (list[i]._text === ' ' && ((i === 0) ||
                (i === len - 1) ||
                (i < len - 1 && list[i + 1]._text === ' '))) {
                list[i].remove();
                list.splice(i, 1);
                i--;
            }
        }
    };
    return _SvgTextElementImpl;
}(_SvgTransformableElementBase));
exports._SvgTextElementImpl = _SvgTextElementImpl;
var _SvgTspanElementImpl = (function (_super) {
    __extends(_SvgTspanElementImpl, _super);
    function _SvgTspanElementImpl(ctx, node, text) {
        var _this = _super.call(this, ctx, node) || this;
        _this._textDecoration = new _SvgTextDecorationAttr(_this);
        _this._text = wjcCore.asString(text);
        _this._x = new _SvgNumAttr(_this, 'x', 0, _SvgNumConversion.Default, _SvgLengthContext.Width);
        _this._y = new _SvgNumAttr(_this, 'y', 0, _SvgNumConversion.Default, _SvgLengthContext.Height);
        _this._dx = new _SvgNumAttr(_this, 'dx', 0, _SvgNumConversion.Default, _SvgLengthContext.Width);
        _this._dy = new _SvgNumAttr(_this, 'dy', 0, _SvgNumConversion.Default, _SvgLengthContext.Height);
        _this._textDecoration = new _SvgTextDecorationAttr(_this);
        return _this;
    }
    _SvgTspanElementImpl.prototype.clone = function () {
        var clone = _super.prototype.clone.call(this);
        clone._text = this._text;
        return clone;
    };
    _SvgTspanElementImpl.prototype._setDecorators = function (value) {
        this._decorators = value;
    };
    _SvgTspanElementImpl.prototype._renderContent = function () {
        if (this._text) {
            var opt = {
                font: this.style.font.toFont(),
                width: Infinity,
                height: Infinity,
                lineBreak: false,
                fill: this.style.fill.color.val !== 'none',
                stroke: this.style.stroke.color.val !== 'none',
                _baseline: _PdfTextBaseline.Alphabetic
            };
            this._decorate();
            if (opt.fill || opt.stroke) {
                if (opt.fill) {
                    opt.brush = this.style.fill.toBrush(this);
                }
                if (opt.stroke) {
                    opt.pen = this.style.stroke.toPen(this);
                }
                this.ctx.area.drawText(this._text, this._cx, this._cy, opt);
            }
        }
    };
    _SvgTspanElementImpl.prototype._decorate = function () {
        var area = this.ctx.area, hasValue = false;
        this._decorators.push({ decoration: this._textDecoration, style: this.style });
        for (var i = 0; i < this._decorators.length && !hasValue; i++) {
            hasValue = this._decorators[i].decoration.val != null;
        }
        if (hasValue) {
            area._pdfdoc.saveState();
            var d = area._pdfdoc._document, sz = area.measureText(this._text, this.style.font.toFont(), {
                width: Infinity,
                height: Infinity,
                includeLastLineExternalLeading: false
            }).size, lineHeight = Math.max(d.currentFontSize() / 20, 0.1), ascender = d.currentFontAscender(), x = this._cx;
            for (var dec; dec = this._decorators.shift();) {
                var decVal = dec.decoration.val;
                if (decVal) {
                    for (var j = 0; j < decVal.length; j++) {
                        var y = this._cy - ascender;
                        switch (decVal[j]) {
                            case 'line-through':
                                y = y + sz.height / 2 - lineHeight / 2;
                                break;
                            case 'overline':
                                y = y - (d.currentFontBBox().ury - d.currentFontAscender());
                                break;
                            case 'underline':
                                y = y + sz.height - lineHeight * 1.5;
                                break;
                        }
                        area.paths.rect(x, y, sz.width, lineHeight);
                    }
                    dec.style.apply(this, true, true);
                }
            }
            area._pdfdoc.restoreState();
        }
    };
    return _SvgTspanElementImpl;
}(_SvgClippableElementBase));
exports._SvgTspanElementImpl = _SvgTspanElementImpl;
'use strict;';
var _SvgRenderer = (function () {
    function _SvgRenderer(svgString, area, urlResolver) {
        var _this = this;
        this._elementsById = {};
        this._registeredCssRules = {};
        wjcCore.assert(area != null, exports._Errors.ValueCannotBeEmpty('svgString'));
        this._doc = area._pdfdoc;
        var dom = this._parse(svgString);
        if (dom) {
            this._svg = new _SvgSvgElementImpl({
                area: area,
                urlResolver: urlResolver,
                getElement: this._getElementById.bind(this),
                registerCssRule: function (rule) {
                    _this._registerCssRule(rule, urlResolver);
                }
            }, null);
            this._copyAttributes(dom, this._svg);
            this._buildTree(dom, this._svg);
            this._svg.viewport = new wjcCore.Size(area.width, area.height);
        }
    }
    Object.defineProperty(_SvgRenderer.prototype, "root", {
        get: function () {
            return this._svg;
        },
        enumerable: true,
        configurable: true
    });
    _SvgRenderer.prototype.render = function (viewPort) {
        if (this._svg) {
            this._svg.render(viewPort || this._svg.viewport);
        }
    };
    _SvgRenderer.prototype._parse = function (svg) {
        if (svg) {
            var parser = new DOMParser();
            parser.async = false;
            return parser.parseFromString(svg, 'text/xml').getElementsByTagName('svg')[0];
        }
    };
    _SvgRenderer.prototype._buildTree = function (dom, tree, handleTextNodes) {
        for (var i = 0; dom.childNodes && i < dom.childNodes.length; i++) {
            var domChild = dom.childNodes.item(i), nodeName = domChild.nodeName;
            if (domChild.nodeType === 1) {
                var className = this._getClassName(nodeName);
                if (wjcSelf[className]) {
                    var element = new wjcSelf[className](tree.ctx, domChild);
                    this._copyAttributes(domChild, element);
                    tree.appendNode(element);
                    var id;
                    if (id = domChild.getAttribute('id')) {
                        this._elementsById[id] = element;
                    }
                    this._buildTree(domChild, element, nodeName === 'text' || (handleTextNodes && nodeName === 'tspan'));
                }
                else {
                }
            }
            else {
                if (domChild.nodeType === 3 && handleTextNodes) {
                    var textContent = domChild.textContent.trim();
                    if (textContent) {
                        if (i != 0 && dom.childNodes[i - 1].nodeType === 1 && domChild.textContent.match(/^\s/)) {
                            tree.appendNode(new _SvgTspanElementImpl(tree.ctx, null, ' '));
                        }
                        var text = _compressSpaces(domChild.textContent);
                        tree.appendNode(new _SvgTspanElementImpl(tree.ctx, null, text));
                    }
                    if (!textContent || domChild.textContent.match(/\s$/)) {
                        tree.appendNode(new _SvgTspanElementImpl(tree.ctx, null, ' '));
                    }
                }
            }
        }
    };
    _SvgRenderer.prototype._getClassName = function (nodeName) {
        return '_Svg' + nodeName.charAt(0).toUpperCase() + nodeName.substring(1) + 'ElementImpl';
    };
    _SvgRenderer.prototype._copyAttributes = function (node, element) {
        for (var i = 0; i < node.attributes.length; i++) {
            var attr = node.attributes.item(i);
            element.attr(attr.name, attr.value);
        }
        var css = _SvgCssHelper.getComputedStyle(node, this._registeredCssRules);
        for (var i = 0, keys = Object.keys(css); i < keys.length; i++) {
            var name = keys[i];
            element.attr(name, css[name]);
        }
    };
    _SvgRenderer.prototype._getElementById = function (id) {
        id = (id || '').replace('#', '');
        return this._elementsById[id];
    };
    _SvgRenderer.prototype._registerCssRule = function (rule, urlResolver) {
        if (rule.selector[0] !== '@') {
            this._registeredCssRules[rule.selector] = rule;
        }
        else {
            if (rule.selector === '@font-face') {
                _SvgCssHelper.registerFontFace(this._doc, rule, urlResolver);
            }
        }
    };
    return _SvgRenderer;
}());
exports._SvgRenderer = _SvgRenderer;
//# sourceMappingURL=wijmo.pdf.js.map